<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hedge Metrics Dashboard</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
        background: #111;
        color: #f2f4f8;
      }

      body {
        margin: 0;
        padding: 2rem;
        max-width: 960px;
        margin-inline: auto;
      }

      h1 {
        font-size: 1.75rem;
        margin-bottom: 0.5rem;
      }

      .subtitle {
        color: #8a94a6;
        margin-bottom: 2rem;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.25rem;
      }

      .card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .spread-section {
        margin-top: 2.5rem;
      }

      .strategy-section {
        margin-top: 2.5rem;
      }

      .strategy-card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
        margin-top: 1rem;
      }

      .grvt-section {
        margin-top: 2.5rem;
      }

      .grvt-card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .vol-section {
        margin-top: 2.5rem;
      }

      .sim-section {
        margin-top: 2.5rem;
      }

      .sim-card {
        background: #101522;
        border-radius: 16px;
        padding: 1.5rem;
        border: 1px solid rgba(255, 255, 255, 0.05);
        box-shadow: 0 22px 46px rgba(0, 0, 0, 0.4);
      }

      .sim-summary {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 1rem;
        margin-bottom: 1.25rem;
      }

      .sim-label {
        margin: 0;
        font-size: 0.78rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .sim-value {
        margin: 0.25rem 0 0;
        font-size: 1.8rem;
        font-weight: 600;
      }

      .sim-controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
        margin-bottom: 1.25rem;
      }

      .sim-controls label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.85rem;
        color: #c7d2e8;
      }

      .sim-controls input[type="number"],
      .sim-controls input[type="range"] {
        width: 100%;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: #0f131d;
        color: #f5f7fb;
        padding: 0.5rem 0.75rem;
        font-size: 0.95rem;
      }

      .sim-controls input[type="range"] {
        appearance: none;
        height: 4px;
        padding: 0;
        background: linear-gradient(120deg, #4f9cff, #7c4dff);
      }

      .sim-slider-note {
        font-size: 0.78rem;
        color: #8a94a6;
      }

      .sim-optimize-row {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin: -0.25rem 0 1rem;
      }

      .sim-optimize-row button {
        padding: 0.5rem 1.25rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: transparent;
        color: #f5f7fb;
        font-size: 0.9rem;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease;
      }

      .sim-optimize-row button:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.2);
      }

      .sim-optimize-row button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #sim-chart {
        width: 100%;
        height: 320px;
      }

      .sim-status {
        margin-top: 0.65rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .vol-card {
        background: #121621;
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: 0 22px 46px rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .vol-symbol-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1.25rem;
      }

      .vol-symbol-card {
        background: #171c2b;
        border-radius: 14px;
        padding: 1.1rem 1.25rem;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .vol-symbol-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
        margin-bottom: 0.85rem;
      }

      .vol-symbol-label {
        margin: 0;
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        color: #7f8fa9;
        text-transform: uppercase;
      }

      .vol-price {
        margin: 0.2rem 0 0;
        font-size: 1.4rem;
        font-weight: 600;
        color: #f5f7fb;
      }

      .vol-updated-note {
        margin: 0;
        font-size: 0.8rem;
        color: #8a94a6;
        text-align: right;
      }

      .vol-metric-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.82rem;
      }

      .vol-metric-table th,
      .vol-metric-table td {
        padding: 0.4rem 0.45rem;
        text-align: center;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        white-space: nowrap;
      }

      .vol-metric-table th:first-child,
      .vol-metric-table td:first-child {
        text-align: left;
      }

      .vol-positive {
        color: #7ee787;
      }

      .vol-negative {
        color: #ff8787;
      }

      .vol-neutral {
        color: #c7d2e8;
      }

      .vol-hedge-card {
        margin-top: 1.5rem;
        padding: 1.2rem 1.35rem;
        border-radius: 14px;
        background: #141a28;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .vol-hedge-card h3 {
        margin: 0 0 0.35rem;
        font-size: 1rem;
      }

      .vol-hedge-pair {
        margin: 0 0 0.75rem;
        font-size: 0.9rem;
        color: #8a94a6;
      }

      .vol-badge {
        background: #1e2535;
        padding: 0.2rem 0.55rem;
        border-radius: 999px;
        font-size: 0.72rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }

      .vol-alert {
        color: #ffb3c1;
      }

      .grvt-summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.25rem;
        margin-bottom: 1.75rem;
      }

      .grvt-chart-grid {
        margin-top: 1.5rem;
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 1.25rem;
      }

      .grvt-chart-card {
        padding: 1.25rem 1.5rem 1.1rem;
        border-radius: 16px;
        background: #101522;
        border: 1px solid rgba(255, 255, 255, 0.04);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
      }

      .grvt-chart-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 1rem;
        margin-bottom: 0.75rem;
      }

      .grvt-chart-header h3 {
        margin: 0;
        font-size: 1rem;
      }

      .grvt-chart-card canvas {
        width: 100%;
        height: 300px;
      }

      .chart-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 1.25rem;
        margin-top: 0.85rem;
        font-size: 0.82rem;
        color: #8a94a6;
      }

      .chart-legend span {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
      }

      .legend-dot {
        width: 0.65rem;
        height: 0.65rem;
        border-radius: 999px;
        display: inline-flex;
      }

      .legend-btc {
        background: linear-gradient(135deg, #f6c177, #f4b453);
      }

      .legend-eth {
        background: linear-gradient(135deg, #7fe9ff, #4cc9f0);
      }

      .legend-transfer {
        background: linear-gradient(135deg, #c084fc, #8b5cf6);
      }

      .legend-diff {
        background: linear-gradient(135deg, #7dd3fc, #38bdf8);
      }

      .grvt-summary-card h3 {
        margin: 0 0 0.35rem;
        font-size: 0.9rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .grvt-summary-card .value {
        font-size: 1.75rem;
        font-weight: 600;
      }

      .grvt-summary-updated {
        margin-top: 0.4rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-risk-detail {
        margin-top: 0.35rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .risk-pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.35rem 0.85rem;
        border-radius: 999px;
        font-weight: 600;
        letter-spacing: 0.04em;
        background: rgba(255, 255, 255, 0.08);
        color: #f5f7fb;
        transition: background 0.25s ease, color 0.25s ease, box-shadow 0.25s ease;
        box-shadow: 0 0 0 rgba(0, 0, 0, 0);
      }

      .risk-pill-summary {
        font-size: 1.35rem;
        min-width: 6rem;
      }

      .risk-pill-inline {
        font-size: 0.85rem;
        padding: 0.15rem 0.6rem;
        min-width: 0;
      }

      .grvt-account-grid {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 1.1rem;
      }

      .grvt-adjust-panel {
        margin-top: 1.5rem;
        padding: 1rem 1.25rem;
        border-radius: 12px;
        background: #1b1f2a;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-transfer-panel {
        margin-top: 1.25rem;
        padding: 1rem 1.25rem 1.25rem;
        border-radius: 12px;
        background: #141823;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .grvt-auto-panel {
        margin-top: 1.25rem;
        padding: 1rem 1.25rem 1.25rem;
        border-radius: 12px;
        background: #151a26;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-auto-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.85rem;
        margin-top: 0.85rem;
      }

      .grvt-auto-grid label {
        display: flex;
        flex-direction: column;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .grvt-auto-grid label small {
        margin-top: 0.35rem;
        font-size: 0.75rem;
        color: #6d768f;
      }

      .grvt-auto-grid input,
      .grvt-auto-grid select {
        margin-top: 0.35rem;
        background: #0f131d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.45rem 0.65rem;
        color: #f5f7fb;
        font-size: 0.9rem;
      }

      .grvt-auto-toggle {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 0.6rem 0.75rem;
        background: rgba(255, 255, 255, 0.03);
      }

      .grvt-auto-toggle span {
        font-weight: 600;
        margin-bottom: 0.25rem;
      }

      .grvt-auto-toggle small {
        color: #6d768f;
        margin-bottom: 0.5rem;
      }

      .grvt-auto-toggle input {
        width: auto;
        margin: 0;
        align-self: flex-start;
        transform: scale(1.2);
      }

      .grvt-risk-panel {
        margin-top: 1.5rem;
        padding: 1rem 1.25rem 1.25rem;
        border-radius: 14px;
        background: #101522;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .risk-status-pill {
        padding: 0.35rem 0.8rem;
        border-radius: 999px;
        font-size: 0.8rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        background: rgba(123, 140, 255, 0.15);
        color: #bcd0ff;
      }

      .risk-settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1rem;
        margin-top: 1rem;
      }

      .risk-settings-card {
        background: #0d111a;
        border-radius: 12px;
        padding: 1rem 1.1rem 1.2rem;
        border: 1px solid rgba(255, 255, 255, 0.04);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
      }

      .risk-slider-label {
        font-size: 0.85rem;
        font-weight: 600;
        color: #cfd6ea;
        display: inline-flex;
        justify-content: space-between;
        width: 100%;
      }

      .risk-slider {
        margin-top: 0.75rem;
      }

      .risk-slider input[type="range"] {
        width: 100%;
        accent-color: #7a62ff;
      }

      .risk-slider-scale {
        display: flex;
        justify-content: space-between;
        font-size: 0.7rem;
        color: #6d768f;
        margin-top: 0.35rem;
      }

      .risk-inline-inputs {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.85rem;
        margin-top: 1rem;
      }

      .risk-inline-inputs label,
      .risk-bark-grid label {
        font-size: 0.78rem;
        color: #8a94a6;
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }

      .risk-inline-inputs input,
      .risk-bark-grid input,
      .risk-bark-grid textarea {
        background: #090d14;
        border: 1px solid rgba(255, 255, 255, 0.07);
        border-radius: 8px;
        padding: 0.45rem 0.6rem;
        color: #f5f7fb;
        font-size: 0.9rem;
      }

      .risk-bark-grid textarea {
        min-height: 68px;
        resize: vertical;
      }

      .risk-bark-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.85rem;
      }

      .risk-toggle {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
        color: #e2e6f3;
      }

      .risk-toggle input {
        width: 1rem;
        height: 1rem;
      }

      .risk-settings-actions {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 0.85rem;
      }

      .risk-actions-left {
        display: flex;
        gap: 0.65rem;
        flex-wrap: wrap;
      }

      .risk-settings-message {
        margin: 0;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .risk-history-card {
        margin-top: 1.25rem;
        padding: 1rem 1.1rem 1.2rem;
        border-radius: 12px;
        background: #0d111a;
        border: 1px solid rgba(255, 255, 255, 0.04);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.015);
      }

      .risk-history-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      .risk-history-header h3 {
        margin: 0;
        font-size: 1rem;
      }

      .risk-history-status {
        margin: 0 0 0.75rem;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .risk-history-table-wrapper {
        max-height: 280px;
        overflow-y: auto;
        border: 1px solid rgba(255, 255, 255, 0.04);
        border-radius: 10px;
      }

      .risk-history-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.78rem;
      }

      .risk-history-table th,
      .risk-history-table td {
        padding: 0.45rem 0.6rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        text-align: left;
      }

      .risk-history-table th {
        font-size: 0.75rem;
        color: #8a94a6;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .risk-history-table td:last-child,
      .risk-history-table th:last-child {
        text-align: right;
      }

      .risk-history-empty {
        margin: 0;
        padding: 0.75rem;
        text-align: center;
        color: #8a94a6;
      }

      .risk-meta {
        margin: 0.85rem 0 0;
        font-size: 0.82rem;
        color: #8a94a6;
      }

      .grvt-auto-checkbox {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: 0.35rem;
      }

      .grvt-auto-checkbox input {
        width: auto;
        margin: 0;
      }

      .grvt-auto-checkbox span {
        color: #c7d2e8;
        font-size: 0.85rem;
      }

      .grvt-auto-actions {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
        margin-top: 1rem;
      }

      .grvt-auto-actions p {
        flex: 1;
        min-width: 240px;
        margin: 0;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-auto-status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
        margin-top: 1rem;
      }

      .grvt-auto-status-grid h4 {
        margin: 0 0 0.35rem;
        font-size: 0.85rem;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .grvt-auto-list {
        margin: 0;
        padding-left: 1.1rem;
        font-size: 0.85rem;
        color: #c7d2e8;
      }

      .grvt-auto-list li {
        margin-bottom: 0.2rem;
      }

      .grvt-auto-pair {
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-transfer-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.85rem;
        margin-top: 1rem;
      }

      .grvt-transfer-grid label {
        display: flex;
        flex-direction: column;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .grvt-transfer-grid input,
      .grvt-transfer-grid select,
      .grvt-transfer-grid textarea {
        margin-top: 0.35rem;
        background: #11141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.45rem 0.65rem;
        color: #f5f7fb;
        font-size: 0.9rem;
      }

      .grvt-transfer-grid textarea {
        min-height: 46px;
        resize: vertical;
      }

      .grvt-transfer-actions {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-top: 1.1rem;
        flex-wrap: wrap;
      }

      .grvt-transfer-status {
        flex: 1;
        min-width: 240px;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-transfer-history table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.78rem;
        margin-top: 0.9rem;
      }

      .grvt-transfer-history thead {
        background: rgba(255, 255, 255, 0.03);
      }

      .grvt-transfer-history th,
      .grvt-transfer-history td {
        padding: 0.4rem 0.5rem;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-adjust-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: flex-end;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .grvt-adjust-controls label {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-adjust-controls input {
        margin-top: 0.35rem;
        background: #11141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.4rem 0.65rem;
        color: #f5f7fb;
        min-width: 120px;
        font-size: 0.95rem;
      }

      .grvt-adjust-controls select {
        margin-top: 0.35rem;
        background: #11141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.4rem 0.65rem;
        color: #f5f7fb;
        font-size: 0.85rem;
        min-width: 140px;
      }

      .grvt-symbol-input {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .grvt-symbol-label {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        margin-bottom: 0.35rem;
        color: #8a94a6;
      }

      .grvt-symbol-label small {
        font-size: 0.75rem;
        color: #6d768f;
      }

      .grvt-symbol-reset {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.08);
        color: #f5f7fb;
        padding: 0.35rem 0.8rem;
        font-size: 0.78rem;
        cursor: pointer;
        transition: opacity 0.2s ease;
      }

      .grvt-symbol-reset:hover {
        opacity: 0.8;
      }

      .grvt-adjust-controls label.grvt-adjust-symbols {
        flex: 1;
        min-width: 200px;
        max-width: 240px;
      }

      .grvt-adjust-buttons {
        display: flex;
        gap: 0.75rem;
      }

      .grvt-adjust-status {
        flex: 1;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-adjust-history table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.78rem;
      }

      .grvt-adjust-history thead {
        background: rgba(255, 255, 255, 0.04);
      }

      .grvt-adjust-history th,
      .grvt-adjust-history td {
        padding: 0.4rem 0.5rem;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .adjust-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.15rem 0.5rem;
        border-radius: 999px;
        font-size: 0.7rem;
        margin: 0 0.25rem 0.25rem 0;
        background: rgba(255, 255, 255, 0.08);
      }

      .adjust-badge.status-pending {
        background: rgba(255, 255, 255, 0.08);
        color: #f5f7fb;
      }

      .adjust-badge.status-acknowledged {
        background: rgba(45, 206, 137, 0.15);
        color: #9ff3c9;
      }

      .adjust-badge.status-failed {
        background: rgba(239, 71, 111, 0.18);
        color: #ffb3c1;
      }

      .adjust-badge.status-expired {
        background: rgba(255, 193, 7, 0.18);
        color: #ffe8a3;
      }

      .grvt-account-card {
        background: #1f2533;
        border-radius: 12px;
        padding: 1.25rem;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-account-card header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        margin-bottom: 0.9rem;
      }

      .grvt-account-name {
        font-weight: 600;
        font-size: 1.05rem;
      }

      .grvt-account-updated {
        font-size: 0.75rem;
        color: #8a94a6;
      }

      .grvt-account-metrics {
        display: grid;
        gap: 0.45rem;
        margin: 0 0 0.75rem;
      }

      .grvt-account-metrics div {
        display: flex;
        justify-content: space-between;
        font-variant-numeric: tabular-nums;
        font-size: 0.9rem;
      }

      .grvt-account-metrics dt {
        margin: 0;
        text-transform: uppercase;
        font-size: 0.75rem;
        color: #7f8fa9;
        letter-spacing: 0.05em;
      }

      .grvt-account-metrics dd {
        margin: 0;
        font-weight: 600;
      }

      .grvt-positions-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.8rem;
      }

      .grvt-positions-table thead {
        background: rgba(255, 255, 255, 0.04);
      }

      .grvt-positions-table th,
      .grvt-positions-table td {
        padding: 0.4rem 0.45rem;
        text-align: right;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        white-space: nowrap;
      }

      .grvt-positions-table th:first-child,
      .grvt-positions-table td:first-child {
        text-align: left;
      }

      .grvt-positions-empty {
        margin: 0;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .grvt-source-badge {
        display: inline-flex;
        align-items: center;
        padding: 0.1rem 0.5rem;
        border-radius: 999px;
        font-size: 0.7rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        background: #1f2a38;
        color: #a4d5ff;
        margin-left: 0.5rem;
      }

      .strategy-summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1.25rem;
      }

      .summary-sub {
        margin-top: 0.5rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      #para-source-updates {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem 0.5rem;
        align-items: flex-start;
      }

      #para-source-updates .badge {
        flex: 1 1 70%;
        max-width: 70%;
        white-space: normal;
        overflow-wrap: anywhere;
      }

      .strategy-table-wrapper {
        margin-top: 1.5rem;
        overflow-x: auto;
      }

      .strategy-selector-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .strategy-selector-label select {
        background: #1f2533;
        color: #f5f7fb;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 6px;
        padding: 0.35rem 0.65rem;
        font-size: 0.85rem;
      }

      table.strategy-table td.action-enter {
        color: #7ee787;
      }

      table.strategy-table td.action-exit {
        color: #ffa94d;
      }

      table.strategy-table td.action-forced {
        color: #ff8787;
      }

      table.strategy-table td.action-other {
        color: #c7d2e8;
      }

      .spread-card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .spread-chart-wrapper {
        height: 280px;
        margin-bottom: 1.5rem;
      }

      .spread-chart-wrapper canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .spread-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin-bottom: 1rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .spread-table-wrapper {
        overflow-x: auto;
      }

      table.spread-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
      }

      table.spread-table thead {
        background: #222635;
      }

      table.spread-table th,
      table.spread-table td {
        padding: 0.65rem 0.75rem;
        text-align: right;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        white-space: nowrap;
      }

      table.spread-table th:first-child,
      table.spread-table td:first-child {
        text-align: left;
      }

      .spread-selector-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .spread-selector-label select {
        background: #1f2533;
        color: #f5f7fb;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 6px;
        padding: 0.35rem 0.65rem;
        font-size: 0.85rem;
      }

      .card h2 {
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        margin: 0 0 0.75rem;
        color: #7f8fa9;
      }

      .value {
        font-size: 2rem;
        font-weight: 600;
      }

      #runtime.runtime-multiple {
        font-size: 1.15rem;
        font-weight: 500;
        line-height: 1.4;
      }

      #runtime .runtime-row {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 0.75rem;
      }

      #runtime .runtime-row + .runtime-row {
        margin-top: 0.35rem;
      }

      #runtime .runtime-row-label {
        font-weight: 600;
        color: #c7d2e8;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        font-size: 0.9rem;
      }

      #runtime .runtime-row-value {
        font-variant-numeric: tabular-nums;
        color: #f2f4f8;
        font-size: 1rem;
      }

      .updated {
        margin-top: 2rem;
        color: #7f8fa9;
        font-size: 0.85rem;
      }

      .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem 1.25rem;
        margin-top: 2.5rem;
        margin-bottom: 1rem;
      }

      .section-header-info {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .section-header h2 {
        margin: 0;
        font-size: 1.25rem;
      }

      .section-header-controls {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        padding: 0.15rem 0.6rem;
        border-radius: 999px;
        font-size: 0.72rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        background: #273042;
        color: #c7d2e8;
      }

      .badge-group {
        display: inline-flex;
        gap: 0.35rem;
        align-items: center;
      }

      .badge-muted {
        background: #1f2533;
        color: #8a94a6;
      }

      .badge-warn {
        background: #4a1f1f;
        color: #ffc9c9;
      }

      .badge-info {
        background: #19314d;
        color: #a4d5ff;
      }

      .agent-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1.25rem;
      }

      .agent-card {
        transition: box-shadow 0.25s ease, transform 0.25s ease;
        border: 1px solid transparent;
      }

      .agent-card.recent {
        box-shadow: 0 0 0 2px rgba(76, 201, 240, 0.25);
      }

      .agent-card.stale {
        border-color: rgba(255, 171, 64, 0.45);
        opacity: 0.7;
      }

      .agent-card.paused {
        border-color: rgba(125, 140, 170, 0.35);
        background: #202431;
      }

      .agent-card header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.1rem;
      }

      .agent-name {
        font-weight: 600;
        font-size: 1.05rem;
        color: #f5f7fb;
      }

      .agent-metrics {
        display: grid;
        gap: 0.6rem;
        margin: 0;
      }

      .agent-metrics div {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
      }

      .agent-metrics dt {
        margin: 0;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .agent-metrics dd {
        margin: 0;
        font-weight: 600;
        font-size: 1.25rem;
      }

      .timestamp {
        margin-top: 1.25rem;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .control-actions {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.25rem;
        align-items: center;
      }

      .updated-note {
        color: #8a94a6;
        font-size: 0.75rem;
      }

      button {
        appearance: none;
        border: none;
        border-radius: 6px;
        padding: 0.55rem 1.1rem;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        background: linear-gradient(135deg, #2b63ff, #7a62ff);
        color: #f5f7fb;
        box-shadow: 0 10px 25px rgba(43, 99, 255, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 14px 28px rgba(43, 99, 255, 0.25);
      }

      button:disabled {
        cursor: wait;
        opacity: 0.65;
        box-shadow: none;
      }

      .button-danger {
        background: linear-gradient(135deg, #ef476f, #ff9a5a);
      }

      .button-success {
        background: linear-gradient(135deg, #2dce89, #28a745);
      }

      .button-ghost {
        background: rgba(39, 48, 66, 0.6);
        color: #dbe4ff;
      }

      .empty {
        margin: 1rem 0 0;
        color: #8a94a6;
        font-size: 0.9rem;
      }

      .hidden {
        display: none !important;
      }

      .dashboard-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1.5rem;
        flex-wrap: wrap;
      }

      .logout-button {
        min-width: 140px;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .logout-button:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      /* Prevent long values from breaking layout */
      .value,
      .summary-sub,
      .grvt-risk-detail,
      .grvt-summary-updated,
      .risk-settings-message,
      .risk-meta,
      .grvt-adjust-status,
      .grvt-transfer-status,
      .grvt-auto-actions p,
      .grvt-auto-list li,
      .grvt-transfer-history td,
      .grvt-adjust-history td,
      .risk-history-table td,
      .agent-metrics dd,
      .timestamp {
        word-break: break-word;
        overflow-wrap: anywhere;
      }

      @media (max-width: 640px) {
        body {
          padding: 1.25rem;
        }

        h1 {
          font-size: 1.4rem;
        }

        .dashboard-top {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.75rem;
        }

        .section-header {
          flex-direction: column;
          align-items: flex-start;
          margin-top: 1.75rem;
        }

        .section-header-info,
        .section-header-controls {
          width: 100%;
          justify-content: space-between;
        }

        .badge-group {
          flex-wrap: wrap;
        }

        .card,
        .grvt-card,
        .sim-card,
        .vol-card,
        .sim-section .sim-card {
          padding: 1.1rem;
        }

        .value {
          font-size: 1.5rem;
        }

        .summary-sub {
          font-size: 0.85rem;
        }

        .grid,
        .grvt-summary-grid {
          grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        }

        .grvt-account-grid {
          grid-template-columns: 1fr;
        }

        .grvt-summary-grid,
        .grvt-adjust-controls,
        .grvt-transfer-grid,
        .grvt-auto-grid,
        .risk-settings-grid,
        .vol-symbol-grid,
        .sim-controls,
        .grvt-auto-status-grid {
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        .section-header h2 {
          font-size: 1.1rem;
        }

        .badge,
        .button,
        .logout-button {
          font-size: 0.85rem;
        }

        .grvt-adjust-buttons,
        .grvt-auto-actions,
        .risk-actions-left,
        .section-header-controls {
          gap: 0.5rem;
          flex-wrap: wrap;
        }

        /* Tables become horizontally scrollable on narrow screens */
        .grvt-adjust-history table,
        .grvt-transfer-history table,
        .risk-history-table,
        .vol-metric-table,
        .strategy-table,
        .spread-table,
        .grvt-auto-status-grid table {
          display: block;
          overflow-x: auto;
          white-space: nowrap;
        }
      }
    </style>
  </head>
  <body>
    <div class="dashboard-top">
      <div>
        <h1>Hedging Cycle Overview</h1>
        <p class="subtitle">Live metrics reported by the Aster–Lighter hedging executor.</p>
      </div>
      <form id="logout-form" method="post" action="/logout">
        <button type="submit" class="logout-button">退出登录</button>
      </form>
    </div>

    <section class="grvt-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>PARA Multi-Account Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="para-account-count">0 accounts</span>
          </div>
        </div>
        <div class="section-header-controls"></div>
      </div>
      <p class="empty" id="para-empty">Waiting for PARA monitor…</p>
      <div class="grvt-card hidden" id="para-card">
        <div class="grvt-summary-grid">
          <article class="card grvt-summary-card">
            <h3>Total PnL</h3>
            <div class="value" id="para-total-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>ETH PnL</h3>
            <div class="value" id="para-eth-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>BTC PnL</h3>
            <div class="value" id="para-btc-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>Net Equity</h3>
            <div class="value" id="para-total-equity">--</div>
            <p class="summary-sub" id="para-wallet-balance">Wallet --</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>风险裕量</h3>
            <div class="value" id="para-transfer-total">--</div>
            <p class="summary-sub" id="para-transfer-note">Equity - 1.5×max(IM)</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Risk Level</h3>
            <div class="value risk-pill risk-pill-summary" id="para-risk-level">--</div>
            <p class="grvt-risk-detail" id="para-risk-detail">Awaiting data…</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Avg Maint</h3>
            <div class="value" id="para-avg-maint">--</div>
            <p class="summary-sub">(Σ maint req / Σ equity)</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Last Update</h3>
            <div class="value hidden" id="para-summary-time">--</div>
            <p class="grvt-summary-updated hidden" id="para-summary-updated">Updated —</p>
            <div class="summary-sub" id="para-source-updates"></div>
          </article>
          <article class="card grvt-summary-card" id="para-reduce-suggestion-card">
            <h3>减仓建议</h3>
            <div class="value" id="para-reduce-suggestion-main">--</div>
            <p class="summary-sub" id="para-reduce-suggestion-detail">等待账户与持仓数据…</p>
          </article>
        </div>
        <div>
          <h3 style="margin-bottom: 0.75rem; font-size: 1rem;">Per Account Net PnL</h3>
          <div class="grvt-account-grid" id="para-account-grid"></div>
          <p class="empty hidden" id="para-accounts-empty">No account data yet…</p>
        </div>
          <div class="grvt-adjust-panel" id="para-adjust-panel">
            <div class="grvt-adjust-header">
              <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">PARA Position Adjustments</h3>
              <p class="summary-sub" style="margin: 0;">广播加/减仓指令到 PARA VPS</p>
            </div>
            <div class="grvt-adjust-controls">
              <label for="para-adjust-symbols" class="grvt-adjust-symbols">
                <div class="grvt-symbol-label">
                  <span>目标币种</span>
                  <small>选择需要调整的币种；未选中时广播所有</small>
                </div>
                <div class="grvt-symbol-input">
                  <select id="para-adjust-symbols"></select>
                  <button type="button" class="grvt-symbol-reset" id="para-reset-symbol">清空</button>
                </div>
              </label>
              <label>
                Size
                <input type="number" id="para-adjust-size" min="0.01" step="0.01" value="1" />
              </label>
              <label>
                下单方式
                <select id="para-order-mode">
                  <option value="market">市价</option>
                  <option value="twap">TWAP</option>
                </select>
              </label>
              <label id="para-twap-duration-wrapper">
                TWAP 时长 (秒)
                <input type="number" id="para-twap-duration" min="30" max="86400" step="30" value="900" />
                <small style="color: #8a94a6;">30-86400，30 秒步进</small>
              </label>
              <div class="grvt-adjust-buttons">
                <button type="button" id="para-adjust-add">加仓</button>
                <button type="button" class="button-danger" id="para-adjust-reduce">减仓</button>
              </div>
              <p class="grvt-adjust-status" id="para-adjust-status">等待指令…</p>
            </div>
            <div class="grvt-adjust-history">
              <table>
                <thead>
                  <tr>
                    <th>时间</th><th>动作</th><th>数量</th><th>币种</th><th>状态</th><th>节点</th>
                  </tr>
                </thead>
                <tbody id="para-adjust-history"><tr><td colspan="6">暂无记录</td></tr></tbody>
              </table>
            </div>
          </div>
          <div class="grvt-transfer-panel hidden" id="para-transfer-panel">
            <div class="grvt-adjust-header">
              <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">PARA 账户间资金划转</h3>
              <p class="summary-sub" style="margin: 0;">默认方向：来源账户 → 目标 L2 地址</p>
            </div>
            <div class="grvt-transfer-grid">
              <label>
                来源账户
                <select id="para-transfer-source"></select>
              </label>
              <label>
                目标账户
                <select id="para-transfer-target"></select>
              </label>
              <label>
                目标 L2 地址
                <input type="text" id="para-transfer-target-address" placeholder="0x..." />
              </label>
              <label>
                数量
                <input type="number" id="para-transfer-amount" min="0" step="0.01" value="0" />
              </label>
              <label>
                币种
                <input type="text" id="para-transfer-currency" value="USDC" />
              </label>
              <label>
                Transfer 类型
                <input type="text" id="para-transfer-type" value="spot" />
              </label>
              <label>
                备注（可选）
                <textarea id="para-transfer-reason" placeholder="记录用途或审批信息"></textarea>
              </label>
            </div>
            <div class="grvt-transfer-actions">
              <button type="button" id="para-transfer-submit">提交互转</button>
              <p class="grvt-transfer-status" id="para-transfer-status">等待指令…</p>
            </div>
            <div class="grvt-transfer-history">
              <table>
                <thead>
                  <tr>
                    <th>时间</th>
                    <th>来源 / 目标</th>
                    <th>方向</th>
                    <th>金额</th>
                    <th>路径</th>
                    <th>状态 / 备注</th>
                  </tr>
                </thead>
                <tbody id="para-transfer-history"></tbody>
              </table>
            </div>
          </div>
            <div class="grvt-risk-panel" id="para-risk-panel">
              <div class="grvt-adjust-header">
                <div>
                  <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">Bark 告警（PARA）</h3>
                  <p class="summary-sub" style="margin: 0;">针对 PARA 账户权益风险的 Bark 推送配置</p>
                </div>
                <div class="risk-status-pill" id="para-risk-settings-status">加载中…</div>
              </div>
              <div class="risk-settings-grid">
                <section class="risk-settings-card">
                  <div class="risk-toggle">
                    <input type="checkbox" id="para-risk-alert-enabled" />
                    <span>启用风险告警</span>
                  </div>
                  <div class="risk-slider">
                    <label class="risk-slider-label" for="para-risk-threshold-slider">
                      <span id="para-risk-threshold-label">阈值 --%</span>
                    </label>
                    <input type="range" id="para-risk-threshold-slider" min="5" max="90" step="0.5" value="30" />
                    <div class="risk-slider-scale">
                      <span>5%</span>
                      <span>25%</span>
                      <span>50%</span>
                      <span>90%</span>
                    </div>
                  </div>
                  <div class="risk-inline-inputs">
                    <label>
                      触发阈值 (%)
                      <input type="number" id="para-risk-threshold-input" min="1" max="90" step="0.5" />
                    </label>
                    <label>
                      重置阈值 (%)
                      <input type="number" id="para-risk-reset-input" min="1" max="90" step="0.5" />
                    </label>
                    <label>
                      冷却 (分钟)
                      <input type="number" id="para-risk-cooldown-input" min="0" max="360" step="1" />
                    </label>
                  </div>
                  <p class="risk-meta" id="para-risk-ratio-meta">等待风险数据…</p>
                </section>
                <section class="risk-settings-card">
                  <div class="risk-bark-grid">
                    <label>
                      Bark URL
                      <input type="text" id="para-risk-bark-url" placeholder="https://api.day.app/xxxxx/%7Btitle%7D/%7Bbody%7D" />
                    </label>
                    <label>
                      请求超时 (秒)
                      <input type="number" id="para-risk-bark-timeout" min="1" max="60" step="0.5" />
                    </label>
                  </div>
                </section>
              </div>
              <div class="risk-settings-actions">
                <div class="risk-actions-left">
                  <button type="button" id="para-risk-settings-save">保存配置</button>
                  <button type="button" class="button-success" id="para-risk-settings-test">测试 Bark</button>
                  <button type="button" class="button-ghost" id="para-risk-settings-refresh">重新读取</button>
                  <button type="button" class="button-danger" id="para-risk-settings-disable">关闭告警</button>
                </div>
                <p class="risk-settings-message" id="para-risk-settings-message">未加载</p>
                <p class="risk-settings-message" id="para-risk-test-message"></p>
              </div>
              <div class="risk-history-card">
                <div class="risk-history-header">
                  <h3>告警历史 (PARA)</h3>
                  <button type="button" class="button-ghost" id="para-risk-history-refresh">刷新</button>
                </div>
                <p class="risk-history-status" id="para-risk-history-status">等待告警数据…</p>
                <div class="risk-history-table-wrapper">
                  <table class="risk-history-table">
                    <thead>
                      <tr>
                        <th>时间</th>
                        <th>来源</th>
                        <th>账户</th>
                        <th>风险%</th>
                        <th>亏损 / 裕量</th>
                      </tr>
                    </thead>
                    <tbody id="para-risk-history-body"></tbody>
                  </table>
                  <p class="risk-history-empty hidden" id="para-risk-history-empty">暂无告警</p>
                </div>
              </div>
            </div>
          <div class="grvt-auto-panel" id="para-auto-panel">
            <div class="grvt-adjust-header">
              <div>
                <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">PARA 自动平衡</h3>
                <p class="summary-sub" style="margin: 0;">根据阈值在两个 PARA 账户间自动划转</p>
              </div>
              <span class="grvt-auto-pair" id="para-auto-pair">未配置</span>
            </div>
            <div class="grvt-auto-grid">
              <label class="grvt-auto-toggle">
                <span>启用自动平衡</span>
                <small>开启后根据阈值自动在两个账户之间划转</small>
                <input type="checkbox" id="para-auto-enabled" />
              </label>
              <label>
                账户 A
                <select id="para-auto-agent-a"></select>
              </label>
              <label>
                账户 B
                <select id="para-auto-agent-b"></select>
              </label>
              <label>
                阈值（%）
                <input type="number" id="para-auto-threshold" min="0" step="0.1" placeholder="15" />
              </label>
              <label>
                最小划转
                <input type="number" id="para-auto-min-transfer" min="0" step="0.01" placeholder="1000" />
              </label>
              <label>
                最大划转（可选）
                <input type="number" id="para-auto-max-transfer" min="0" step="0.01" placeholder="5000" />
              </label>
              <label>
                币种
                <input type="text" id="para-auto-currency" value="USDC" />
              </label>
              <label>
                冷却（秒）
                <input type="number" id="para-auto-cooldown" min="0" step="1" placeholder="900" />
              </label>
              <label>
                使用可划转余额
                <div class="grvt-auto-checkbox">
                  <input type="checkbox" id="para-auto-use-available" />
                  <span>prefer transferable balance</span>
                </div>
                <small>优先比较 available_equity，波动大时更稳健</small>
              </label>
            </div>
            <div class="grvt-auto-actions">
              <button type="button" id="para-auto-save">保存配置</button>
              <button type="button" class="button-danger" id="para-auto-disable">停用</button>
              <button type="button" class="button-ghost" id="para-auto-refresh">刷新状态</button>
              <p id="para-auto-status">等待配置…</p>
            </div>
            <div class="grvt-auto-status-grid">
              <div>
                <h4>实时测量</h4>
                <ul class="grvt-auto-list" id="para-auto-measurement">
                  <li>尚未收到差值数据</li>
                </ul>
              </div>
              <div>
                <h4>最近执行</h4>
                <ul class="grvt-auto-list" id="para-auto-last-action">
                  <li>无执行记录</li>
                </ul>
              </div>
            </div>
          </div>
          <div class="grvt-chart-card hidden" id="para-price-chart-wrapper">
            <div class="grvt-chart-header">
              <h3>BTC / ETH Δ%</h3>
              <span class="summary-sub" id="para-price-chart-note">等待数据…</span>
            </div>
            <canvas id="para-price-chart"></canvas>
            <div class="chart-legend" id="para-price-chart-legend">
              <span><span class="legend-dot legend-btc"></span>BTC (相对首笔)</span>
              <span><span class="legend-dot legend-eth"></span>ETH (相对首笔)</span>
            </div>
          </div>
      </div>
    </section>

    <section class="vol-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>BTC / ETH Volatility Signals</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="vol-updated">等待行情…</span>
            <span class="badge badge-info hidden" id="vol-source-badge">Source —</span>
          </div>
        </div>
        <div class="section-header-controls">
          <span class="badge badge-warn hidden" id="vol-error-badge"></span>
        </div>
      </div>
      <p class="empty" id="vol-empty">Waiting for volatility feed…</p>
      <div class="vol-card hidden" id="vol-card">
        <div class="vol-symbol-grid" id="vol-symbol-grid"></div>
        <div class="vol-hedge-card">
          <h3>Hedge Guidance</h3>
          <p class="vol-hedge-pair" id="vol-hedge-pair">—</p>
          <table class="vol-metric-table">
            <thead>
              <tr>
                <th>Window</th>
                <th>Corr</th>
                <th>Vol Ratio</th>
                <th>Beta</th>
                <th>Δ Return</th>
              </tr>
            </thead>
            <tbody id="vol-hedge-body">
              <tr>
                <td colspan="5">Waiting for correlation window…</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="sim-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>BTC / ETH Pair Simulation</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="sim-date-range">等待模拟数据…</span>
          </div>
        </div>
        <div class="section-header-controls">
          <button type="button" class="button-ghost" id="sim-refresh">重新抓取</button>
        </div>
      </div>
      <p class="empty" id="sim-empty">加载 Binance 历史行情…</p>
      <div class="sim-card hidden" id="sim-card">
        <div class="sim-summary">
          <div>
            <p class="sim-label">Net PnL</p>
            <p class="sim-value" id="sim-pnl-value">--</p>
          </div>
          <div>
            <p class="sim-label">Exposure</p>
            <p class="sim-value" id="sim-exposure">--</p>
          </div>
          <div>
            <p class="sim-label">Start</p>
            <p class="sim-value" id="sim-start-display">--</p>
          </div>
        </div>
        <div class="sim-controls">
          <label>
            起点 t（距最早样本的天数）
            <input type="range" id="sim-start" min="0" max="0" step="1" value="0" />
            <span class="sim-slider-note" id="sim-start-note">--</span>
          </label>
          <label>
            Long BTC Value (X · USDT)
            <input type="number" id="sim-btc-amount" min="0" step="1000" value="100000" />
          </label>
          <label>
            Short ETH Value (Y · USDT)
            <input type="number" id="sim-eth-amount" min="0" step="1000" value="150000" />
          </label>
        </div>
        <div class="sim-optimize-row">
          <button type="button" id="sim-optimize">计算最佳配比</button>
          <span class="sim-slider-note" id="sim-optimize-note">基于当前 t 的移动平均平滑度</span>
        </div>
        <canvas id="sim-chart" height="320"></canvas>
        <p class="sim-status" id="sim-status">数据源：Binance 1h klines</p>
      </div>
    </section>

    <section class="grvt-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>GRVT Multi-Account Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="grvt-account-count">0 accounts</span>
          </div>
        </div>
        <div class="section-header-controls"></div>
      </div>
      <p class="empty" id="grvt-empty">Waiting for GRVT monitor…</p>
      <div class="grvt-card hidden" id="grvt-card">
        <div class="grvt-summary-grid">
          <article class="card grvt-summary-card">
            <h3>Total PnL</h3>
            <div class="value" id="grvt-total-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>ETH PnL</h3>
            <div class="value" id="grvt-eth-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>BTC PnL</h3>
            <div class="value" id="grvt-btc-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>Net Equity</h3>
            <div class="value" id="grvt-total-equity">--</div>
            <p class="summary-sub" id="grvt-wallet-balance">Wallet --</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>风险基数</h3>
            <div class="value" id="grvt-transfer-total">--</div>
            <p class="summary-sub" id="grvt-transfer-note">Σ Equity - Σ 初始保证金</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Risk Level</h3>
            <div class="value risk-pill risk-pill-summary" id="grvt-risk-level">--</div>
            <p class="grvt-risk-detail" id="grvt-risk-detail">Awaiting data…</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Last Update</h3>
            <div class="value" id="grvt-summary-time">--</div>
            <p class="grvt-summary-updated" id="grvt-summary-updated">Updated —</p>
          </article>
        </div>
        <div class="grvt-risk-panel" id="grvt-risk-panel">
          <div class="grvt-adjust-header">
            <div>
              <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">Bark 风险告警</h3>
              <p class="summary-sub" style="margin: 0;">将原 CLI 阈值迁移到面板，实时调节风险和推送模板</p>
            </div>
            <div class="risk-status-pill" id="risk-settings-status">加载中…</div>
          </div>
          <div class="risk-settings-grid">
            <section class="risk-settings-card">
              <div class="risk-toggle">
                <input type="checkbox" id="risk-alert-enabled" />
                <span>启用风险告警</span>
              </div>
              <div class="risk-slider">
                <label class="risk-slider-label" for="risk-threshold-slider">
                  <span id="risk-threshold-label">阈值 --%</span>
                </label>
                <input type="range" id="risk-threshold-slider" min="5" max="90" step="0.5" value="30" />
                <div class="risk-slider-scale">
                  <span>5%</span>
                  <span>25%</span>
                  <span>50%</span>
                  <span>90%</span>
                </div>
              </div>
              <div class="risk-inline-inputs">
                <label>
                  触发阈值 (%)
                  <input type="number" id="risk-threshold-input" min="1" max="90" step="0.5" />
                </label>
                <label>
                  重置阈值 (%)
                  <input type="number" id="risk-reset-input" min="1" max="90" step="0.5" />
                </label>
                <label>
                  冷却 (分钟)
                  <input type="number" id="risk-cooldown-input" min="0" max="360" step="1" />
                </label>
              </div>
              <p class="risk-meta" id="risk-ratio-meta">等待风险数据…</p>
            </section>
            <section class="risk-settings-card">
              <div class="risk-bark-grid">
                <label>
                  Bark URL
                  <input type="text" id="risk-bark-url" placeholder="https://api.day.app/xxxxx/%7Btitle%7D/%7Bbody%7D" />
                </label>
                <label class="risk-toggle">
                  <input type="checkbox" id="risk-bark-append" checked />
                  <span>缺少 {title}/{body} 时自动附加</span>
                </label>
                <label>
                  请求超时 (秒)
                  <input type="number" id="risk-bark-timeout" min="1" max="60" step="0.5" />
                </label>
                <label>
                  标题模板
                  <textarea id="risk-title-template" rows="2"></textarea>
                </label>
                <label>
                  正文模板
                  <textarea id="risk-body-template" rows="3"></textarea>
                </label>
              </div>
            </section>
          </div>
          <div class="risk-settings-actions">
            <div class="risk-actions-left">
              <button type="button" id="risk-settings-save">保存配置</button>
              <button type="button" class="button-success" id="risk-settings-test">测试 Bark</button>
              <button type="button" class="button-ghost" id="risk-settings-refresh">重新读取</button>
              <button type="button" class="button-danger" id="risk-settings-disable">关闭告警</button>
            </div>
            <p class="risk-settings-message" id="risk-settings-message">未加载</p>
            <p class="risk-settings-message" id="risk-test-message"></p>
          </div>
          <div class="risk-history-card">
            <div class="risk-history-header">
              <h3>告警历史</h3>
              <button type="button" class="button-ghost" id="risk-history-refresh">刷新</button>
            </div>
            <p class="risk-history-status" id="risk-history-status">等待告警数据…</p>
            <div class="risk-history-table-wrapper">
              <table class="risk-history-table">
                <thead>
                  <tr>
                    <th>时间</th>
                    <th>来源</th>
                    <th>账户</th>
                    <th>风险%</th>
                    <th>亏损 / 基数</th>
                  </tr>
                </thead>
                <tbody id="risk-history-body"></tbody>
              </table>
              <p class="risk-history-empty hidden" id="risk-history-empty">暂无告警</p>
            </div>
          </div>
        </div>
        <div class="grvt-chart-grid">
          <div class="grvt-chart-card hidden" id="grvt-price-chart-wrapper">
            <div class="grvt-chart-header">
              <h3>BTC / ETH Δ%</h3>
              <span class="summary-sub" id="grvt-price-chart-note">等待数据…</span>
            </div>
            <canvas id="grvt-price-chart"></canvas>
            <div class="chart-legend" id="grvt-price-chart-legend">
              <span><span class="legend-dot legend-btc"></span>BTC (相对首笔)</span>
              <span><span class="legend-dot legend-eth"></span>ETH (相对首笔)</span>
            </div>
          </div>
          <div class="grvt-chart-card hidden" id="grvt-transfer-chart-wrapper">
            <div class="grvt-chart-header">
              <h3>风险基数走势</h3>
              <span class="summary-sub" id="grvt-transfer-chart-note">等待数据…</span>
            </div>
            <canvas id="grvt-transfer-chart"></canvas>
            <div class="chart-legend" id="grvt-transfer-chart-legend">
              <span><span class="legend-dot legend-transfer"></span>风险基数</span>
              <span><span class="legend-dot legend-diff"></span>BTC-ETH Δ%</span>
            </div>
          </div>
        </div>
        <div class="grvt-adjust-panel" id="grvt-adjust-panel">
          <div class="grvt-adjust-header">
            <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">Global Position Adjustments</h3>
            <p class="summary-sub" style="margin: 0;">Broadcast add/reduce requests to every VPS</p>
          </div>
          <div class="grvt-adjust-controls">
            <label for="grvt-adjust-symbols" class="grvt-adjust-symbols">
              <div class="grvt-symbol-label">
                <span>目标币种</span>
                <small>选择需要调整的币种；未选中时广播所有</small>
              </div>
              <div class="grvt-symbol-input">
                <select id="grvt-adjust-symbols"></select>
                <button type="button" class="grvt-symbol-reset" id="grvt-reset-symbol">清空</button>
              </div>
            </label>
            <label for="grvt-adjust-size">
              Size
              <input type="number" id="grvt-adjust-size" min="0.01" step="0.01" value="1" />
            </label>
            <div class="grvt-adjust-buttons">
              <button type="button" id="grvt-adjust-add">加仓</button>
              <button type="button" class="button-danger" id="grvt-adjust-reduce">减仓</button>
            </div>
            <p class="grvt-adjust-status" id="grvt-adjust-status">等待指令…</p>
          </div>
          <div class="grvt-adjust-history">
            <table>
              <thead>
                <tr>
                  <th>时间</th>
                  <th>动作</th>
                  <th>数量</th>
                  <th>币种</th>
                  <th>状态</th>
                  <th>节点</th>
                </tr>
              </thead>
              <tbody id="grvt-adjust-history"></tbody>
            </table>
          </div>
        </div>
        <div class="grvt-transfer-panel hidden" id="grvt-transfer-panel">
          <div class="grvt-adjust-header">
            <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">账户间资金划转</h3>
            <p class="summary-sub" style="margin: 0;">默认方向：来源账户 → 目标账户</p>
          </div>
          <div class="grvt-transfer-grid">
            <label>
              来源账户
              <select id="grvt-transfer-source"></select>
            </label>
            <label>
              目标账户
              <select id="grvt-transfer-target"></select>
            </label>
            <label>
              数量
              <input type="number" id="grvt-transfer-amount" min="0" step="0.01" value="0" />
            </label>
            <label>
              币种
              <input type="text" id="grvt-transfer-currency" value="USDT" />
            </label>
            <label>
              Transfer 类型
              <input type="text" id="grvt-transfer-type" value="spot" />
            </label>
            <label>
              备注（可选）
              <textarea id="grvt-transfer-reason" placeholder="记录用途或审批信息"></textarea>
            </label>
          </div>
          <div class="grvt-transfer-grid">
            <label>
              From Account ID
              <input type="text" id="grvt-transfer-from-account" />
            </label>
            <label>
              From Sub Account ID
              <input type="text" id="grvt-transfer-from-sub" />
            </label>
            <label>
              To Account ID
              <input type="text" id="grvt-transfer-to-account" />
            </label>
            <label>
              To Sub Account ID
              <input type="text" id="grvt-transfer-to-sub" />
            </label>
          </div>
          <div class="grvt-transfer-actions">
            <button type="button" id="grvt-transfer-submit">提交互转</button>
            <p class="grvt-transfer-status" id="grvt-transfer-status">等待指令…</p>
          </div>
          <div class="grvt-transfer-history">
            <table>
              <thead>
                <tr>
                  <th>时间</th>
                  <th>来源 / 目标</th>
                  <th>方向</th>
                  <th>金额</th>
                  <th>路径</th>
                  <th>状态 / 备注</th>
                </tr>
              </thead>
              <tbody id="grvt-transfer-history"></tbody>
            </table>
          </div>
        </div>
        <div class="grvt-auto-panel" id="grvt-auto-panel">
          <div class="grvt-adjust-header">
            <div>
              <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">自动平衡配置</h3>
              <p class="summary-sub" style="margin: 0;">当两个账户权益差距超过阈值时自动触发互转</p>
            </div>
            <span class="grvt-auto-pair" id="grvt-auto-pair">未配置</span>
          </div>
          <div class="grvt-auto-grid">
            <label class="grvt-auto-toggle">
              <span>启用自动平衡</span>
              <small>开启后根据阈值自动在两个账户之间划转</small>
              <input type="checkbox" id="grvt-auto-enabled" />
            </label>
            <label>
              账户 A
              <select id="grvt-auto-agent-a"></select>
            </label>
            <label>
              账户 B
              <select id="grvt-auto-agent-b"></select>
            </label>
            <label>
              阈值（%）
              <input type="number" id="grvt-auto-threshold" min="0" step="0.1" placeholder="15" />
            </label>
            <label>
              最小划转
              <input type="number" id="grvt-auto-min-transfer" min="0" step="0.01" placeholder="1000" />
            </label>
            <label>
              最大划转（可选）
              <input type="number" id="grvt-auto-max-transfer" min="0" step="0.01" placeholder="5000" />
            </label>
            <label>
              币种
              <input type="text" id="grvt-auto-currency" value="USDT" />
            </label>
            <label>
              冷却（秒）
              <input type="number" id="grvt-auto-cooldown" min="0" step="1" placeholder="900" />
            </label>
            <label>
              使用可划转余额
              <div class="grvt-auto-checkbox">
                <input type="checkbox" id="grvt-auto-use-available" />
                <span>prefer transferable balance</span>
              </div>
              <small>优先比较 equity-初始保证金-正向未实现收益，波动大时更稳健</small>
            </label>
          </div>
          <div class="grvt-auto-actions">
            <button type="button" id="grvt-auto-save">保存配置</button>
            <button type="button" class="button-danger" id="grvt-auto-disable">停用</button>
            <button type="button" class="button-ghost" id="grvt-auto-refresh">刷新状态</button>
            <p id="grvt-auto-status">等待配置…</p>
          </div>
          <div class="grvt-auto-status-grid">
            <div>
              <h4>实时测量</h4>
              <ul class="grvt-auto-list" id="grvt-auto-measurement">
                <li>尚未收到差值数据</li>
              </ul>
            </div>
            <div>
              <h4>最近执行</h4>
              <ul class="grvt-auto-list" id="grvt-auto-last-action">
                <li>无执行记录</li>
              </ul>
            </div>
          </div>
        </div>
        <div>
          <h3 style="margin-bottom: 0.75rem; font-size: 1rem;">Per Account Net PnL</h3>
          <div class="grvt-account-grid" id="grvt-account-grid"></div>
          <p class="empty hidden" id="grvt-accounts-empty">No account data yet…</p>
        </div>
      </div>
    </section>

    <section class="grid">
      <article class="card">
        <h2>Current Position</h2>
        <div class="value" id="position">--</div>
      </article>
      <article class="card">
        <h2>Total Cycles</h2>
        <div class="value" id="cycles">--</div>
      </article>
      <article class="card">
        <h2>Cumulative PnL</h2>
        <div class="value" id="pnl">--</div>
      </article>
      <article class="card">
        <h2>Total Volume</h2>
        <div class="value" id="volume">--</div>
      </article>
      <article class="card">
        <h2>Available Balance</h2>
        <div class="value" id="available-balance">--</div>
      </article>
      <article class="card">
        <h2>Total Account Value</h2>
        <div class="value" id="account-value">--</div>
      </article>
      <article class="card">
        <h2>Runtime</h2>
        <div class="value" id="runtime">--</div>
      </article>
    </section>

    <section class="agent-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>Per-VPS Metrics</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="agent-count">0 active</span>
            <span class="badge badge-info hidden" id="default-pause-indicator">Paused by default</span>
          </div>
        </div>
        <div class="section-header-controls">
          <button type="button" class="button-danger" id="pause-all">Pause All</button>
          <button type="button" class="button-success" id="resume-all">Resume All</button>
        </div>
      </div>
      <p class="empty" id="agent-empty">Waiting for VPS metrics…</p>
      <div class="agent-grid hidden" id="agent-grid"></div>
    </section>


    <section class="strategy-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>Spread Strategy Profit Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="strategy-agent-count">0 strategies</span>
          </div>
        </div>
        <div class="section-header-controls">
          <label class="strategy-selector-label hidden" id="strategy-agent-label">
            Strategy
            <select id="strategy-agent-select"></select>
          </label>
        </div>
      </div>
      <p class="empty" id="strategy-empty">Waiting for strategy metrics…</p>
      <div class="strategy-card hidden" id="strategy-card">
        <div class="strategy-summary-grid">
          <article class="card">
            <h2>Net PnL</h2>
            <div class="value" id="strategy-net-pnl">--</div>
            <p class="summary-sub" id="strategy-trade-count">Trades —</p>
          </article>
          <article class="card">
            <h2>Total Volume</h2>
            <div class="value" id="strategy-total-volume">--</div>
            <p class="summary-sub">Entry + exit notional</p>
          </article>
          <article class="card">
            <h2>PnL / Volume</h2>
            <div class="value" id="strategy-pnl-ratio">--</div>
            <p class="summary-sub">Net profit versus traded value</p>
          </article>
          <article class="card">
            <h2>Open Position</h2>
            <div class="value" id="strategy-open-position">None</div>
            <p class="summary-sub" id="strategy-open-details">—</p>
          </article>
          <article class="card">
            <h2>Last Decision</h2>
            <div class="value" id="strategy-last-decision">—</div>
            <p class="summary-sub" id="strategy-last-decision-time">—</p>
          </article>
        </div>
        <div class="strategy-table-wrapper">
          <table class="spread-table strategy-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Action</th>
                <th>Direction</th>
                <th>Spread</th>
                <th>Z-Score</th>
                <th>Quantity</th>
                <th>PnL</th>
                <th>Reason</th>
              </tr>
            </thead>
            <tbody id="strategy-events-body"></tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="spread-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>Aster–Lighter Spread Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="spread-agent-count">0 monitors</span>
          </div>
        </div>
        <div class="section-header-controls">
          <label class="spread-selector-label hidden" id="spread-agent-label">
            Monitor
            <select id="spread-agent-select"></select>
          </label>
        </div>
      </div>
      <p class="empty" id="spread-empty">Waiting for spread data…</p>
      <div class="spread-card hidden" id="spread-card">
        <div class="spread-meta">
          <span id="spread-instrument">Instrument —</span>
          <span id="spread-updated">Updated —</span>
        </div>
        <div class="spread-chart-wrapper hidden" id="spread-chart-wrapper">
          <canvas id="spread-chart"></canvas>
        </div>
        <div class="spread-table-wrapper">
          <table class="spread-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Aster Bid</th>
                <th>Aster Ask</th>
                <th>Lighter Bid</th>
                <th>Lighter Ask</th>
                <th>AsterBid - LighterAsk</th>
                <th>LighterBid - AsterAsk</th>
                <th>Mid Δ</th>
              </tr>
            </thead>
            <tbody id="spread-table-body"></tbody>
          </table>
        </div>
      </div>
    </section>

    <p class="updated" id="updated">Awaiting data…</p>

    <script>
    const agentGrid = document.getElementById('agent-grid');
    const agentEmpty = document.getElementById('agent-empty');
    const agentCount = document.getElementById('agent-count');
    const updatedElement = document.getElementById('updated');
    const defaultPauseIndicator = document.getElementById('default-pause-indicator');
    const pauseAllButton = document.getElementById('pause-all');
    const resumeAllButton = document.getElementById('resume-all');
    const runtimeElement = document.getElementById('runtime');
  const grvtAccountCount = document.getElementById('grvt-account-count');
  const grvtEmpty = document.getElementById('grvt-empty');
  const grvtCard = document.getElementById('grvt-card');
  const grvtTotalPnl = document.getElementById('grvt-total-pnl');
  const grvtEthPnl = document.getElementById('grvt-eth-pnl');
  const grvtBtcPnl = document.getElementById('grvt-btc-pnl');
  const grvtTotalEquity = document.getElementById('grvt-total-equity');
  const grvtWalletBalance = document.getElementById('grvt-wallet-balance');
  const grvtTransferableTotal = document.getElementById('grvt-transfer-total');
  const grvtTransferableNote = document.getElementById('grvt-transfer-note');
  const grvtPriceChartWrapper = document.getElementById('grvt-price-chart-wrapper');
  const grvtPriceChartCanvas = document.getElementById('grvt-price-chart');
  const grvtPriceChartNote = document.getElementById('grvt-price-chart-note');
  const grvtPriceChartLegend = document.getElementById('grvt-price-chart-legend');
  const grvtTransferChartWrapper = document.getElementById('grvt-transfer-chart-wrapper');
  const grvtTransferChartCanvas = document.getElementById('grvt-transfer-chart');
  const grvtTransferChartNote = document.getElementById('grvt-transfer-chart-note');
  const grvtTransferChartLegend = document.getElementById('grvt-transfer-chart-legend');
  const grvtRiskLevel = document.getElementById('grvt-risk-level');
  const grvtRiskDetail = document.getElementById('grvt-risk-detail');
  const grvtSummaryTime = document.getElementById('grvt-summary-time');
  const grvtSummaryUpdated = document.getElementById('grvt-summary-updated');
  const grvtAccountGrid = document.getElementById('grvt-account-grid');
  const grvtAccountsEmpty = document.getElementById('grvt-accounts-empty');

  const paraAccountCount = document.getElementById('para-account-count');
  const paraEmpty = document.getElementById('para-empty');
  const paraCard = document.getElementById('para-card');
  const paraTotalPnl = document.getElementById('para-total-pnl');
  const paraEthPnl = document.getElementById('para-eth-pnl');
  const paraBtcPnl = document.getElementById('para-btc-pnl');
  const paraTotalEquity = document.getElementById('para-total-equity');
  const paraWalletBalance = document.getElementById('para-wallet-balance');
  const paraTransferableTotal = document.getElementById('para-transfer-total');
  const paraTransferableNote = document.getElementById('para-transfer-note');
  const paraRiskLevel = document.getElementById('para-risk-level');
  const paraRiskDetail = document.getElementById('para-risk-detail');
  const paraAvgMaint = document.getElementById('para-avg-maint');
  const paraSourceUpdates = document.getElementById('para-source-updates');
  const paraSummaryTime = document.getElementById('para-summary-time');
  const paraSummaryUpdated = document.getElementById('para-summary-updated');
  const paraReduceSuggestionCard = document.getElementById('para-reduce-suggestion-card');
  const paraReduceSuggestionMain = document.getElementById('para-reduce-suggestion-main');
  const paraReduceSuggestionDetail = document.getElementById('para-reduce-suggestion-detail');
  const paraPriceChartWrapper = document.getElementById('para-price-chart-wrapper');
  const paraPriceChartCanvas = document.getElementById('para-price-chart');
  const paraPriceChartNote = document.getElementById('para-price-chart-note');
  const paraPriceChartLegend = document.getElementById('para-price-chart-legend');
  const paraAccountGrid = document.getElementById('para-account-grid');
  const paraAccountsEmpty = document.getElementById('para-accounts-empty');
  const paraAdjustPanel = document.getElementById('para-adjust-panel');
  const paraAdjustSizeInput = document.getElementById('para-adjust-size');
  const paraAdjustSymbolsSelect = document.getElementById('para-adjust-symbols');
  const paraOrderModeSelect = document.getElementById('para-order-mode');
  const paraTwapDurationInput = document.getElementById('para-twap-duration');
  const paraTwapDurationWrapper = document.getElementById('para-twap-duration-wrapper');
  const paraResetSymbolButton = document.getElementById('para-reset-symbol');
  const paraAdjustAddButton = document.getElementById('para-adjust-add');
  const paraAdjustReduceButton = document.getElementById('para-adjust-reduce');
  const paraAdjustStatus = document.getElementById('para-adjust-status');
  const paraAdjustHistoryBody = document.getElementById('para-adjust-history');
  const paraRiskPanel = document.getElementById('para-risk-panel');
  const paraRiskSettingsStatus = document.getElementById('para-risk-settings-status');
  const paraRiskSettingsMessage = document.getElementById('para-risk-settings-message');
  const paraRiskTestMessage = document.getElementById('para-risk-test-message');
  const paraRiskAlertEnabledInput = document.getElementById('para-risk-alert-enabled');
  const paraRiskThresholdSlider = document.getElementById('para-risk-threshold-slider');
  const paraRiskThresholdInput = document.getElementById('para-risk-threshold-input');
  const paraRiskResetInput = document.getElementById('para-risk-reset-input');
  const paraRiskCooldownInput = document.getElementById('para-risk-cooldown-input');
  const paraRiskThresholdLabel = document.getElementById('para-risk-threshold-label');
  const paraRiskMeta = document.getElementById('para-risk-ratio-meta');
  const paraRiskBarkUrlInput = document.getElementById('para-risk-bark-url');
  const paraRiskBarkAppendInput = null;
  const paraRiskBarkTimeoutInput = document.getElementById('para-risk-bark-timeout');
  const paraRiskTitleTemplateInput = document.getElementById('para-risk-title-template');
  const paraRiskBodyTemplateInput = document.getElementById('para-risk-body-template');
  const paraRiskSaveButton = document.getElementById('para-risk-settings-save');
  const paraRiskDisableButton = document.getElementById('para-risk-settings-disable');
  const paraRiskRefreshButton = document.getElementById('para-risk-settings-refresh');
  const paraRiskTestButton = document.getElementById('para-risk-settings-test');
  const paraRiskHistoryBody = document.getElementById('para-risk-history-body');
  const paraRiskHistoryEmpty = document.getElementById('para-risk-history-empty');
  const paraRiskHistoryStatus = document.getElementById('para-risk-history-status');
  const paraRiskHistoryRefreshButton = document.getElementById('para-risk-history-refresh');
  const grvtRiskPanel = document.getElementById('grvt-risk-panel');
  const riskSettingsStatus = document.getElementById('risk-settings-status');
  const riskSettingsMessage = document.getElementById('risk-settings-message');
  const riskAlertEnabledInput = document.getElementById('risk-alert-enabled');
  const riskThresholdSlider = document.getElementById('risk-threshold-slider');
  const riskThresholdInput = document.getElementById('risk-threshold-input');
  const riskResetInput = document.getElementById('risk-reset-input');
  const riskCooldownInput = document.getElementById('risk-cooldown-input');
  const riskThresholdLabel = document.getElementById('risk-threshold-label');
  const riskMeta = document.getElementById('risk-ratio-meta');
  const riskBarkUrlInput = document.getElementById('risk-bark-url');
  const riskBarkAppendInput = document.getElementById('risk-bark-append');
  const riskBarkTimeoutInput = document.getElementById('risk-bark-timeout');
  const riskTitleTemplateInput = document.getElementById('risk-title-template');
  const riskBodyTemplateInput = document.getElementById('risk-body-template');
  const riskSaveButton = document.getElementById('risk-settings-save');
  const riskTestButton = document.getElementById('risk-settings-test');
  const riskDisableButton = document.getElementById('risk-settings-disable');
  const riskRefreshButton = document.getElementById('risk-settings-refresh');
  const riskHistoryBody = document.getElementById('risk-history-body');
  const riskHistoryEmpty = document.getElementById('risk-history-empty');
  const riskHistoryStatus = document.getElementById('risk-history-status');
  const riskHistoryRefreshButton = document.getElementById('risk-history-refresh');
  const grvtAdjustPanel = document.getElementById('grvt-adjust-panel');
  const grvtAdjustSizeInput = document.getElementById('grvt-adjust-size');
  const grvtAdjustSymbolsSelect = document.getElementById('grvt-adjust-symbols');
  const grvtResetSymbolButton = document.getElementById('grvt-reset-symbol');
  const grvtAdjustAddButton = document.getElementById('grvt-adjust-add');
  const grvtAdjustReduceButton = document.getElementById('grvt-adjust-reduce');
  const grvtAdjustStatus = document.getElementById('grvt-adjust-status');
  const grvtAdjustHistoryBody = document.getElementById('grvt-adjust-history');
  const grvtTransferPanel = document.getElementById('grvt-transfer-panel');
  const grvtTransferSourceSelect = document.getElementById('grvt-transfer-source');
  const grvtTransferTargetSelect = document.getElementById('grvt-transfer-target');
  const grvtTransferAmountInput = document.getElementById('grvt-transfer-amount');
  const grvtTransferCurrencyInput = document.getElementById('grvt-transfer-currency');
  const grvtTransferTypeInput = document.getElementById('grvt-transfer-type');
  const grvtTransferReasonInput = document.getElementById('grvt-transfer-reason');
  const grvtTransferFromAccountInput = document.getElementById('grvt-transfer-from-account');
  const grvtTransferFromSubInput = document.getElementById('grvt-transfer-from-sub');
  const grvtTransferToAccountInput = document.getElementById('grvt-transfer-to-account');
  const grvtTransferToSubInput = document.getElementById('grvt-transfer-to-sub');
  const grvtTransferSubmitButton = document.getElementById('grvt-transfer-submit');
  const grvtTransferStatus = document.getElementById('grvt-transfer-status');
  const grvtTransferHistoryBody = document.getElementById('grvt-transfer-history');
  const paraTransferPanel = document.getElementById('para-transfer-panel');
  const paraTransferSourceSelect = document.getElementById('para-transfer-source');
  const paraTransferTargetSelect = document.getElementById('para-transfer-target');
  const paraTransferTargetAddressInput = document.getElementById('para-transfer-target-address');
  const paraTransferAmountInput = document.getElementById('para-transfer-amount');
  const paraTransferCurrencyInput = document.getElementById('para-transfer-currency');
  const paraTransferTypeInput = document.getElementById('para-transfer-type');
  const paraTransferReasonInput = document.getElementById('para-transfer-reason');
  const paraTransferSubmitButton = document.getElementById('para-transfer-submit');
  const paraTransferStatus = document.getElementById('para-transfer-status');
  const paraTransferHistoryBody = document.getElementById('para-transfer-history');
  const paraAutoPanel = document.getElementById('para-auto-panel');
  const paraAutoEnabledInput = document.getElementById('para-auto-enabled');
  const paraAutoAgentASelect = document.getElementById('para-auto-agent-a');
  const paraAutoAgentBSelect = document.getElementById('para-auto-agent-b');
  const paraAutoThresholdInput = document.getElementById('para-auto-threshold');
  const paraAutoMinTransferInput = document.getElementById('para-auto-min-transfer');
  const paraAutoMaxTransferInput = document.getElementById('para-auto-max-transfer');
  const paraAutoCurrencyInput = document.getElementById('para-auto-currency');
  const paraAutoCooldownInput = document.getElementById('para-auto-cooldown');
  const paraAutoUseAvailableInput = document.getElementById('para-auto-use-available');
  const paraAutoSaveButton = document.getElementById('para-auto-save');
  const paraAutoDisableButton = document.getElementById('para-auto-disable');
  const paraAutoRefreshButton = document.getElementById('para-auto-refresh');
  const paraAutoStatus = document.getElementById('para-auto-status');
  const paraAutoMeasurement = document.getElementById('para-auto-measurement');
  const paraAutoLastAction = document.getElementById('para-auto-last-action');
  const paraAutoPairLabel = document.getElementById('para-auto-pair');
  const grvtAutoPanel = document.getElementById('grvt-auto-panel');
  const grvtAutoEnabledInput = document.getElementById('grvt-auto-enabled');
  const grvtAutoAgentASelect = document.getElementById('grvt-auto-agent-a');
  const grvtAutoAgentBSelect = document.getElementById('grvt-auto-agent-b');
  const grvtAutoThresholdInput = document.getElementById('grvt-auto-threshold');
  const grvtAutoMinTransferInput = document.getElementById('grvt-auto-min-transfer');
  const grvtAutoMaxTransferInput = document.getElementById('grvt-auto-max-transfer');
  const grvtAutoCurrencyInput = document.getElementById('grvt-auto-currency');
  const grvtAutoCooldownInput = document.getElementById('grvt-auto-cooldown');
  const grvtAutoUseAvailableInput = document.getElementById('grvt-auto-use-available');
  const grvtAutoSaveButton = document.getElementById('grvt-auto-save');
  const grvtAutoDisableButton = document.getElementById('grvt-auto-disable');
  const grvtAutoRefreshButton = document.getElementById('grvt-auto-refresh');
  const grvtAutoStatus = document.getElementById('grvt-auto-status');
  const grvtAutoMeasurement = document.getElementById('grvt-auto-measurement');
  const grvtAutoLastAction = document.getElementById('grvt-auto-last-action');
  const grvtAutoPairLabel = document.getElementById('grvt-auto-pair');
    const spreadAgentCount = document.getElementById('spread-agent-count');
    const spreadAgentLabel = document.getElementById('spread-agent-label');
    const spreadAgentSelect = document.getElementById('spread-agent-select');
    const spreadEmpty = document.getElementById('spread-empty');
    const spreadCard = document.getElementById('spread-card');
    const spreadTableBody = document.getElementById('spread-table-body');
    const spreadInstrument = document.getElementById('spread-instrument');
    const spreadUpdated = document.getElementById('spread-updated');
  const spreadChartWrapper = document.getElementById('spread-chart-wrapper');
  const spreadChartCanvas = document.getElementById('spread-chart');
    const strategyAgentCount = document.getElementById('strategy-agent-count');
    const strategyAgentLabel = document.getElementById('strategy-agent-label');
    const strategyAgentSelect = document.getElementById('strategy-agent-select');
    const strategyEmpty = document.getElementById('strategy-empty');
    const strategyCard = document.getElementById('strategy-card');
    const strategyNetPnl = document.getElementById('strategy-net-pnl');
    const strategyTradeCount = document.getElementById('strategy-trade-count');
  const strategyTotalVolume = document.getElementById('strategy-total-volume');
  const strategyPnlRatio = document.getElementById('strategy-pnl-ratio');
    const strategyOpenPosition = document.getElementById('strategy-open-position');
    const strategyOpenDetails = document.getElementById('strategy-open-details');
    const strategyLastDecision = document.getElementById('strategy-last-decision');
    const strategyLastDecisionTime = document.getElementById('strategy-last-decision-time');
    const strategyEventsBody = document.getElementById('strategy-events-body');
    const volCard = document.getElementById('vol-card');
    const volEmpty = document.getElementById('vol-empty');
    const volUpdated = document.getElementById('vol-updated');
    const volSourceBadge = document.getElementById('vol-source-badge');
    const volSymbolGrid = document.getElementById('vol-symbol-grid');
    const volErrorBadge = document.getElementById('vol-error-badge');
    const volHedgePair = document.getElementById('vol-hedge-pair');
    const volHedgeBody = document.getElementById('vol-hedge-body');
    const simCard = document.getElementById('sim-card');
    const simEmpty = document.getElementById('sim-empty');
    const simChartCanvas = document.getElementById('sim-chart');
    const simStartInput = document.getElementById('sim-start');
    const simStartNote = document.getElementById('sim-start-note');
    const simStartDisplay = document.getElementById('sim-start-display');
    const simBtcInput = document.getElementById('sim-btc-amount');
    const simEthInput = document.getElementById('sim-eth-amount');
    const simPnLValue = document.getElementById('sim-pnl-value');
    const simExposureValue = document.getElementById('sim-exposure');
    const simDateRangeBadge = document.getElementById('sim-date-range');
    const simStatus = document.getElementById('sim-status');
    const simRefreshButton = document.getElementById('sim-refresh');
    const simOptimizeButton = document.getElementById('sim-optimize');
  const simOptimizeNote = document.getElementById('sim-optimize-note');
    if (simOptimizeButton) {
      simOptimizeButton.disabled = true;
    }
  const MAX_SPREAD_HISTORY_POINTS = 1800;
    const MAX_STRATEGY_EVENTS = 120;
  const MAX_GRVT_POSITIONS = 12;
  // PARA 每个账户持仓展示上限；设为 Infinity 表示展示全部。
  const MAX_PARA_POSITIONS = Infinity;
  const RISK_GRADIENTS = [
    {
      max: 0.1,
      label: 'low',
      gradient: 'linear-gradient(135deg, #34e89e, #0f9d58)',
      color: '#041b11',
      shadow: '0 8px 18px rgba(15, 157, 88, 0.35)'
    },
    {
      max: 0.25,
      label: 'guarded',
      gradient: 'linear-gradient(135deg, #f9f871, #f7b267)',
      color: '#2b1d02',
      shadow: '0 8px 18px rgba(247, 178, 103, 0.35)'
    },
    {
      max: 0.5,
      label: 'elevated',
      gradient: 'linear-gradient(135deg, #f79d65, #f05a28)',
      color: '#2a0a02',
      shadow: '0 8px 18px rgba(240, 90, 40, 0.35)'
    },
    {
      max: Infinity,
      label: 'critical',
      gradient: 'linear-gradient(135deg, #ff4e50, #c81d25)',
      color: '#ffeef2',
      shadow: '0 8px 18px rgba(200, 29, 37, 0.4)'
    }
  ];
  const GLOBAL_RISK_GRADIENTS = [
    {
      max: 0.2,
      label: 'low',
      gradient: 'linear-gradient(135deg, #34e89e, #0f9d58)',
      color: '#041b11',
      shadow: '0 8px 18px rgba(15, 157, 88, 0.35)'
    },
    {
      max: 0.4,
      label: 'guarded',
      gradient: 'linear-gradient(135deg, #f9f871, #f7b267)',
      color: '#2b1d02',
      shadow: '0 8px 18px rgba(247, 178, 103, 0.35)'
    },
    {
      max: 0.7,
      label: 'elevated',
      gradient: 'linear-gradient(135deg, #f79d65, #f05a28)',
      color: '#2a0a02',
      shadow: '0 8px 18px rgba(240, 90, 40, 0.35)'
    },
    {
      max: Infinity,
      label: 'critical',
      gradient: 'linear-gradient(135deg, #ff4e50, #c81d25)',
      color: '#ffeef2',
      shadow: '0 8px 18px rgba(200, 29, 37, 0.4)'
    }
  ];
  const GLOBAL_RISK_THRESHOLD_TEXT = '阈值 20% / 40% / 70%';
  const BTC_LINE_COLOR = '#f6c177';
  const ETH_LINE_COLOR = '#4cc9f0';
  const RISK_CAPACITY_LINE_COLOR = '#c084fc';
  const PRICE_DIFF_LINE_COLOR = '#7dd3fc';
  const DEFAULT_MARGIN_SCHEDULE = [
    { maxNotional: 600000, initial: 0.02, maintenance: 0.01 },
    { maxNotional: 1600000, initial: 0.04, maintenance: 0.02 },
    { maxNotional: 4000000, initial: 0.05, maintenance: 0.025 },
    { maxNotional: 10000000, initial: 0.1, maintenance: 0.05 },
    { maxNotional: 20000000, initial: 0.2, maintenance: 0.1 },
    { maxNotional: 50000000, initial: 0.25, maintenance: 0.125 },
    { maxNotional: 80000000, initial: 0.3333, maintenance: 0.1667 },
    { maxNotional: 101000000, initial: 0.5, maintenance: 0.25 },
    { maxNotional: Infinity, initial: 1, maintenance: 0.5 }
  ];
  const MARGIN_SCHEDULES = {
    BTC: DEFAULT_MARGIN_SCHEDULE,
    ETH: DEFAULT_MARGIN_SCHEDULE,
  };
  const RISK_CAPACITY_CONFIRMATION_CYCLES = 3;
  const RISK_CAPACITY_DEVIATION_THRESHOLD = 0.1;
  const RISK_CAPACITY_MIN_ABS_DELTA = 500;
  const RISK_CAPACITY_PENDING_TOLERANCE = 0.001;
      let batchBusy = false;
      let lastDefaultPaused = false;
      let selectedSpreadAgent = null;
      let lastSpreadOptionsKey = '';
      let selectedStrategyAgent = null;
      let lastStrategyOptionsKey = '';
      let lastMetricsSnapshot = null;
  let grvtAdjustLocked = false;
  let grvtPendingRequestId = null;
  let paraAdjustLocked = false;
  let paraPendingRequestId = null;
  let grvtTransferLocked = false;
  let grvtTransferOptionsKey = '';
  const grvtTransferDefaults = new Map();
  let paraTransferLocked = false;
  let paraTransferOptionsKey = '';
  const paraTransferDefaults = new Map();
  let autoBalanceAgentsKey = '';
  let autoBalanceConfigKey = '';
  let autoBalanceBusy = false;
  let autoBalanceDirty = false;
  let autoBalanceLastConfig = null;
  let paraAutoAgentsKey = '';
  let paraAutoConfigKey = '';
  let paraAutoBusy = false;
  let paraAutoDirty = false;
  let paraAutoLastConfig = null;
  let riskSettingsBusy = false;
  let paraRiskSettingsBusy = false;
  let riskSettingsDirty = false;
  let riskSettingsSnapshot = null;
  let riskTestBusy = false;
  let latestGlobalRiskRatio = null;
  let paraLatestRiskRatio = null;
  let grvtLatestRiskRatio = null;
  let paraRiskHistoryEntries = [];

  function recomputeGlobalRiskRatio() {
    if (Number.isFinite(paraLatestRiskRatio)) {
      latestGlobalRiskRatio = paraLatestRiskRatio;
    } else if (Number.isFinite(grvtLatestRiskRatio)) {
      latestGlobalRiskRatio = grvtLatestRiskRatio;
    } else {
      latestGlobalRiskRatio = null;
    }
  }
  let riskHistoryBusy = false;
  let riskHistoryEntries = [];
  let lastRiskHistoryFetch = 0;
  const RISK_HISTORY_REFRESH_INTERVAL = 5000;
  const riskCapacityBufferState = {
    acceptedValue: null,
    acceptedAt: null,
    pendingValue: null,
    pendingCycles: 0,
    pendingDeltaPct: 0,
    pendingSince: null,
  };
  const paraRiskCapacityBufferState = {
    acceptedValue: null,
    acceptedAt: null,
    pendingValue: null,
    pendingCycles: 0,
    pendingDeltaPct: 0,
    pendingSince: null,
  };
  let simulationDataset = null;
  let simulationSeries = [];
  let simulationBusy = false;
  let simOptimizeBusy = false;

  const PARA_STALE_WARN_SEC = 10;
  const PARA_STALE_CRIT_SEC = 30;

      const numberFormatter = new Intl.NumberFormat(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 6,
        notation: 'compact'
      });

      function toNumber(value) {
        if (value === null || value === undefined) {
          return 0;
        }
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : 0;
      }

      function clamp(value, min, max) {
        if (!Number.isFinite(value)) {
          return min;
        }
        if (value < min) {
          return min;
        }
        if (value > max) {
          return max;
        }
        return value;
      }

      function parseDecimal(value) {
        if (value === null || value === undefined) {
          return null;
        }
        if (typeof value === 'number') {
          return Number.isFinite(value) ? value : null;
        }
        const normalized = String(value).replace(/,/g, '').trim();
        if (!normalized || normalized === '--') {
          return null;
        }
        const numeric = Number(normalized);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function computePercent(numerator, denominator) {
        if (!Number.isFinite(numerator) || !Number.isFinite(denominator) || Math.abs(denominator) < 1e-12) {
          return null;
        }
        return (numerator / denominator) * 100;
      }

      function formatPercent(value, digits = 2) {
        if (!Number.isFinite(value)) {
          return '—';
        }
        return `${value.toFixed(digits)}%`;
      }

      function formatSignedPercent(value, digits = 2) {
        if (!Number.isFinite(value)) {
          return '—';
        }
        const prefix = value > 0 ? '+' : '';
        return `${prefix}${value.toFixed(digits)}%`;
      }

      function formatSignedNumber(value, digits = 6) {
        if (!Number.isFinite(value)) {
          return '—';
        }
        const prefix = value > 0 ? '+' : '';
        return `${prefix}${value.toFixed(digits)}`;
      }

      function percentClass(value) {
        if (!Number.isFinite(value) || Math.abs(value) < 1e-9) {
          return 'vol-neutral';
        }
        return value > 0 ? 'vol-positive' : 'vol-negative';
      }

      function formatMultiplier(value, digits = 2) {
        if (!Number.isFinite(value)) {
          return '—';
        }
        return `${value.toFixed(digits)}x`;
      }

      function extractNumeric(bucket, key) {
        if (!bucket) {
          return null;
        }
        const value = bucket[key];
        if (typeof value === 'number') {
          return Number.isFinite(value) ? value : null;
        }
        return parseDecimal(value);
      }

      function getSeriesBounds(...seriesList) {
        let min = Infinity;
        let max = -Infinity;
        let hasValue = false;

        for (const series of seriesList) {
          for (const value of series) {
            if (!Number.isFinite(value)) {
              continue;
            }
            hasValue = true;
            if (value < min) {
              min = value;
            }
            if (value > max) {
              max = value;
            }
          }
        }

        if (!hasValue) {
          return { hasValue: false, min: 0, max: 0 };
        }

        if (min === max) {
          const epsilon = Math.abs(min) > 0 ? Math.abs(min) * 0.05 : 0.05;
          min -= epsilon;
          max += epsilon;
        }

        const padding = (max - min) * 0.08;
        return {
          hasValue: true,
          min: min - padding,
          max: max + padding,
        };
      }

      function prepareCanvas(canvas) {
        if (!canvas) {
          return null;
        }

        const rect = canvas.getBoundingClientRect();
        const width = rect.width || canvas.parentElement?.clientWidth || 600;
        const height = rect.height || 260;
        const dpr = window.devicePixelRatio || 1;

        canvas.width = width * dpr;
        canvas.height = height * dpr;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          return null;
        }

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        return { ctx, width, height };
      }

      function drawSeries(ctx, values, mapX, mapY, color) {
        ctx.beginPath();
        let started = false;
        for (let index = 0; index < values.length; index += 1) {
          const value = values[index];
          if (!Number.isFinite(value)) {
            started = false;
            continue;
          }

          const x = mapX(index);
          const y = mapY(value);
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        }

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function drawTimedSeries(ctx, points, mapX, mapY, color, width = 2) {
        ctx.beginPath();
        let started = false;
        for (const point of points) {
          const ts = Number(point.ts);
          const value = Number(point.value);
          if (!Number.isFinite(ts) || !Number.isFinite(value)) {
            started = false;
            continue;
          }
          const x = mapX(ts);
          const y = mapY(value);
          if (!Number.isFinite(x) || !Number.isFinite(y)) {
            started = false;
            continue;
          }
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
      }

      function renderSpreadCanvas(labels, seriesA, seriesB) {
        if (!spreadChartCanvas || !spreadChartWrapper) {
          return;
        }

        const bounds = getSeriesBounds(seriesA, seriesB);
        if (!bounds.hasValue) {
          spreadChartWrapper.classList.add('hidden');
          return;
        }

        const layout = { top: 56, right: 28, bottom: 52, left: 88 };
        spreadChartCanvas.style.width = '100%';

        const setup = prepareCanvas(spreadChartCanvas);
        if (!setup) {
          spreadChartWrapper.classList.add('hidden');
          return;
        }

        const { ctx, width, height } = setup;
        const innerWidth = Math.max(10, width - layout.left - layout.right);
        const innerHeight = Math.max(10, height - layout.top - layout.bottom);
        const { min, max } = bounds;
        const range = max - min || 1;

        const mapX = (index) => {
          if (labels.length <= 1) {
            return layout.left + innerWidth / 2;
          }
          return layout.left + (index / (labels.length - 1)) * innerWidth;
        };

        const mapY = (value) => {
          const ratio = (value - min) / range;
          return layout.top + (1 - ratio) * innerHeight;
        };

        ctx.fillStyle = '#1b1d24';
        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
        ctx.lineWidth = 1;
        const horizontalLines = 5;
        for (let i = 0; i <= horizontalLines; i += 1) {
          const value = min + (range * i) / horizontalLines;
          const y = mapY(value);
          ctx.beginPath();
          ctx.moveTo(layout.left, y);
          ctx.lineTo(width - layout.right, y);
          ctx.stroke();
        }

        ctx.font = '12px "Segoe UI", system-ui';
        ctx.fillStyle = '#8a94a6';
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'right';
        const yTicks = 4;
        for (let i = 0; i <= yTicks; i += 1) {
          const value = min + (range * i) / yTicks;
          const y = mapY(value);
          ctx.fillText(formatPercent(value, 2), layout.left - 12, y);
        }

        if (min < 0 && max > 0) {
          const zeroY = mapY(0);
          ctx.strokeStyle = 'rgba(199, 210, 232, 0.4)';
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.moveTo(layout.left, zeroY);
          ctx.lineTo(width - layout.right, zeroY);
          ctx.stroke();
        }

        drawSeries(ctx, seriesA, mapX, mapY, 'rgba(99, 156, 255, 1)');
        drawSeries(ctx, seriesB, mapX, mapY, 'rgba(255, 160, 86, 1)');

        ctx.font = '13px "Segoe UI", system-ui';
        const legendEntries = [
          { label: 'Aster bid – Lighter ask', color: 'rgba(99, 156, 255, 1)' },
          { label: 'Lighter bid – Aster ask', color: 'rgba(255, 160, 86, 1)' }
        ];
        let legendTextWidth = 0;
        for (const entry of legendEntries) {
          legendTextWidth = Math.max(legendTextWidth, ctx.measureText(entry.label).width);
        }
        const legendPaddingX = 14;
        const legendPaddingY = 10;
        const legendItemHeight = 22;
        const legendHeight = legendEntries.length * legendItemHeight + legendPaddingY * 2;
        const legendWidth = legendTextWidth + legendPaddingX * 2 + 24;
        let legendX = width - layout.right - legendWidth;
        let legendY = layout.top - legendHeight - 12;
        if (legendY < 8) {
          legendY = layout.top + 8;
        }

        ctx.fillStyle = 'rgba(17, 19, 27, 0.9)';
        ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);

        let legendCursorY = legendY + legendPaddingY + legendItemHeight / 2;
        for (const entry of legendEntries) {
          ctx.fillStyle = entry.color;
          ctx.beginPath();
          ctx.arc(legendX + legendPaddingX, legendCursorY, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#c7d2e8';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText(entry.label, legendX + legendPaddingX + 14, legendCursorY);
          legendCursorY += legendItemHeight;
        }

        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillStyle = '#8a94a6';
        const minLabelGap = 96;
        const labelIndexes = [];
        let lastLabelX = -Infinity;
        for (let i = 0; i < labels.length; i += 1) {
          const x = mapX(i);
          if (!Number.isFinite(x)) {
            continue;
          }
          if (labelIndexes.length === 0 || x - lastLabelX >= minLabelGap || i === labels.length - 1) {
            labelIndexes.push(i);
            lastLabelX = x;
          }
        }

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        const bottomY = height - layout.bottom;
        for (const index of labelIndexes) {
          const x = mapX(index);
          ctx.beginPath();
          ctx.moveTo(x, layout.top);
          ctx.lineTo(x, bottomY);
          ctx.stroke();
          ctx.fillText(labels[index] ?? '', x, bottomY + 8);
        }
      }

      function escapeHtml(value) {
        return String(value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function formatDecimal(value, fractionDigits = 4) {
        if (value === null || value === undefined) {
          return '--';
        }
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed || trimmed === '--' || trimmed.toLowerCase() === 'none') {
            return '--';
          }
          value = trimmed.replace(/,/g, '');
        }
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return '--';
        }
        return numeric.toFixed(fractionDigits);
      }

      function formatUsd(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return '--';
        }
        return `$${numberFormatter.format(numeric)}`;
      }

      function formatCoinAmount(value, fractionDigits = 4) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return '--';
        }
        return numeric.toFixed(fractionDigits);
      }

      function formatDuration(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) {
          return '0s';
        }

        let remaining = Math.round(seconds);
        if (remaining <= 0) {
          remaining = 1;
        }

        const units = [
          { label: 'd', value: 86400 },
          { label: 'h', value: 3600 },
          { label: 'm', value: 60 },
          { label: 's', value: 1 }
        ];

        const parts = [];
        for (const unit of units) {
          if (remaining < unit.value && parts.length === 0 && unit.label !== 's') {
            continue;
          }

          const amount = Math.floor(remaining / unit.value);
          if (amount > 0 || (unit.label === 's' && parts.length === 0)) {
            parts.push(`${amount}${unit.label}`);
          }
          remaining %= unit.value;

          if (parts.length >= 3) {
            break;
          }
        }

        return parts.join(' ');
      }

      function formatTimestamp(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) {
          return null;
        }
        return new Date(seconds * 1000).toLocaleString();
      }

      function formatDateLabel(ts, { includeTime = false } = {}) {
        if (!Number.isFinite(ts) || ts <= 0) {
          return '—';
        }
        const date = new Date(ts * 1000);
        return includeTime ? date.toLocaleString() : date.toLocaleDateString();
      }

      function formatSimRange(data) {
        if (!data || !Array.isArray(data.points) || !data.points.length) {
          return '等待模拟数据…';
        }
        const firstTs = Number(data.points[0]?.ts);
        const lastTs = Number(data.points[data.points.length - 1]?.ts);
        if (!Number.isFinite(firstTs) || !Number.isFinite(lastTs)) {
          return '—';
        }
        return `${formatDateLabel(firstTs)} — ${formatDateLabel(lastTs)}`;
      }

      function computeSelectedStartIndex() {
        if (!simulationDataset || !Array.isArray(simulationDataset.points) || !simulationDataset.points.length) {
          return 0;
        }
        const samplesPerDay = Math.max(1, Number(simulationDataset.samples_per_day) || 24);
        const maxDays = Number(simStartInput?.max || 0);
        const sliderDays = simStartInput ? Number(simStartInput.value) : 0;
        const clampedDays = clamp(sliderDays, 0, maxDays);
        return Math.min(simulationDataset.points.length - 1, Math.round(clampedDays * samplesPerDay));
      }

      function computeMovingAverageScore(series, windowSize, normalizationFactor = 1) {
        if (!Array.isArray(series) || !series.length) {
          return Number.POSITIVE_INFINITY;
        }
        const window = Math.max(2, Math.min(windowSize, series.length));
        const queue = [];
        let runningSum = 0;
        let totalAbs = 0;
        let sampleCount = 0;
        const denom = normalizationFactor > 0 ? normalizationFactor : 1;
        for (const point of series) {
          const value = Number(point.pnl) / denom;
          if (!Number.isFinite(value)) {
            continue;
          }
          queue.push(value);
          runningSum += value;
          if (queue.length > window) {
            runningSum -= queue.shift();
          }
          if (queue.length === window) {
            const avg = runningSum / window;
            totalAbs += Math.abs(avg);
            sampleCount += 1;
          }
        }
        if (!sampleCount) {
          return Number.POSITIVE_INFINITY;
        }
        return totalAbs / sampleCount;
      }

      function generateScaleValues(min, max, steps) {
        const normalizedSteps = Math.max(2, steps);
        const values = [];
        for (let index = 0; index < normalizedSteps; index += 1) {
          const ratio = normalizedSteps === 1 ? 0 : index / (normalizedSteps - 1);
          values.push(min + ratio * (max - min));
        }
        return values;
      }

      function computeOptimalExposure(startIndex) {
        if (!simulationDataset || !Array.isArray(simulationDataset.points) || !simulationDataset.points.length) {
          return null;
        }
        const points = simulationDataset.points;
        const anchor = points[startIndex];
        if (!anchor) {
          return null;
        }
        const btcPrice = Number(anchor.long ?? anchor.btc ?? anchor.price ?? 0);
        const ethPrice = Number(anchor.short ?? anchor.eth ?? 0);
        if (!(btcPrice > 0 && ethPrice > 0)) {
          return null;
        }
        const currentLongValue = parseDecimal(simBtcInput?.value);
        const currentShortValue = parseDecimal(simEthInput?.value);
        const fallbackLong = Number(simulationDataset.default?.long_value ?? 100000);
        const fallbackShort = Number(simulationDataset.default?.short_value ?? 150000);
        const baseLongValue = Number.isFinite(currentLongValue) && currentLongValue > 0 ? currentLongValue : fallbackLong;
        const baseShortValue = Number.isFinite(currentShortValue) && currentShortValue > 0 ? currentShortValue : fallbackShort;

        const samplesPerDay = Math.max(1, Number(simulationDataset.samples_per_day) || 24);
        const windowSize = Math.max(4, Math.round(samplesPerDay));
        const longScales = generateScaleValues(0.25, 2.5, 12);
        const shortScales = generateScaleValues(0.25, 2.5, 12);

        let best = null;
        for (const longScale of longScales) {
          const longValue = baseLongValue * longScale;
          if (!(longValue > 0)) {
            continue;
          }
          const longAmount = longValue / btcPrice;
          if (!(longAmount > 0)) {
            continue;
          }
          for (const shortScale of shortScales) {
            const shortValue = baseShortValue * shortScale;
            if (!(shortValue > 0)) {
              continue;
            }
            const shortAmount = shortValue / ethPrice;
            if (!(shortAmount > 0)) {
              continue;
            }
            const series = computeSimulationSeries(points, startIndex, longAmount, shortAmount);
            if (!series.length) {
              continue;
            }
            const notionalScale = Math.max(1e-9, longValue + shortValue);
            const score = computeMovingAverageScore(series, windowSize, notionalScale);
            if (!Number.isFinite(score)) {
              continue;
            }
            if (!best || score < best.score) {
              best = {
                score,
                series,
                longValue,
                shortValue,
                longAmount,
                shortAmount,
              };
            }
          }
        }
        return best;
      }

      function updateSimulationStatus() {
        if (!simStatus || !simulationDataset) {
          return;
        }
        const source = (simulationDataset.source || 'market').toUpperCase();
        const interval = simulationDataset.interval || '1h';
        const points = simulationDataset.point_count ?? (simulationDataset.points?.length ?? 0);
        simStatus.textContent = `数据源：${source} · 间隔 ${interval} · 样本 ${points}`;
      }

      function configureSimulationControls(data) {
        if (!data || !Array.isArray(data.points) || !data.points.length) {
          return;
        }
        const samplesPerDay = Math.max(1, Number(data.samples_per_day) || 24);
        const maxStartIndex = Math.max(0, data.points.length - 2);
        const maxDays = Math.max(0, Math.floor(maxStartIndex / samplesPerDay));
        if (simStartInput) {
          simStartInput.min = '0';
          simStartInput.max = String(maxDays);
          simStartInput.step = maxDays > 180 ? '2' : '1';
          const defaultIndex = Number(data.default?.start_index ?? 0);
          const defaultDays = Math.max(0, Math.round(defaultIndex / samplesPerDay));
          simStartInput.value = String(Math.min(maxDays, defaultDays));
        }
        if (simBtcInput) {
          const longValue = Number(data.default?.long_value ?? 100000);
          simBtcInput.value = Number.isFinite(longValue) ? longValue : 100000;
        }
        if (simEthInput) {
          const shortValue = Number(data.default?.short_value ?? 150000);
          simEthInput.value = Number.isFinite(shortValue) ? shortValue : 150000;
        }
        if (simOptimizeButton) {
          simOptimizeButton.disabled = false;
        }
      }

      function computeSimulationSeries(points, startIndex, btcAmount, ethAmount) {
        if (!Array.isArray(points) || !points.length) {
          return [];
        }
        const clampedIndex = Math.max(0, Math.min(startIndex, points.length - 1));
        const anchor = points[clampedIndex];
        if (!anchor) {
          return [];
        }
        const baseBtc = Number(anchor.long ?? anchor.btc ?? anchor.price ?? 0);
        const baseEth = Number(anchor.short ?? anchor.eth ?? 0);
        const series = [];
        for (let index = clampedIndex; index < points.length; index += 1) {
          const entry = points[index];
          const btc = Number(entry.long ?? entry.btc ?? entry.price);
          const eth = Number(entry.short ?? entry.eth);
          const ts = Number(entry.ts);
          if (!Number.isFinite(btc) || !Number.isFinite(eth) || !Number.isFinite(ts)) {
            continue;
          }
          const pnl = (btc - baseBtc) * btcAmount - (eth - baseEth) * ethAmount;
          series.push({ ts, pnl, btc, eth });
        }
        return series;
      }

      function updateSimulationSummary(series, { btcAmount, ethAmount, btcValue, ethValue, startIndex } = {}) {
        if (!simulationDataset) {
          return;
        }
        const anchor = Array.isArray(simulationDataset.points)
          ? simulationDataset.points[Math.max(0, Math.min(startIndex ?? 0, simulationDataset.points.length - 1))]
          : null;
        if (simStartDisplay) {
          const startText = anchor ? formatDateLabel(Number(anchor.ts), { includeTime: true }) : '—';
          simStartDisplay.textContent = startText;
        }
        if (simStartNote && simStartInput) {
          simStartNote.textContent = `t = ${simStartInput.value} 天`;
        }
        if (simExposureValue) {
          const longLabel = simulationDataset.long_label || simulationDataset.long_symbol || 'BTC';
          const shortLabel = simulationDataset.short_label || simulationDataset.short_symbol || 'ETH';
          const longUsdText = formatUsd(btcValue);
          const shortUsdText = formatUsd(ethValue);
          const longCoinText = formatCoinAmount(btcAmount, 4);
          const shortCoinText = formatCoinAmount(ethAmount, 4);
          const longSide = `${longUsdText !== '--' ? `+${longUsdText}` : '+--'} ${longLabel} (~${longCoinText} ${longLabel})`;
          const shortSide = `${shortUsdText !== '--' ? `-${shortUsdText}` : '- --'} ${shortLabel} (~${shortCoinText} ${shortLabel})`;
          simExposureValue.textContent = `${longSide} / ${shortSide}`;
        }
        if (simPnLValue) {
          const latest = series?.length ? series[series.length - 1].pnl : null;
          simPnLValue.textContent = Number.isFinite(latest) ? numberFormatter.format(latest) : '--';
        }
      }

      function renderSimulationChart(series) {
        if (!simChartCanvas) {
          return;
        }
        const setup = prepareCanvas(simChartCanvas);
        if (!setup) {
          return;
        }
        const { ctx, width, height } = setup;
        ctx.fillStyle = '#0b0f18';
        ctx.fillRect(0, 0, width, height);
        if (!Array.isArray(series) || !series.length) {
          ctx.fillStyle = '#6b7280';
          ctx.font = '14px "Segoe UI", system-ui';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('等待模拟数据…', width / 2, height / 2);
          return;
        }
        const values = series.map((point) => Number(point.pnl));
        const bounds = getSeriesBounds(values);
        if (!bounds.hasValue) {
          return;
        }
        const layout = { top: 36, right: 28, bottom: 50, left: 86 };
        const innerWidth = Math.max(10, width - layout.left - layout.right);
        const innerHeight = Math.max(10, height - layout.top - layout.bottom);
        const minTs = Number(series[0].ts);
        const maxTs = Number(series[series.length - 1].ts);
        const span = Math.max(1, maxTs - minTs);
        const mapX = (ts) => layout.left + ((ts - minTs) / span) * innerWidth;
        const mapY = (value) => {
          const range = bounds.max - bounds.min || 1;
          const ratio = (value - bounds.min) / range;
          return layout.top + (1 - ratio) * innerHeight;
        };

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        const horizontalLines = 4;
        for (let i = 0; i <= horizontalLines; i += 1) {
          const value = bounds.min + ((bounds.max - bounds.min) * i) / horizontalLines;
          const y = mapY(value);
          ctx.beginPath();
          ctx.moveTo(layout.left, y);
          ctx.lineTo(width - layout.right, y);
          ctx.stroke();
          ctx.fillStyle = '#8a94a6';
          ctx.font = '12px "Segoe UI", system-ui';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'middle';
          ctx.fillText(numberFormatter.format(value), layout.left - 10, y);
        }

        if (bounds.min < 0 && bounds.max > 0) {
          const zeroY = mapY(0);
          ctx.strokeStyle = 'rgba(252, 211, 77, 0.35)';
          ctx.beginPath();
          ctx.moveTo(layout.left, zeroY);
          ctx.lineTo(width - layout.right, zeroY);
          ctx.stroke();
        }

        ctx.font = '12px "Segoe UI", system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillStyle = '#8a94a6';
        const labels = 4;
        for (let i = 0; i <= labels; i += 1) {
          const ratio = i / labels;
          const ts = minTs + ratio * span;
          const x = mapX(ts);
          ctx.fillText(formatDateLabel(ts), x, height - layout.bottom + 8);
        }

        const lineSeries = series.map((point) => ({ ts: point.ts, value: point.pnl }));
        drawTimedSeries(ctx, lineSeries, mapX, mapY, 'rgba(252, 211, 77, 1)', 2.6);
      }

      async function loadSimulationData({ silent = false } = {}) {
        if (!simChartCanvas || simulationBusy) {
          return;
        }
        if (!silent && simStatus) {
          simStatus.textContent = '加载 Binance 历史行情…';
        }
        simulationBusy = true;
        try {
          const response = await fetch('/simulation/pnl', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const errorText = (await response.text())?.trim();
            const suffix = errorText ? ` ${errorText}` : '';
            throw new Error(`HTTP ${response.status}${suffix}`);
          }
          const payload = await response.json();
          simulationDataset = payload;
          configureSimulationControls(payload);
          if (simCard) {
            simCard.classList.remove('hidden');
          }
          if (simEmpty) {
            simEmpty.classList.add('hidden');
          }
          if (simDateRangeBadge) {
            simDateRangeBadge.textContent = formatSimRange(payload);
          }
          updateSimulationStatus();
          updateSimulationFromInputs();
        } catch (error) {
          if (simEmpty) {
            simEmpty.textContent = `无法加载模拟：${error}`;
            simEmpty.classList.remove('hidden');
          }
          if (simCard) {
            simCard.classList.add('hidden');
          }
        } finally {
          simulationBusy = false;
        }
      }

      function updateSimulationFromInputs() {
        if (!simulationDataset || !Array.isArray(simulationDataset.points) || !simulationDataset.points.length) {
          return;
        }
        const startIndex = computeSelectedStartIndex();
        let btcValue = parseDecimal(simBtcInput?.value);
        if (!Number.isFinite(btcValue) || btcValue <= 0) {
          btcValue = simulationDataset.default?.long_value ?? 100000;
        }
        let ethValue = parseDecimal(simEthInput?.value);
        if (!Number.isFinite(ethValue) || ethValue <= 0) {
          ethValue = simulationDataset.default?.short_value ?? 150000;
        }
        const anchor = simulationDataset.points[startIndex];
        const btcPrice = Number(anchor?.long ?? anchor?.btc ?? anchor?.price ?? 0);
        const ethPrice = Number(anchor?.short ?? anchor?.eth ?? 0);
        let btcAmount = btcPrice > 0 ? btcValue / btcPrice : 0;
        let ethAmount = ethPrice > 0 ? ethValue / ethPrice : 0;
        if ((!Number.isFinite(btcAmount) || btcAmount <= 0) && Number.isFinite(simulationDataset.default?.long_amount)) {
          btcAmount = simulationDataset.default.long_amount;
        }
        if ((!Number.isFinite(ethAmount) || ethAmount <= 0) && Number.isFinite(simulationDataset.default?.short_amount)) {
          ethAmount = simulationDataset.default.short_amount;
        }
        const series = computeSimulationSeries(simulationDataset.points, startIndex, btcAmount, ethAmount);
        simulationSeries = series;
        updateSimulationSummary(series, { btcAmount, ethAmount, btcValue, ethValue, startIndex });
        renderSimulationChart(series);
      }

      function handleSimOptimizeRequest(event) {
        if (event) {
          event.preventDefault();
        }
        if (simOptimizeBusy) {
          return;
        }
        if (!simulationDataset || !Array.isArray(simulationDataset.points) || !simulationDataset.points.length) {
          if (simOptimizeNote) {
            simOptimizeNote.textContent = '请先加载模拟数据';
          }
          return;
        }
        simOptimizeBusy = true;
        if (simOptimizeButton) {
          simOptimizeButton.disabled = true;
        }
        if (simOptimizeNote) {
          simOptimizeNote.textContent = '正在搜索最平滑的组合…';
        }
        try {
          const startIndex = computeSelectedStartIndex();
          const best = computeOptimalExposure(startIndex);
          if (!best) {
            if (simOptimizeNote) {
              simOptimizeNote.textContent = '未找到更优的组合，试试调整窗口或输入值';
            }
            return;
          }
          const roundValue = (value) => {
            if (!Number.isFinite(value) || value <= 0) {
              return 0;
            }
            const rounded = Math.round(value / 1000) * 1000;
            return Math.max(1000, rounded);
          };
          const roundedLongValue = roundValue(best.longValue);
          const roundedShortValue = roundValue(best.shortValue);
          if (simBtcInput) {
            simBtcInput.value = String(roundedLongValue);
          }
          if (simEthInput) {
            simEthInput.value = String(roundedShortValue);
          }
          updateSimulationFromInputs();
          if (simOptimizeNote) {
            const longText = `${formatUsd(roundedLongValue)} · ~${formatCoinAmount(best.longAmount, 4)} BTC`;
            const shortText = `${formatUsd(roundedShortValue)} · ~${formatCoinAmount(best.shortAmount, 4)} ETH`;
            simOptimizeNote.textContent = `最佳配比：${longText} / -${shortText} · 平滑分数 ${best.score.toFixed(4)}`;
          }
        } catch (error) {
          if (simOptimizeNote) {
            simOptimizeNote.textContent = `计算失败：${error?.message || error}`;
          }
        } finally {
          simOptimizeBusy = false;
          if (simOptimizeButton) {
            simOptimizeButton.disabled = false;
          }
        }
      }

      function describeAdjustmentAction(action) {
        if (!action) {
          return '—';
        }
        const normalized = String(action).trim().toLowerCase();
        if (normalized === 'add') {
          return '加仓';
        }
        if (normalized === 'reduce') {
          return '减仓';
        }
        if (normalized === 'transfer') {
          return '转账';
        }
        return normalized;
      }

      function normalizeSymbolLabel(value) {
        if (value === null || value === undefined) {
          return '';
        }
        const text = String(value).trim();
        if (!text) {
          return '';
        }
        return text.toUpperCase();
      }

      function normalizeParaPositionSymbol(value) {
        const raw = normalizeSymbolLabel(value);
        if (!raw) {
          return '';
        }
        // Common forms:
        // - BTC
        // - BTC-USD
        // - BTC-PERP
        // - BTCUSD
        // - FF-USD
        // Keep base asset for matching.
        const cleaned = raw.replace(/\s+/g, '');
        const parts = cleaned.split(/[-_/]/g).filter(Boolean);
        if (parts.length >= 1) {
          // If it looks like FF-USD keep FF-USD as-is for exclusion.
          if (parts.length >= 2 && parts[0] === 'FF' && parts[1] === 'USD') {
            return 'FF-USD';
          }
          return parts[0];
        }
        // Fallback: try to extract leading letters.
        const match = cleaned.match(/^[A-Z]+/);
        return match ? match[0] : cleaned;
      }

      function sumPositionsPnlByBase(positions, { excludeSymbols = new Set() } = {}) {
        const out = {};
        if (!Array.isArray(positions)) {
          return out;
        }
        for (const pos of positions) {
          const base = normalizeParaPositionSymbol(pos?.symbol);
          if (!base) {
            continue;
          }
          if (excludeSymbols.has(base) || excludeSymbols.has(normalizeSymbolLabel(pos?.symbol))) {
            continue;
          }
          const pnl = parseDecimal(pos?.pnl);
          if (!Number.isFinite(pnl)) {
            continue;
          }
          out[base] = (out[base] ?? 0) + pnl;
        }
        return out;
      }

      function estimatePnLPerUnit(positions, baseSymbol) {
        // Estimate how much total PnL changes when reducing 1 coin (absolute size)
        // using a simple sensitivity: dPnL/dSize ≈ sign(size) * (mark - entry)
        // Aggregate across all positions of that base.
        if (!Array.isArray(positions) || !baseSymbol) {
          return null;
        }
        let total = 0;
        let hasAny = false;
        for (const pos of positions) {
          const base = normalizeParaPositionSymbol(pos?.symbol);
          if (base !== baseSymbol) {
            continue;
          }
          const size = parseDecimal(pos?.net_size ?? pos?.size ?? pos?.quantity);
          const entry = parseDecimal(pos?.entry_price ?? pos?.entryPrice);
          const mark = parseDecimal(pos?.mark_price ?? pos?.markPrice);
          if (!Number.isFinite(size) || !Number.isFinite(entry) || !Number.isFinite(mark)) {
            continue;
          }
          const sign = size >= 0 ? 1 : -1;
          total += sign * (mark - entry);
          hasAny = true;
        }
        if (!hasAny) {
          return null;
        }
        // If total is very small, the estimate is unstable.
        if (!Number.isFinite(total) || Math.abs(total) < 1e-9) {
          return null;
        }
        return total;
      }

      function estimateTotalAbsSize(positions, baseSymbol) {
        if (!Array.isArray(positions) || !baseSymbol) {
          return 0;
        }
        let totalAbs = 0;
        for (const pos of positions) {
          const base = normalizeParaPositionSymbol(pos?.symbol);
          if (base !== baseSymbol) {
            continue;
          }
          const size = parseDecimal(pos?.net_size ?? pos?.size ?? pos?.quantity);
          if (!Number.isFinite(size)) {
            continue;
          }
          totalAbs += Math.abs(size);
        }
        return totalAbs;
      }

      function computeParaReduceSuggestion(flattenedAccounts) {
        // Contract:
        // - Only meaningful when there are exactly 2 accounts (two sources/accounts).
        // - We exclude FF-USD position PnL impact entirely.
        // Output: { ok, message, symbol, actions, details }
        const accounts = Array.isArray(flattenedAccounts) ? flattenedAccounts : [];
        if (accounts.length !== 2) {
          return {
            ok: false,
            message: accounts.length ? `当前 ${accounts.length} 个账户，减仓建议仅在 2 个账户时启用。` : '等待账户数据…',
          };
        }

        const [a, b] = accounts;
        const exclude = new Set(['FF-USD', 'FFUSD']);

        // Total PnL (display-level) - remove FF-USD position pnl if present
        const aPosPnl = sumPositionsPnlByBase(a.positions, { excludeSymbols: exclude });
        const bPosPnl = sumPositionsPnlByBase(b.positions, { excludeSymbols: exclude });
        const aFf = sumPositionsPnlByBase(a.positions, { excludeSymbols: new Set() });
        const bFf = sumPositionsPnlByBase(b.positions, { excludeSymbols: new Set() });
        const aFfPnl = Number.isFinite(aFf['FF-USD']) ? aFf['FF-USD'] : 0;
        const bFfPnl = Number.isFinite(bFf['FF-USD']) ? bFf['FF-USD'] : 0;

        const aTotalRaw = Number.isFinite(a.total) ? a.total : 0;
        const bTotalRaw = Number.isFinite(b.total) ? b.total : 0;
        const aTotal = aTotalRaw - aFfPnl;
        const bTotal = bTotalRaw - bFfPnl;
        const deltaTotal = aTotal - bTotal; // want -> 0

        const aBtc = Number.isFinite(aPosPnl.BTC) ? aPosPnl.BTC : 0;
        const bBtc = Number.isFinite(bPosPnl.BTC) ? bPosPnl.BTC : 0;
        const aEth = Number.isFinite(aPosPnl.ETH) ? aPosPnl.ETH : 0;
        const bEth = Number.isFinite(bPosPnl.ETH) ? bPosPnl.ETH : 0;
        const deltaBtc = aBtc - bBtc;
        const deltaEth = aEth - bEth;

        // Decide which symbol adjustment most reduces |deltaTotal|.
        // User expectation: adjustment should be applied to BOTH accounts simultaneously.
        // We treat it as a paired trade on a single symbol:
        //   - reduce(symbol) on the account that is "ahead" on total pnl
        //   - add(symbol)    on the other account
        // This keeps total exposure more symmetric while pushing ΔTotal toward 0.
        // Approx effect: ΔTotal' ≈ ΔTotal - f * ΔSymbol  (where ΔSymbol = aSymbolPnL - bSymbolPnL)
        // Choose symbol with best alignment and propose f that minimizes |ΔTotal'|.
        const candidates = [
          { symbol: 'BTC', deltaSymbol: deltaBtc },
          { symbol: 'ETH', deltaSymbol: deltaEth },
        ].filter((c) => Number.isFinite(c.deltaSymbol) && Math.abs(c.deltaSymbol) > 1e-9);

        if (!Number.isFinite(deltaTotal) || Math.abs(deltaTotal) < 1e-6) {
          return {
            ok: true,
            symbol: null,
            actions: [],
            details: `已基本平衡（排除 FF-USD 后 ΔPnL=${numberFormatter.format(deltaTotal)}）。`,
            message: '无需减仓',
          };
        }

        if (!candidates.length) {
          return {
            ok: false,
            message: '缺少 BTC/ETH 仓位 PnL（或仅有 FF-USD），无法计算减仓建议。',
          };
        }

        let best = null;
        for (const c of candidates) {
          // If deltaSymbol has opposite sign to deltaTotal, reducing that symbol would worsen.
          const alignment = deltaTotal * c.deltaSymbol;
          if (alignment <= 0) {
            continue;
          }
          // optimal f = deltaTotal / deltaSymbol (clamped 0..1)
          const f = clamp(deltaTotal / c.deltaSymbol, 0, 1);
          const newDelta = deltaTotal - f * c.deltaSymbol;
          const score = Math.abs(newDelta);
          if (!best || score < best.score) {
            best = { ...c, f, newDelta, score };
          }
        }

        if (!best) {
          return {
            ok: false,
            message: `BTC/ETH 的 PnL 差与总 PnL 差方向不一致（ΔTotal=${numberFormatter.format(deltaTotal)}，ΔBTC=${numberFormatter.format(deltaBtc)}，ΔETH=${numberFormatter.format(deltaEth)}），按该规则不建议减仓。`,
          };
        }

        // Paired adjustment (two-sided reduce): both accounts reduce exposure on the same symbol.
        // Reasoning: in your setup the two accounts typically hold opposite directions (one long one short).
        // Reducing on BOTH sides shrinks gross exposure while keeping the hedge structure.
        const aName = a?.name ?? 'Account A';
        const bName = b?.name ?? 'Account B';

        const aCap = estimateTotalAbsSize(a.positions, best.symbol);
        const bCap = estimateTotalAbsSize(b.positions, best.symbol);
        const pairedCap = Math.min(aCap, bCap);
        if (!(pairedCap > 0)) {
          return {
            ok: false,
            message: `两边都需要有 ${best.symbol} 仓位才能做“双边同时减仓”建议（${aName} 可用=${formatCoinAmount(aCap, 4)}，${bName} 可用=${formatCoinAmount(bCap, 4)}）。`,
          };
        }

        // Convert fraction f to paired size recommendation.
        const rawPairedSize = best.f * pairedCap;

        // Optional refinement: Use a-side pnl sensitivity to translate ΔTotal to size.
        // (This is a heuristic; we still clamp by pairedCap.)
        const pnlPerUnit = estimatePnLPerUnit(a.positions, best.symbol);
        let refinedSize = null;
        if (Number.isFinite(pnlPerUnit) && deltaTotal * pnlPerUnit > 0) {
          refinedSize = clamp(Math.abs(deltaTotal / pnlPerUnit), 0, pairedCap);
        }

        const suggestionSize = Number.isFinite(refinedSize) ? refinedSize : rawPairedSize;
        const finalSize = clamp(suggestionSize, 0, pairedCap);

  const main = `${best.symbol} 双边同时减仓：${aName} 减仓 ~${formatCoinAmount(finalSize, 4)}；${bName} 减仓 ~${formatCoinAmount(finalSize, 4)}`;
        const detailParts = [];
        detailParts.push(`排除 FF-USD 后：ΔTotal=${numberFormatter.format(deltaTotal)} → 目标接近 0`);
        detailParts.push(`Δ${best.symbol}=${numberFormatter.format(best.deltaSymbol)}，按比例 f=${(best.f * 100).toFixed(1)}%`);
        if (Number.isFinite(pnlPerUnit)) {
          detailParts.push(`估算 dPnL/dSize≈${formatSignedNumber(pnlPerUnit, 4)} / 1${best.symbol}`);
        }
        detailParts.push(`预计减仓后：ΔTotal≈${numberFormatter.format(best.newDelta)}（粗略）`);

        const actions = [
          { account: aName, action: 'reduce', symbol: best.symbol, size: finalSize },
          { account: bName, action: 'reduce', symbol: best.symbol, size: finalSize },
        ];

        return {
          ok: true,
          symbol: best.symbol,
          actions,
          message: main,
          details: detailParts.join(' · '),
        };
      }

      function describeSymbolScope(symbols) {
        if (!Array.isArray(symbols)) {
          return '全部';
        }
        const normalized = symbols
          .map((symbol) => normalizeSymbolLabel(symbol))
          .filter(Boolean);
        if (!normalized.length) {
          return '全部';
        }
        return normalized.join(', ');
      }

      function describeTransferDirection(direction) {
        if (!direction) {
          return '—';
        }
        const normalized = String(direction).trim().toLowerCase();
        if (normalized === 'main_to_sub') {
          return '主账户 → 子账户';
        }
        if (normalized === 'sub_to_main') {
          return '子账户 → 主账户';
        }
        if (normalized === 'main_to_main') {
          return '主账户 → 主账户';
        }
        if (normalized === 'l2_transfer') {
          return 'L2 转账';
        }
        return normalized;
      }

      function formatTransferRoute(payload) {
        if (!payload) {
          return '—';
        }
        if (payload.target_l2_address) {
          return `→ ${payload.target_l2_address}`;
        }
        const fromAccount = payload.from_account_id || payload.from_account || payload.from || '';
        const fromSub = payload.from_sub_account_id ?? payload.from_sub_account ?? '';
        const toAccount = payload.to_account_id || payload.to_account || payload.to || '';
        const toSub = payload.to_sub_account_id ?? payload.to_sub_account ?? '';
        const formatSide = (account, sub) => {
          if (!account && !sub) {
            return '?';
          }
          if (!sub) {
            return account || '?';
          }
          return `${account || '?'} (#${sub})`;
        };
        return `${formatSide(fromAccount, fromSub)} → ${formatSide(toAccount, toSub)}`;
      }

      function getInputValue(element) {
        if (!element) {
          return '';
        }
        return String(element.value ?? '').trim();
      }

      function setInputValue(element, value, { force = false } = {}) {
        if (!element) {
          return;
        }
        if (!force && element.value) {
          return;
        }
        element.value = value ?? '';
      }

      function buildTransferRouteFromDefaults(defaults, direction) {
        if (!defaults) {
          return null;
        }
        const normalizedDirection = String(direction || defaults.direction || 'sub_to_main').toLowerCase();
        if (defaults.routes && typeof defaults.routes === 'object') {
          const fromRoutes = defaults.routes[normalizedDirection];
          if (fromRoutes && typeof fromRoutes === 'object') {
            return fromRoutes;
          }
        }
        const normalize = (value) => {
          if (value === null || value === undefined) {
            return '';
          }
          return String(value).trim();
        };
        const mainAccount = normalize(defaults.main_account_id || defaults.from_account_id);
        const tradingSub = normalize(defaults.sub_account_id || defaults.to_sub_account_id);
        const mainSub = normalize(defaults.main_sub_account_id || defaults.to_sub_account_id || '0') || '0';
        if (!mainAccount) {
          return null;
        }
        if (normalizedDirection === 'sub_to_main') {
          if (!tradingSub) {
            return null;
          }
          return {
            from_account_id: mainAccount,
            from_sub_account_id: tradingSub,
            to_account_id: mainAccount,
            to_sub_account_id: mainSub,
          };
        }
        if (normalizedDirection === 'main_to_sub') {
          if (!tradingSub) {
            return null;
          }
          return {
            from_account_id: mainAccount,
            from_sub_account_id: mainSub,
            to_account_id: mainAccount,
            to_sub_account_id: tradingSub,
          };
        }
        return null;
      }

      function setGrvtTransferStatus(message) {
        if (grvtTransferStatus) {
          grvtTransferStatus.textContent = message || '等待指令…';
        }
      }

      function updateGrvtTransferButtons() {
        if (!grvtTransferSubmitButton) {
          return;
        }
        const sourceValue = grvtTransferSourceSelect?.value || '';
        const targetValue = grvtTransferTargetSelect?.value || '';
        const selectionsReady = Boolean(sourceValue && targetValue && sourceValue !== targetValue);
        grvtTransferSubmitButton.disabled = grvtTransferLocked || !selectionsReady;
      }

      function syncGrvtTransferSelectionStatus() {
        if (grvtTransferLocked) {
          return;
        }
        const sourceOptions = grvtTransferSourceSelect?.options?.length || 0;
        const targetOptions = grvtTransferTargetSelect?.options?.length || 0;
        const sourceValue = grvtTransferSourceSelect?.value;
        const targetValue = grvtTransferTargetSelect?.value;
        if (!sourceOptions || !targetOptions) {
          setGrvtTransferStatus('等待 VPS 提供转账参数…');
          return;
        }
        if (Math.min(sourceOptions, targetOptions) < 2) {
          setGrvtTransferStatus('至少需要两台 VPS 才能执行主账户互转');
          return;
        }
        if (!sourceValue || !targetValue) {
          setGrvtTransferStatus('请先选择来源和目标 VPS');
          return;
        }
        if (sourceValue === targetValue) {
          setGrvtTransferStatus('请为来源与目标选择不同的 VPS');
          return;
        }
        setGrvtTransferStatus('等待指令…');
      }

      function updateGrvtTransferAgents(options) {
        if (!grvtTransferPanel || !grvtTransferSourceSelect || !grvtTransferTargetSelect) {
          return;
        }
        const normalized = Array.isArray(options)
          ? options
              .map((option) => {
                const agentId = option?.agentId || option?.agent || option?.id || '';
                if (!agentId) {
                  return null;
                }
                const label = option?.label || option?.name || agentId;
                const defaults = option?.defaults && typeof option.defaults === 'object' ? option.defaults : {};
                return { agentId, label, defaults };
              })
              .filter(Boolean)
          : [];

        if (!normalized.length) {
          grvtTransferPanel.classList.add('hidden');
          grvtTransferSourceSelect.innerHTML = '';
          grvtTransferTargetSelect.innerHTML = '';
          grvtTransferDefaults.clear();
          grvtTransferLocked = false;
          grvtTransferOptionsKey = '';
          setGrvtTransferStatus('等待 VPS 提供转账参数…');
          updateGrvtTransferButtons();
          return;
        }

        const optionsKey = normalized
          .map((option) => `${option.agentId}:${JSON.stringify(option.defaults || {})}`)
          .join('|');
        const shouldRebuild =
          optionsKey !== grvtTransferOptionsKey ||
          grvtTransferSourceSelect.options.length !== normalized.length ||
          grvtTransferTargetSelect.options.length !== normalized.length;
        grvtTransferDefaults.clear();
        for (const option of normalized) {
          grvtTransferDefaults.set(option.agentId, option.defaults || {});
        }
        grvtTransferPanel.classList.remove('hidden');

        if (shouldRebuild) {
          grvtTransferOptionsKey = optionsKey;
          const previousSource = grvtTransferSourceSelect.value;
          const previousTarget = grvtTransferTargetSelect.value;
          const rebuildSelect = (select, previous) => {
            select.innerHTML = '';
            for (const option of normalized) {
              const element = document.createElement('option');
              element.value = option.agentId;
              element.textContent = option.label;
              select.appendChild(element);
            }
            if (previous && normalized.some((option) => option.agentId === previous)) {
              select.value = previous;
            } else if (select.options.length) {
              select.selectedIndex = 0;
            } else {
              select.value = '';
            }
          };
          rebuildSelect(grvtTransferSourceSelect, previousSource);
          rebuildSelect(grvtTransferTargetSelect, previousTarget);

          if (
            normalized.length > 1 &&
            grvtTransferSourceSelect.value &&
            grvtTransferSourceSelect.value === grvtTransferTargetSelect.value
          ) {
            const alternative = normalized.find((option) => option.agentId !== grvtTransferSourceSelect.value);
            if (alternative) {
              grvtTransferTargetSelect.value = alternative.agentId;
            }
          }
        }

        const sourceAgent = grvtTransferSourceSelect.value;
        const targetAgent = grvtTransferTargetSelect.value;
        if (sourceAgent) {
          applyGrvtTransferDefaults('source', { forceAll: true });
        }
        if (targetAgent) {
          applyGrvtTransferDefaults('target', { forceAll: true });
        }
        syncGrvtTransferSelectionStatus();
        updateGrvtTransferButtons();
      }

      function applyGrvtTransferDefaults(role, { forceAll = false } = {}) {
        const select = role === 'target' ? grvtTransferTargetSelect : grvtTransferSourceSelect;
        const agentId = select?.value;
        if (!agentId) {
          updateGrvtTransferButtons();
          return;
        }
        const defaults = grvtTransferDefaults.get(agentId) || {};
        if (role === 'source') {
          if (grvtTransferCurrencyInput && (forceAll || !grvtTransferCurrencyInput.value)) {
            grvtTransferCurrencyInput.value = (defaults.currency || 'USDT').toUpperCase();
          }
          if (grvtTransferTypeInput && (forceAll || !grvtTransferTypeInput.value)) {
            grvtTransferTypeInput.value = defaults.transfer_type || 'spot';
          }
        }
        updateGrvtTransferRoute({ force: true });
        updateGrvtTransferButtons();
      }

      function updateGrvtTransferRoute({ force = false } = {}) {
        const sourceId = grvtTransferSourceSelect?.value;
        const targetId = grvtTransferTargetSelect?.value;
        const sourceDefaults = (sourceId && grvtTransferDefaults.get(sourceId)) || {};
        const targetDefaults = (targetId && grvtTransferDefaults.get(targetId)) || {};
        const direction = 'main_to_main';
        const sourceRoute = buildTransferRouteFromDefaults(sourceDefaults, direction) || {};
        const targetRoute = buildTransferRouteFromDefaults(targetDefaults, direction) || {};
        const fallbackFromAccount =
          sourceRoute.from_account_id ||
          sourceDefaults.main_account_id ||
          sourceDefaults.from_account_id ||
          '';
        const fallbackFromSub =
          sourceRoute.from_sub_account_id ||
          sourceDefaults.main_sub_account_id ||
          sourceDefaults.sub_account_id ||
          sourceDefaults.from_sub_account_id ||
          '0';
        const fallbackToAccount =
          targetRoute.to_account_id ||
          targetDefaults.main_account_id ||
          targetDefaults.to_account_id ||
          sourceRoute.to_account_id ||
          '';
        const fallbackToSub =
          targetRoute.to_sub_account_id ||
          targetDefaults.main_sub_account_id ||
          targetDefaults.to_sub_account_id ||
          sourceRoute.to_sub_account_id ||
          '0';
        setInputValue(grvtTransferFromAccountInput, fallbackFromAccount, { force });
        setInputValue(grvtTransferFromSubInput, fallbackFromSub, { force });
        setInputValue(grvtTransferToAccountInput, fallbackToAccount, { force });
        setInputValue(grvtTransferToSubInput, fallbackToSub, { force });
      }

      async function sendGrvtTransfer() {
        if (grvtTransferLocked) {
          return;
        }
        const sourceAgentId = grvtTransferSourceSelect?.value;
        const targetAgentId = grvtTransferTargetSelect?.value;
        if (!sourceAgentId || !targetAgentId) {
          setGrvtTransferStatus('请先选择来源和目标 VPS');
          return;
        }
        if (sourceAgentId === targetAgentId && (grvtTransferSourceSelect?.options?.length || 0) > 1) {
          setGrvtTransferStatus('来源与目标 VPS 必须不同');
          return;
        }
        const amountValue = parseFloat(getInputValue(grvtTransferAmountInput) || '0');
        if (!Number.isFinite(amountValue) || amountValue <= 0) {
          setGrvtTransferStatus('请输入合法的数量');
          return;
        }
        const currencyValue = (getInputValue(grvtTransferCurrencyInput) || 'USDT').toUpperCase();
        const payload = {
          agent_ids: [sourceAgentId],
          target_agent_id: targetAgentId,
          num_tokens: amountValue,
          currency: currencyValue,
          direction: 'main_to_main',
          from_account_id: getInputValue(grvtTransferFromAccountInput),
          from_sub_account_id: getInputValue(grvtTransferFromSubInput),
          to_account_id: getInputValue(grvtTransferToAccountInput),
          to_sub_account_id: getInputValue(grvtTransferToSubInput),
          transfer_type: getInputValue(grvtTransferTypeInput) || undefined,
        };

        const missing = Object.entries({
          from_account_id: payload.from_account_id,
          from_sub_account_id: payload.from_sub_account_id,
          to_account_id: payload.to_account_id,
          to_sub_account_id: payload.to_sub_account_id,
        })
          .filter(([, value]) => !value)
          .map(([key]) => key);
        if (missing.length) {
          setGrvtTransferStatus(`缺少字段：${missing.join(', ')}`);
          return;
        }

        if (!payload.transfer_type) {
          delete payload.transfer_type;
        }

        const reason = getInputValue(grvtTransferReasonInput);
        if (reason) {
          payload.reason = reason;
        }

        grvtTransferLocked = true;
        updateGrvtTransferButtons();
        setGrvtTransferStatus('提交转账请求…');
        try {
          const response = await fetch('/grvt/transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          setGrvtTransferStatus('等待 VPS ACK…');
          await refreshMetrics();
        } catch (error) {
          grvtTransferLocked = false;
          updateGrvtTransferButtons();
          setGrvtTransferStatus(`请求失败：${error}`);
        }
      }

      function renderGrvtTransferHistory(summary) {
        if (!grvtTransferHistoryBody) {
          return;
        }
        const requests = Array.isArray(summary?.requests)
          ? summary.requests.filter((request) => (request?.action || '').toLowerCase() === 'transfer')
          : [];
        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const pendingStatuses = ['pending', 'in_progress'];
        let locked = false;
        let statusMessage = '等待指令…';
        const resolveTargetLabel = (payload) => {
          if (!payload || typeof payload !== 'object') {
            return '';
          }
          const metadata = payload.transfer_metadata && typeof payload.transfer_metadata === 'object' ? payload.transfer_metadata : {};
          return metadata.target_agent_label || metadata.target_agent_id || payload.target_agent_id || '';
        };

        const active = summary?.active_request;
        const activeIsTransfer = (active?.action || '').toLowerCase() === 'transfer' && pendingStatuses.includes(normalizeStatus(active?.overall_status));
        const pendingCandidate = activeIsTransfer ? active : requests.find((request) => pendingStatuses.includes(normalizeStatus(request.overall_status)));
        if (pendingCandidate) {
          locked = true;
          const targetAgents = Array.isArray(pendingCandidate.target_agents) ? pendingCandidate.target_agents.join(', ') : 'VPS';
          const pendingTarget = resolveTargetLabel(pendingCandidate.payload);
          const targetHint = pendingTarget ? ` → ${pendingTarget}` : '';
          statusMessage = `等待 ${(targetAgents || 'VPS')}${targetHint} ACK…`;
        } else if (requests.length) {
          const latest = requests[0];
          const latestStatus = normalizeStatus(latest.overall_status);
          const payload = latest?.payload || {};
          const directionText = describeTransferDirection(payload.direction || latest?.direction);
          if (latestStatus === 'completed' || latestStatus === 'acknowledged') {
            statusMessage = `最近一次 ${directionText} 已完成`;
          } else if (latestStatus === 'failed') {
            statusMessage = `最近一次 ${directionText} 部分失败`;
          } else if (latestStatus) {
            statusMessage = `最近状态：${latestStatus}`;
          }
        }

        grvtTransferLocked = locked;
        setGrvtTransferStatus(statusMessage);
        updateGrvtTransferButtons();

        if (!requests.length) {
          grvtTransferHistoryBody.innerHTML = '<tr><td colspan="6">暂无转账记录</td></tr>';
          return;
        }

        const rows = [];
        for (const request of requests.slice(0, 6)) {
          const createdText = formatTimestamp(request.created_at) ?? '--';
          const payload = request.payload || {};
          const sourceAgents = Array.isArray(request.target_agents) ? request.target_agents.join(', ') : '—';
          const targetLabel = resolveTargetLabel(payload) || '—';
          const amountValue = `${numberFormatter.format(toNumber(payload.num_tokens ?? request.magnitude ?? 0))} ${(payload.currency || 'USDC').toUpperCase()}`;
          const routeText = formatTransferRoute(payload);
          const statusText = request.overall_status || 'pending';
          const reasonText = payload?.transfer_metadata?.reason || payload.reason || '';
          const directionText = describeTransferDirection(payload.direction || payload?.transfer_metadata?.direction || request.direction);
          const noteText = reasonText ? `${statusText} / ${reasonText}` : statusText;
          rows.push(`
            <tr>
              <td>${escapeHtml(createdText)}</td>
              <td>${escapeHtml(`${sourceAgents || '—'} → ${targetLabel || '—'}`)}</td>
              <td>${escapeHtml(directionText)}</td>
              <td>${escapeHtml(amountValue)}</td>
              <td>${escapeHtml(routeText)}</td>
              <td>${escapeHtml(noteText)}</td>
            </tr>
          `);
        }

        grvtTransferHistoryBody.innerHTML = rows.join('');
        if (!locked) {
          syncGrvtTransferSelectionStatus();
        }
      }

      function setParaTransferStatus(message) {
        if (paraTransferStatus) {
          paraTransferStatus.textContent = message || '等待指令…';
        }
      }

      function updateParaTransferButtons() {
        if (!paraTransferSubmitButton) {
          return;
        }
        const sourceValue = paraTransferSourceSelect?.value || '';
        const targetValue = paraTransferTargetSelect?.value || '';
        const targetAddress = getInputValue(paraTransferTargetAddressInput);
        const selectionsReady = Boolean(sourceValue && targetValue && sourceValue !== targetValue && targetAddress);
        paraTransferSubmitButton.disabled = paraTransferLocked || !selectionsReady;
      }

      function syncParaTransferSelectionStatus() {
        if (paraTransferLocked) {
          return;
        }
        const sourceOptions = paraTransferSourceSelect?.options?.length || 0;
        const targetOptions = paraTransferTargetSelect?.options?.length || 0;
        const sourceValue = paraTransferSourceSelect?.value;
        const targetValue = paraTransferTargetSelect?.value;
        if (!sourceOptions || !targetOptions) {
          setParaTransferStatus('等待 VPS 提供转账参数…');
          return;
        }
        if (Math.min(sourceOptions, targetOptions) < 2) {
          setParaTransferStatus('至少需要两台 VPS 才能执行主账户互转');
          return;
        }
        if (!sourceValue || !targetValue) {
          setParaTransferStatus('请先选择来源和目标 VPS');
          return;
        }
        if (sourceValue === targetValue) {
          setParaTransferStatus('请为来源与目标选择不同的 VPS');
          return;
        }
        const targetAddress = getInputValue(paraTransferTargetAddressInput);
        if (!targetAddress) {
          setParaTransferStatus('目标 L2 地址缺失');
          return;
        }
        setParaTransferStatus('等待指令…');
      }

      function updateParaTransferAgents(options) {
        if (!paraTransferPanel || !paraTransferSourceSelect || !paraTransferTargetSelect) {
          return;
        }
        const normalized = Array.isArray(options)
          ? options
              .map((option) => {
                const agentId = option?.agentId || option?.agent || option?.id || '';
                if (!agentId) {
                  return null;
                }
                const label = option?.label || option?.name || agentId;
                const defaults = option?.defaults && typeof option.defaults === 'object' ? option.defaults : {};
                return { agentId, label, defaults };
              })
              .filter(Boolean)
          : [];

        if (!normalized.length) {
          paraTransferPanel.classList.add('hidden');
          paraTransferSourceSelect.innerHTML = '';
          paraTransferTargetSelect.innerHTML = '';
          paraTransferDefaults.clear();
          paraTransferLocked = false;
          paraTransferOptionsKey = '';
          setParaTransferStatus('等待 VPS 提供转账参数…');
          updateParaTransferButtons();
          return;
        }

        const optionsKey = normalized
          .map((option) => `${option.agentId}:${JSON.stringify(option.defaults || {})}`)
          .join('|');
        const shouldRebuild =
          optionsKey !== paraTransferOptionsKey ||
          paraTransferSourceSelect.options.length !== normalized.length ||
          paraTransferTargetSelect.options.length !== normalized.length;
        paraTransferDefaults.clear();
        for (const option of normalized) {
          paraTransferDefaults.set(option.agentId, option.defaults || {});
        }
        paraTransferPanel.classList.remove('hidden');

        if (shouldRebuild) {
          paraTransferOptionsKey = optionsKey;
          const previousSource = paraTransferSourceSelect.value;
          const previousTarget = paraTransferTargetSelect.value;
          const rebuildSelect = (select, previous) => {
            select.innerHTML = '';
            for (const option of normalized) {
              const element = document.createElement('option');
              element.value = option.agentId;
              element.textContent = option.label;
              select.appendChild(element);
            }
            if (previous && normalized.some((option) => option.agentId === previous)) {
              select.value = previous;
            } else if (select.options.length) {
              select.selectedIndex = 0;
            } else {
              select.value = '';
            }
          };
          rebuildSelect(paraTransferSourceSelect, previousSource);
          rebuildSelect(paraTransferTargetSelect, previousTarget);

          if (
            normalized.length > 1 &&
            paraTransferSourceSelect.value &&
            paraTransferSourceSelect.value === paraTransferTargetSelect.value
          ) {
            const alternative = normalized.find((option) => option.agentId !== paraTransferSourceSelect.value);
            if (alternative) {
              paraTransferTargetSelect.value = alternative.agentId;
            }
          }
        }

        const sourceAgent = paraTransferSourceSelect.value;
        const targetAgent = paraTransferTargetSelect.value;
        if (sourceAgent) {
          applyParaTransferDefaults('source', { forceAll: true });
        }
        if (targetAgent) {
          applyParaTransferDefaults('target', { forceAll: true });
        }
        syncParaTransferSelectionStatus();
        updateParaTransferButtons();
      }

      function applyParaTransferDefaults(role, { forceAll = false } = {}) {
        const select = role === 'target' ? paraTransferTargetSelect : paraTransferSourceSelect;
        const agentId = select?.value;
        if (!agentId) {
          updateParaTransferButtons();
          return;
        }
        const defaults = paraTransferDefaults.get(agentId) || {};
        if (role === 'source') {
          if (paraTransferCurrencyInput && (forceAll || !paraTransferCurrencyInput.value)) {
            paraTransferCurrencyInput.value = (defaults.currency || 'USDC').toUpperCase();
          }
          if (paraTransferTypeInput && (forceAll || !paraTransferTypeInput.value)) {
            paraTransferTypeInput.value = defaults.transfer_type || 'spot';
          }
        } else if (role === 'target') {
          const targetAddr = defaults.l2_address || defaults.target_l2_address || '';
          setInputValue(paraTransferTargetAddressInput, targetAddr, { force: forceAll });
        }
        updateParaTransferButtons();
      }

      function updateParaTransferRoute({ force = false } = {}) {
        const targetId = paraTransferTargetSelect?.value;
        const targetDefaults = (targetId && paraTransferDefaults.get(targetId)) || {};
        const targetAddr = targetDefaults.l2_address || targetDefaults.target_l2_address || '';
        setInputValue(paraTransferTargetAddressInput, targetAddr, { force });
      }

      async function sendParaTransfer() {
        if (paraTransferLocked) {
          return;
        }
        const sourceAgentId = paraTransferSourceSelect?.value;
        const targetAgentId = paraTransferTargetSelect?.value;
        if (!sourceAgentId || !targetAgentId) {
          setParaTransferStatus('请先选择来源和目标 VPS');
          return;
        }
        if (sourceAgentId === targetAgentId && (paraTransferSourceSelect?.options?.length || 0) > 1) {
          setParaTransferStatus('来源与目标 VPS 必须不同');
          return;
        }
        const amountValue = parseFloat(getInputValue(paraTransferAmountInput) || '0');
        if (!Number.isFinite(amountValue) || amountValue <= 0) {
          setParaTransferStatus('请输入合法的数量');
          return;
        }
        const targetAddress = getInputValue(paraTransferTargetAddressInput);
        if (!targetAddress) {
          setParaTransferStatus('请输入目标 L2 地址');
          return;
        }
  const currencyValue = (getInputValue(paraTransferCurrencyInput) || 'USDC').toUpperCase();
        const payload = {
          agent_ids: [sourceAgentId],
          target_agent_id: targetAgentId,
          num_tokens: amountValue,
          currency: currencyValue,
          target_l2_address: targetAddress,
          transfer_type: getInputValue(paraTransferTypeInput) || undefined,
        };

        if (!payload.transfer_type) {
          delete payload.transfer_type;
        }

        const reason = getInputValue(paraTransferReasonInput);
        if (reason) {
          payload.reason = reason;
        }

        paraTransferLocked = true;
        updateParaTransferButtons();
        setParaTransferStatus('提交转账请求…');
        try {
          const response = await fetch('/para/transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          setParaTransferStatus('等待 VPS ACK…');
          await refreshMetrics();
        } catch (error) {
          paraTransferLocked = false;
          updateParaTransferButtons();
          setParaTransferStatus(`请求失败：${error}`);
        }
      }

      function renderParaTransferHistory(summary) {
        if (!paraTransferHistoryBody) {
          return;
        }
        const requests = Array.isArray(summary?.requests)
          ? summary.requests.filter((request) => (request?.action || '').toLowerCase() === 'transfer')
          : [];
        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const pendingStatuses = ['pending', 'in_progress'];
        let locked = false;
        let statusMessage = '等待指令…';
        const resolveTargetLabel = (payload) => {
          if (!payload || typeof payload !== 'object') {
            return '';
          }
          const metadata = payload.transfer_metadata && typeof payload.transfer_metadata === 'object' ? payload.transfer_metadata : {};
          return metadata.target_agent_label || metadata.target_agent_id || payload.target_agent_id || '';
        };

        const active = summary?.active_request;
        const activeIsTransfer = (active?.action || '').toLowerCase() === 'transfer' && pendingStatuses.includes(normalizeStatus(active?.overall_status));
        const pendingCandidate = activeIsTransfer ? active : requests.find((request) => pendingStatuses.includes(normalizeStatus(request.overall_status)));
        if (pendingCandidate) {
          locked = true;
          const targetAgents = Array.isArray(pendingCandidate.target_agents) ? pendingCandidate.target_agents.join(', ') : 'VPS';
          const pendingTarget = resolveTargetLabel(pendingCandidate.payload);
          const targetHint = pendingTarget ? ` → ${pendingTarget}` : '';
          statusMessage = `等待 ${(targetAgents || 'VPS')}${targetHint} ACK…`;
        } else if (requests.length) {
          const latest = requests[0];
          const latestStatus = normalizeStatus(latest.overall_status);
          const payload = latest?.payload || {};
          const directionText = describeTransferDirection(payload.direction || latest?.direction);
          if (latestStatus === 'completed' || latestStatus === 'acknowledged') {
            statusMessage = `最近一次 ${directionText} 已完成`;
          } else if (latestStatus === 'failed') {
            statusMessage = `最近一次 ${directionText} 部分失败`;
          } else if (latestStatus) {
            statusMessage = `最近状态：${latestStatus}`;
          }
        }

        paraTransferLocked = locked;
        setParaTransferStatus(statusMessage);
        updateParaTransferButtons();

        if (!requests.length) {
          paraTransferHistoryBody.innerHTML = '<tr><td colspan="6">暂无转账记录</td></tr>';
          return;
        }

        const rows = [];
        for (const request of requests.slice(0, 6)) {
          const createdText = formatTimestamp(request.created_at) ?? '--';
          const payload = request.payload || {};
          const sourceAgents = Array.isArray(request.target_agents) ? request.target_agents.join(', ') : '—';
          const targetLabel = resolveTargetLabel(payload) || '—';
          const amountValue = `${numberFormatter.format(toNumber(payload.num_tokens ?? request.magnitude ?? 0))} ${(payload.currency || 'USDT').toUpperCase()}`;
          const routeText = formatTransferRoute(payload);
          const statusText = request.overall_status || 'pending';
          const reasonText = payload?.transfer_metadata?.reason || payload.reason || '';
          const directionText = describeTransferDirection(payload.direction || payload?.transfer_metadata?.direction || request.direction);
          const noteText = reasonText ? `${statusText} / ${reasonText}` : statusText;
          rows.push(`
            <tr>
              <td>${escapeHtml(createdText)}</td>
              <td>${escapeHtml(`${sourceAgents || '—'} → ${targetLabel || '—'}`)}</td>
              <td>${escapeHtml(directionText)}</td>
              <td>${escapeHtml(amountValue)}</td>
              <td>${escapeHtml(routeText)}</td>
              <td>${escapeHtml(noteText)}</td>
            </tr>
          `);
        }

        paraTransferHistoryBody.innerHTML = rows.join('');
        if (!locked) {
          syncParaTransferSelectionStatus();
        }
      }

      function setAutoBalanceStatusMessage(message) {
        if (grvtAutoStatus) {
          grvtAutoStatus.textContent = message || '等待配置…';
        }
      }

      function setParaAutoBalanceStatusMessage(message) {
        if (paraAutoStatus) {
          paraAutoStatus.textContent = message || '等待配置…';
        }
      }

      function getRiskViews() {
        return [
          {
            scope: 'global',
            panel: grvtRiskPanel,
            statusPill: riskSettingsStatus,
            message: riskSettingsMessage,
            testMessage: document.getElementById('risk-test-message'),
            enabledInput: riskAlertEnabledInput,
            thresholdSlider: riskThresholdSlider,
            thresholdInput: riskThresholdInput,
            resetInput: riskResetInput,
            cooldownInput: riskCooldownInput,
            thresholdLabel: riskThresholdLabel,
            meta: riskMeta,
            barkUrlInput: riskBarkUrlInput,
            barkAppendInput: riskBarkAppendInput,
            barkTimeoutInput: riskBarkTimeoutInput,
            titleTemplateInput: riskTitleTemplateInput,
            bodyTemplateInput: riskBodyTemplateInput,
            saveButton: riskSaveButton,
            disableButton: riskDisableButton,
            refreshButton: riskRefreshButton,
            testButton: riskTestButton,
          },
          {
            scope: 'para',
            panel: paraRiskPanel,
            statusPill: paraRiskSettingsStatus,
            message: paraRiskSettingsMessage,
            testMessage: paraRiskTestMessage,
            enabledInput: paraRiskAlertEnabledInput,
            thresholdSlider: paraRiskThresholdSlider,
            thresholdInput: paraRiskThresholdInput,
            resetInput: paraRiskResetInput,
            cooldownInput: paraRiskCooldownInput,
            thresholdLabel: paraRiskThresholdLabel,
            meta: paraRiskMeta,
            barkUrlInput: paraRiskBarkUrlInput,
            barkAppendInput: paraRiskBarkAppendInput,
            barkTimeoutInput: paraRiskBarkTimeoutInput,
            titleTemplateInput: paraRiskTitleTemplateInput,
            bodyTemplateInput: paraRiskBodyTemplateInput,
            saveButton: paraRiskSaveButton,
            disableButton: paraRiskDisableButton,
            refreshButton: paraRiskRefreshButton,
            testButton: paraRiskTestButton,
          },
        ].filter((view) => view.panel);
      }

      function updateAutoBalanceButtons() {
        [grvtAutoSaveButton, grvtAutoDisableButton, grvtAutoRefreshButton].forEach((button) => {
          if (button) {
            button.disabled = autoBalanceBusy;
          }
        });
      }

      function updateParaAutoBalanceButtons() {
        [paraAutoSaveButton, paraAutoDisableButton, paraAutoRefreshButton].forEach((button) => {
          if (button) {
            button.disabled = paraAutoBusy;
          }
        });
      }

      function markAutoBalanceDirty() {
        autoBalanceDirty = true;
        if (!autoBalanceBusy) {
          setAutoBalanceStatusMessage('配置未保存');
        }
      }

      function markParaAutoBalanceDirty() {
        paraAutoDirty = true;
        if (!paraAutoBusy) {
          setParaAutoBalanceStatusMessage('配置未保存');
        }
      }

      function renderAutoBalanceList(element, items, emptyLabel) {
        if (!element) {
          return;
        }
        if (!items || !items.length) {
          element.innerHTML = `<li>${escapeHtml(emptyLabel)}</li>`;
          return;
        }
        element.innerHTML = items.map((item) => `<li>${escapeHtml(item)}</li>`).join('');
      }

      function updateAutoBalanceAgentOptions(agentMap) {
        if (!grvtAutoAgentASelect || !grvtAutoAgentBSelect) {
          return;
        }
        const entries = agentMap && typeof agentMap === 'object'
          ? Object.entries(agentMap)
          : [];
        const options = entries
          .map(([agentId, metrics]) => {
            const instrument = metrics?.instrument ? ` · ${metrics.instrument}` : '';
            return { agentId, label: `${agentId}${instrument}` };
          })
          .sort((a, b) => a.agentId.localeCompare(b.agentId, undefined, { sensitivity: 'base' }));
        const key = options.map((option) => `${option.agentId}:${option.label}`).join('|');
        if (key === autoBalanceAgentsKey) {
          return;
        }
        autoBalanceAgentsKey = key;
        const hasOption = (select, value) => {
          if (!select || !value) {
            return false;
          }
          return Array.from(select.options || []).some((option) => option.value === value);
        };
        const rebuild = (select, previous) => {
          if (!select) {
            return;
          }
          select.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = '选择 VPS';
          select.appendChild(placeholder);
          for (const option of options) {
            const element = document.createElement('option');
            element.value = option.agentId;
            element.textContent = option.label;
            select.appendChild(element);
          }
          if (previous && options.some((option) => option.agentId === previous)) {
            select.value = previous;
          } else {
            select.value = '';
          }
        };
        rebuild(grvtAutoAgentASelect, grvtAutoAgentASelect.value);
        rebuild(grvtAutoAgentBSelect, grvtAutoAgentBSelect.value);
        if (!grvtAutoAgentASelect.value && autoBalanceLastConfig?.agent_a && hasOption(grvtAutoAgentASelect, autoBalanceLastConfig.agent_a)) {
          grvtAutoAgentASelect.value = autoBalanceLastConfig.agent_a;
        }
        if (!grvtAutoAgentBSelect.value && autoBalanceLastConfig?.agent_b && hasOption(grvtAutoAgentBSelect, autoBalanceLastConfig.agent_b)) {
          grvtAutoAgentBSelect.value = autoBalanceLastConfig.agent_b;
        }
      }

      function updateParaAutoBalanceAgentOptions(agentMap) {
        if (!paraAutoAgentASelect || !paraAutoAgentBSelect) {
          return;
        }
        const entries = agentMap && typeof agentMap === 'object'
          ? Object.entries(agentMap)
          : [];
        const options = entries
          .map(([agentId, metrics]) => {
            const instrument = metrics?.instrument ? ` · ${metrics.instrument}` : '';
            return { agentId, label: `${agentId}${instrument}` };
          })
          .sort((a, b) => a.agentId.localeCompare(b.agentId, undefined, { sensitivity: 'base' }));
        const key = options.map((option) => `${option.agentId}:${option.label}`).join('|');
        if (key === paraAutoAgentsKey) {
          return;
        }
        paraAutoAgentsKey = key;
        const hasOption = (select, value) => {
          if (!select || !value) {
            return false;
          }
          return Array.from(select.options || []).some((option) => option.value === value);
        };
        const rebuild = (select, previous) => {
          if (!select) {
            return;
          }
          select.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = '选择 VPS';
          select.appendChild(placeholder);
          for (const option of options) {
            const element = document.createElement('option');
            element.value = option.agentId;
            element.textContent = option.label;
            select.appendChild(element);
          }
          if (previous && options.some((option) => option.agentId === previous)) {
            select.value = previous;
          } else {
            select.value = '';
          }
        };
        rebuild(paraAutoAgentASelect, paraAutoAgentASelect.value);
        rebuild(paraAutoAgentBSelect, paraAutoAgentBSelect.value);
        if (!paraAutoAgentASelect.value && paraAutoLastConfig?.agent_a && hasOption(paraAutoAgentASelect, paraAutoLastConfig.agent_a)) {
          paraAutoAgentASelect.value = paraAutoLastConfig.agent_a;
        }
        if (!paraAutoAgentBSelect.value && paraAutoLastConfig?.agent_b && hasOption(paraAutoAgentBSelect, paraAutoLastConfig.agent_b)) {
          paraAutoAgentBSelect.value = paraAutoLastConfig.agent_b;
        }
      }

      function applyAutoBalanceConfig(config, { markClean = false } = {}) {
        if (!grvtAutoEnabledInput) {
          return;
        }
        const enabled = Boolean(config);
        grvtAutoEnabledInput.checked = enabled;
        const setValue = (element, value, fallback = '') => {
          if (!element) {
            return;
          }
          if (value === null || value === undefined || value === '') {
            element.value = fallback;
          } else {
            element.value = value;
          }
        };
        if (grvtAutoAgentASelect) {
          grvtAutoAgentASelect.value = config?.agent_a ?? '';
        }
        if (grvtAutoAgentBSelect) {
          grvtAutoAgentBSelect.value = config?.agent_b ?? '';
        }
        const thresholdPercentRaw = config?.threshold_percent;
        let thresholdPercent = Number(thresholdPercentRaw);
        if (!Number.isFinite(thresholdPercent)) {
          const ratio = Number(config?.threshold_ratio);
          thresholdPercent = Number.isFinite(ratio) ? ratio * 100 : NaN;
        }
        setValue(
          grvtAutoThresholdInput,
          Number.isFinite(thresholdPercent) ? thresholdPercent.toString() : ''
        );
        setValue(grvtAutoMinTransferInput, config?.min_transfer ?? '');
        setValue(grvtAutoMaxTransferInput, config?.max_transfer ?? '');
        setValue(grvtAutoCurrencyInput, config?.currency ?? 'USDT', 'USDT');
        setValue(
          grvtAutoCooldownInput,
          config && Number.isFinite(Number(config.cooldown_seconds))
            ? String(config.cooldown_seconds)
            : ''
        );
        if (grvtAutoUseAvailableInput) {
          grvtAutoUseAvailableInput.checked = Boolean(config?.use_available_equity);
        }
        if (grvtAutoPairLabel) {
          if (config?.agent_a && config?.agent_b) {
            grvtAutoPairLabel.textContent = `${config.agent_a} ↔ ${config.agent_b}`;
          } else {
            grvtAutoPairLabel.textContent = '未配置';
          }
        }
        autoBalanceLastConfig = config ? { ...config } : null;
        if (markClean) {
          autoBalanceDirty = false;
          autoBalanceConfigKey = JSON.stringify(config || null);
        }
      }

      function buildAutoBalancePayload() {
        const enabled = grvtAutoEnabledInput?.checked ?? false;
        if (!enabled) {
          return { enabled: false };
        }
        const agentA = grvtAutoAgentASelect?.value || '';
        const agentB = grvtAutoAgentBSelect?.value || '';
        if (!agentA || !agentB || agentA === agentB) {
          throw new Error('请选择两台不同的 VPS');
        }
        const thresholdText = getInputValue(grvtAutoThresholdInput);
        const thresholdPercent = Number(thresholdText);
        if (!Number.isFinite(thresholdPercent) || thresholdPercent <= 0) {
          throw new Error('阈值百分比必须大于 0');
        }
        const minTransferText = getInputValue(grvtAutoMinTransferInput);
        const minTransferValue = Number(minTransferText);
        if (!minTransferText || !Number.isFinite(minTransferValue) || minTransferValue <= 0) {
          throw new Error('最小划转金额必须大于 0');
        }
        const payload = {
          enabled: true,
          agent_a: agentA,
          agent_b: agentB,
          threshold_percent: thresholdPercent,
          min_transfer: minTransferText,
          currency: (getInputValue(grvtAutoCurrencyInput) || 'USDT').toUpperCase(),
          use_available_equity: Boolean(grvtAutoUseAvailableInput?.checked),
        };
        const maxTransferText = getInputValue(grvtAutoMaxTransferInput);
        if (maxTransferText) {
          const maxTransferValue = Number(maxTransferText);
          if (!Number.isFinite(maxTransferValue) || maxTransferValue <= 0) {
            throw new Error('最大划转金额需大于 0');
          }
          payload.max_transfer = maxTransferText;
        }
        const cooldownText = getInputValue(grvtAutoCooldownInput);
        if (cooldownText) {
          const cooldownValue = Number(cooldownText);
          if (!Number.isFinite(cooldownValue) || cooldownValue < 0) {
            throw new Error('冷却时间需为非负数字');
          }
          payload.cooldown_seconds = cooldownValue;
        }
        return payload;
      }

      function formatAutoBalanceNumber(value) {
        const numeric = parseDecimal(value);
        if (Number.isFinite(numeric)) {
          return numberFormatter.format(numeric);
        }
        if (value === null || value === undefined || value === '') {
          return '--';
        }
        return String(value);
      }

      function renderAutoBalanceStatus(status, agentCount = 0) {
        if (!grvtAutoPanel) {
          return;
        }
        if (!status) {
          setAutoBalanceStatusMessage('后端尚未提供自动平衡状态');
          renderAutoBalanceList(grvtAutoMeasurement, [], '暂无实时测量');
          renderAutoBalanceList(grvtAutoLastAction, [], '暂无执行记录');
          if (grvtAutoPairLabel) {
            grvtAutoPairLabel.textContent = '未配置';
          }
          return;
        }
        const summaryParts = [];
        summaryParts.push(status.enabled ? '已启用' : '未启用');
        const config = status.config || null;
        if (config?.threshold_percent !== undefined) {
          const thresholdValue = Number(config.threshold_percent);
          if (Number.isFinite(thresholdValue)) {
            summaryParts.push(`阈值 ${thresholdValue.toFixed(2)}%`);
          }
        }
        if (agentCount > 0 && agentCount < 2) {
          summaryParts.push('至少需要两台 VPS');
        }
        const cooldownUntil = Number(status.cooldown_until);
        if (status.cooldown_active && Number.isFinite(cooldownUntil)) {
          const remaining = Math.max(0, cooldownUntil - Date.now() / 1000);
          summaryParts.push(`冷却中 ${formatDuration(remaining)}`);
        }
        if (status.last_error) {
          summaryParts.push(`错误：${status.last_error}`);
        }
        setAutoBalanceStatusMessage(summaryParts.join(' · '));
        if (grvtAutoPairLabel) {
          if (config?.agent_a && config?.agent_b) {
            grvtAutoPairLabel.textContent = `${config.agent_a} ↔ ${config.agent_b}`;
          } else {
            grvtAutoPairLabel.textContent = '未配置';
          }
        }
        const currency = (config?.currency || 'USDT').toUpperCase();
        const measurement = status.measurement || null;
        const measurementItems = [];
        if (measurement) {
          const ratioPercent = Number.isFinite(Number(measurement.ratio))
            ? `${(Number(measurement.ratio) * 100).toFixed(2)}%`
            : '—';
          const thresholdText = Number.isFinite(Number(config?.threshold_percent))
            ? `${Number(config.threshold_percent).toFixed(2)}%`
            : '—';
          measurementItems.push(`权益差值 ${formatAutoBalanceNumber(measurement.difference)} ${currency}`);
          measurementItems.push(`差值比例 ${ratioPercent} / 阈值 ${thresholdText}`);
          measurementItems.push(`计划划转 ${formatAutoBalanceNumber(measurement.transfer_amount)} ${currency}`);
          measurementItems.push(`方向 ${measurement.source_agent || '?'} → ${measurement.target_agent || '?'}`);
        }
        renderAutoBalanceList(grvtAutoMeasurement, measurementItems, '暂无实时测量');
        const lastItems = [];
        if (status.last_transfer_amount && status.last_direction) {
          const from = status.last_direction.from || '?';
          const to = status.last_direction.to || '?';
          lastItems.push(`上次划转 ${status.last_transfer_amount} ${currency} · ${from} → ${to}`);
        }
        const lastActionTs = Number(status.last_action_at);
        if (Number.isFinite(lastActionTs) && lastActionTs > 0) {
          lastItems.push(`执行时间 ${formatTimestamp(lastActionTs) || '—'}`);
        }
        if (status.last_request_id) {
          lastItems.push(`请求编号 ${status.last_request_id}`);
        }
        if (!status.cooldown_active && Number.isFinite(cooldownUntil) && cooldownUntil > 0) {
          lastItems.push(`冷却截止 ${formatTimestamp(cooldownUntil) || '—'}`);
        }
        if (status.last_error) {
          lastItems.push(`最近错误 ${status.last_error}`);
        }
        renderAutoBalanceList(
          grvtAutoLastAction,
          lastItems,
          status.enabled ? '尚无执行记录' : '停用状态'
        );
      }

      function renderAutoBalance(statusPayload, agentsMap) {
        if (!grvtAutoPanel) {
          return;
        }
        updateAutoBalanceAgentOptions(agentsMap);
        const agentCount = agentsMap && typeof agentsMap === 'object'
          ? Object.keys(agentsMap).length
          : 0;
        renderAutoBalanceStatus(statusPayload, agentCount);
        if (!statusPayload || autoBalanceDirty || autoBalanceBusy) {
          return;
        }
        const config = statusPayload.config || null;
        const serialized = JSON.stringify(config || null);
        if (serialized !== autoBalanceConfigKey) {
          applyAutoBalanceConfig(config, { markClean: true });
        }
      }

      async function submitAutoBalanceConfig() {
        if (autoBalanceBusy) {
          return;
        }
        let payload;
        try {
          payload = buildAutoBalancePayload();
        } catch (error) {
          setAutoBalanceStatusMessage(error.message || String(error));
          return;
        }
        autoBalanceBusy = true;
        updateAutoBalanceButtons();
        setAutoBalanceStatusMessage('提交自动平衡配置…');
        try {
          const response = await fetch('/auto_balance/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyAutoBalanceConfig(result.config, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderAutoBalanceStatus(result.status, agentCount);
          setAutoBalanceStatusMessage('配置已保存');
          await refreshMetrics();
        } catch (error) {
          setAutoBalanceStatusMessage(`保存失败：${error}`);
        } finally {
          autoBalanceBusy = false;
          updateAutoBalanceButtons();
        }
      }

      async function disableAutoBalance() {
        if (autoBalanceBusy) {
          return;
        }
        autoBalanceBusy = true;
        updateAutoBalanceButtons();
        setAutoBalanceStatusMessage('停用自动平衡…');
        try {
          const response = await fetch('/auto_balance/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ enabled: false }),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyAutoBalanceConfig(null, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderAutoBalanceStatus(result.status, agentCount);
          setAutoBalanceStatusMessage('已停用');
          await refreshMetrics();
        } catch (error) {
          setAutoBalanceStatusMessage(`停用失败：${error}`);
        } finally {
          autoBalanceBusy = false;
          updateAutoBalanceButtons();
        }
      }

      async function loadAutoBalanceConfig({ silent = false } = {}) {
        if (autoBalanceBusy) {
          return;
        }
        autoBalanceBusy = true;
        updateAutoBalanceButtons();
        if (!silent) {
          setAutoBalanceStatusMessage('刷新自动平衡配置…');
        }
        try {
          const response = await fetch('/auto_balance/config', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyAutoBalanceConfig(result.config, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderAutoBalanceStatus(result.status, agentCount);
          if (!silent) {
            setAutoBalanceStatusMessage('配置已更新');
          }
        } catch (error) {
          if (!silent) {
            setAutoBalanceStatusMessage(`刷新失败：${error}`);
          }
        } finally {
          autoBalanceBusy = false;
          updateAutoBalanceButtons();
        }
      }

      function applyParaAutoBalanceConfig(config, { markClean = false } = {}) {
        if (!paraAutoEnabledInput) {
          return;
        }
        const enabled = Boolean(config);
        paraAutoEnabledInput.checked = enabled;
        const setValue = (element, value, fallback = '') => {
          if (!element) {
            return;
          }
          if (value === null || value === undefined || value === '') {
            element.value = fallback;
          } else {
            element.value = value;
          }
        };
        if (paraAutoAgentASelect) {
          paraAutoAgentASelect.value = config?.agent_a ?? '';
        }
        if (paraAutoAgentBSelect) {
          paraAutoAgentBSelect.value = config?.agent_b ?? '';
        }
        const thresholdPercentRaw = config?.threshold_percent;
        let thresholdPercent = Number(thresholdPercentRaw);
        if (!Number.isFinite(thresholdPercent)) {
          const ratio = Number(config?.threshold_ratio);
          thresholdPercent = Number.isFinite(ratio) ? ratio * 100 : NaN;
        }
        setValue(
          paraAutoThresholdInput,
          Number.isFinite(thresholdPercent) ? thresholdPercent.toString() : ''
        );
        setValue(paraAutoMinTransferInput, config?.min_transfer ?? '');
        setValue(paraAutoMaxTransferInput, config?.max_transfer ?? '');
        setValue(paraAutoCurrencyInput, config?.currency ?? 'USDC', 'USDC');
        setValue(
          paraAutoCooldownInput,
          config && Number.isFinite(Number(config.cooldown_seconds))
            ? String(config.cooldown_seconds)
            : ''
        );
        if (paraAutoUseAvailableInput) {
          paraAutoUseAvailableInput.checked = Boolean(config?.use_available_equity);
        }
        if (paraAutoPairLabel) {
          if (config?.agent_a && config?.agent_b) {
            paraAutoPairLabel.textContent = `${config.agent_a} ↔ ${config.agent_b}`;
          } else {
            paraAutoPairLabel.textContent = '未配置';
          }
        }
        paraAutoLastConfig = config ? { ...config } : null;
        if (markClean) {
          paraAutoDirty = false;
          paraAutoConfigKey = JSON.stringify(config || null);
        }
      }

      function buildParaAutoBalancePayload() {
        const enabled = paraAutoEnabledInput?.checked ?? false;
        if (!enabled) {
          return { enabled: false };
        }
        const agentA = paraAutoAgentASelect?.value || '';
        const agentB = paraAutoAgentBSelect?.value || '';
        if (!agentA || !agentB || agentA === agentB) {
          throw new Error('请选择两台不同的 PARA VPS');
        }
        const thresholdText = getInputValue(paraAutoThresholdInput);
        const thresholdPercent = Number(thresholdText);
        if (!Number.isFinite(thresholdPercent) || thresholdPercent <= 0) {
          throw new Error('阈值百分比必须大于 0');
        }
        const minTransferText = getInputValue(paraAutoMinTransferInput);
        const minTransferValue = Number(minTransferText);
        if (!minTransferText || !Number.isFinite(minTransferValue) || minTransferValue <= 0) {
          throw new Error('最小划转金额必须大于 0');
        }
        const payload = {
          enabled: true,
          agent_a: agentA,
          agent_b: agentB,
          threshold_percent: thresholdPercent,
          min_transfer: minTransferText,
          currency: (getInputValue(paraAutoCurrencyInput) || 'USDC').toUpperCase(),
          use_available_equity: Boolean(paraAutoUseAvailableInput?.checked),
        };
        const maxTransferText = getInputValue(paraAutoMaxTransferInput);
        if (maxTransferText) {
          const maxTransferValue = Number(maxTransferText);
          if (!Number.isFinite(maxTransferValue) || maxTransferValue <= 0) {
            throw new Error('最大划转金额需大于 0');
          }
          payload.max_transfer = maxTransferText;
        }
        const cooldownText = getInputValue(paraAutoCooldownInput);
        if (cooldownText) {
          const cooldownValue = Number(cooldownText);
          if (!Number.isFinite(cooldownValue) || cooldownValue < 0) {
            throw new Error('冷却时间需为非负数字');
          }
          payload.cooldown_seconds = cooldownValue;
        }
        return payload;
      }

      function renderParaAutoBalanceStatus(status, agentCount = 0) {
        if (!paraAutoPanel) {
          return;
        }
        if (!status) {
          setParaAutoBalanceStatusMessage('后端尚未提供自动平衡状态');
          renderAutoBalanceList(paraAutoMeasurement, [], '暂无实时测量');
          renderAutoBalanceList(paraAutoLastAction, [], '暂无执行记录');
          if (paraAutoPairLabel) {
            paraAutoPairLabel.textContent = '未配置';
          }
          return;
        }
        const summaryParts = [];
        summaryParts.push(status.enabled ? '已启用' : '未启用');
        const config = status.config || null;
        if (config?.threshold_percent !== undefined) {
          const thresholdValue = Number(config.threshold_percent);
          if (Number.isFinite(thresholdValue)) {
            summaryParts.push(`阈值 ${thresholdValue.toFixed(2)}%`);
          }
        }
        if (agentCount > 0 && agentCount < 2) {
          summaryParts.push('至少需要两台 PARA VPS');
        }
        const cooldownUntil = Number(status.cooldown_until);
        if (status.cooldown_active && Number.isFinite(cooldownUntil)) {
          const remaining = Math.max(0, cooldownUntil - Date.now() / 1000);
          summaryParts.push(`冷却中 ${formatDuration(remaining)}`);
        }
        if (status.last_error) {
          summaryParts.push(`错误：${status.last_error}`);
        }
        setParaAutoBalanceStatusMessage(summaryParts.join(' · '));
        if (paraAutoPairLabel) {
          if (config?.agent_a && config?.agent_b) {
            paraAutoPairLabel.textContent = `${config.agent_a} ↔ ${config.agent_b}`;
          } else {
            paraAutoPairLabel.textContent = '未配置';
          }
        }
        const currency = (config?.currency || 'USDC').toUpperCase();
        const measurement = status.measurement || null;
        const measurementItems = [];
        if (measurement) {
          const ratioPercent = Number.isFinite(Number(measurement.ratio))
            ? `${(Number(measurement.ratio) * 100).toFixed(2)}%`
            : '—';
          const thresholdText = Number.isFinite(Number(config?.threshold_percent))
            ? `${Number(config.threshold_percent).toFixed(2)}%`
            : '—';
          measurementItems.push(`权益差值 ${formatAutoBalanceNumber(measurement.difference)} ${currency}`);
          measurementItems.push(`差值比例 ${ratioPercent} / 阈值 ${thresholdText}`);
          measurementItems.push(`计划划转 ${formatAutoBalanceNumber(measurement.transfer_amount)} ${currency}`);
          measurementItems.push(`方向 ${measurement.source_agent || '?'} → ${measurement.target_agent || '?'}`);
        }
        renderAutoBalanceList(paraAutoMeasurement, measurementItems, '暂无实时测量');
        const lastItems = [];
        if (status.last_transfer_amount && status.last_direction) {
          const from = status.last_direction.from || '?';
          const to = status.last_direction.to || '?';
          lastItems.push(`上次划转 ${status.last_transfer_amount} ${currency} · ${from} → ${to}`);
        }
        const lastActionTs = Number(status.last_action_at);
        if (Number.isFinite(lastActionTs) && lastActionTs > 0) {
          lastItems.push(`执行时间 ${formatTimestamp(lastActionTs) || '—'}`);
        }
        if (status.last_request_id) {
          lastItems.push(`请求编号 ${status.last_request_id}`);
        }
        if (!status.cooldown_active && Number.isFinite(cooldownUntil) && cooldownUntil > 0) {
          lastItems.push(`冷却截止 ${formatTimestamp(cooldownUntil) || '—'}`);
        }
        if (status.last_error) {
          lastItems.push(`最近错误 ${status.last_error}`);
        }
        renderAutoBalanceList(
          paraAutoLastAction,
          lastItems,
          status.enabled ? '尚无执行记录' : '停用状态'
        );
      }

      function renderParaAutoBalance(statusPayload, agentsMap) {
        if (!paraAutoPanel) {
          return;
        }
        updateParaAutoBalanceAgentOptions(agentsMap);
        const agentCount = agentsMap && typeof agentsMap === 'object'
          ? Object.keys(agentsMap).length
          : 0;
        renderParaAutoBalanceStatus(statusPayload, agentCount);
        if (!statusPayload || paraAutoDirty || paraAutoBusy) {
          return;
        }
        const config = statusPayload.config || null;
        const serialized = JSON.stringify(config || null);
        if (serialized !== paraAutoConfigKey) {
          applyParaAutoBalanceConfig(config, { markClean: true });
        }
      }

      async function submitParaAutoBalanceConfig() {
        if (paraAutoBusy) {
          return;
        }
        let payload;
        try {
          payload = buildParaAutoBalancePayload();
        } catch (error) {
          setParaAutoBalanceStatusMessage(error.message || String(error));
          return;
        }
        paraAutoBusy = true;
        updateParaAutoBalanceButtons();
        setParaAutoBalanceStatusMessage('提交自动平衡配置…');
        try {
          const response = await fetch('/para/auto_balance/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyParaAutoBalanceConfig(result.config, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderParaAutoBalanceStatus(result.status, agentCount);
          setParaAutoBalanceStatusMessage('配置已保存');
          await refreshMetrics();
        } catch (error) {
          setParaAutoBalanceStatusMessage(`保存失败：${error}`);
        } finally {
          paraAutoBusy = false;
          updateParaAutoBalanceButtons();
        }
      }

      async function disableParaAutoBalance() {
        if (paraAutoBusy) {
          return;
        }
        paraAutoBusy = true;
        updateParaAutoBalanceButtons();
        setParaAutoBalanceStatusMessage('停用自动平衡…');
        try {
          const response = await fetch('/para/auto_balance/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ enabled: false }),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyParaAutoBalanceConfig(null, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderParaAutoBalanceStatus(result.status, agentCount);
          setParaAutoBalanceStatusMessage('已停用');
          await refreshMetrics();
        } catch (error) {
          setParaAutoBalanceStatusMessage(`停用失败：${error}`);
        } finally {
          paraAutoBusy = false;
          updateParaAutoBalanceButtons();
        }
      }

      async function loadParaAutoBalanceConfig({ silent = false } = {}) {
        if (paraAutoBusy) {
          return;
        }
        paraAutoBusy = true;
        updateParaAutoBalanceButtons();
        if (!silent) {
          setParaAutoBalanceStatusMessage('刷新自动平衡配置…');
        }
        try {
          const response = await fetch('/para/auto_balance/config', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyParaAutoBalanceConfig(result.config, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderParaAutoBalanceStatus(result.status, agentCount);
          if (!silent) {
            setParaAutoBalanceStatusMessage('配置已更新');
          }
        } catch (error) {
          if (!silent) {
            setParaAutoBalanceStatusMessage(`刷新失败：${error}`);
          }
        } finally {
          paraAutoBusy = false;
          updateParaAutoBalanceButtons();
        }
      }

      function getRiskThresholdSummary() {
        if (!riskSettingsSnapshot) {
          return GLOBAL_RISK_THRESHOLD_TEXT;
        }
        const parts = [];
        const thresholdPercent = Number.isFinite(riskSettingsSnapshot.threshold_percent)
          ? Number(riskSettingsSnapshot.threshold_percent)
          : Number(riskSettingsSnapshot.threshold) * 100;
        if (Number.isFinite(thresholdPercent) && thresholdPercent > 0) {
          parts.push(`阈值 ${thresholdPercent.toFixed(1)}%`);
        }
        const resetPercent = Number.isFinite(riskSettingsSnapshot.reset_ratio_percent)
          ? Number(riskSettingsSnapshot.reset_ratio_percent)
          : Number(riskSettingsSnapshot.reset_ratio) * 100;
        if (Number.isFinite(resetPercent) && resetPercent > 0) {
          parts.push(`重置 ${resetPercent.toFixed(1)}%`);
        }
        const cooldownSeconds = Number.isFinite(riskSettingsSnapshot.cooldown)
          ? Number(riskSettingsSnapshot.cooldown)
          : Number(riskSettingsSnapshot.cooldown_minutes) * 60;
        if (Number.isFinite(cooldownSeconds) && cooldownSeconds > 0) {
          if (cooldownSeconds >= 60) {
            const minutes = cooldownSeconds / 60;
            parts.push(`冷却 ${minutes >= 10 ? minutes.toFixed(0) : minutes.toFixed(1)}m`);
          } else {
            parts.push(`冷却 ${cooldownSeconds.toFixed(0)}s`);
          }
        }
        return parts.length ? parts.join(' / ') : GLOBAL_RISK_THRESHOLD_TEXT;
      }

      function updateRiskThresholdLabel(value) {
        getRiskViews().forEach((view) => {
          if (!view.thresholdLabel) {
            return;
          }
          if (Number.isFinite(value)) {
            view.thresholdLabel.textContent = `阈值 ${value.toFixed(1)}%`;
          } else {
            view.thresholdLabel.textContent = '阈值 --%';
          }
        });
      }

      function updateRiskMeta() {
        const parts = [];
        // Global 面板显示 global/latest 的 risk ratio；PARA 面板严格显示 paraLatestRiskRatio
        const views = getRiskViews();
        for (const view of views) {
          const viewParts = [];
          const isPara = view.panel === paraRiskPanel;
          const ratio = isPara ? paraLatestRiskRatio : latestGlobalRiskRatio;
          if (Number.isFinite(ratio)) {
            viewParts.push(`当前风险 ${(ratio * 100).toFixed(2)}%`);
          }
          const thresholdSummary = getRiskThresholdSummary();
          if (thresholdSummary) {
            viewParts.push(thresholdSummary);
          }
          const lastAlertTs = Number(riskSettingsSnapshot?.last_alert_at);
          if (Number.isFinite(lastAlertTs) && lastAlertTs > 0) {
            viewParts.push(`上次推送 ${formatTimestamp(lastAlertTs) || '—'}`);
          }
          const cooldownRemaining = Number(riskSettingsSnapshot?.cooldown_remaining);
          if (Number.isFinite(cooldownRemaining) && cooldownRemaining > 0.5) {
            viewParts.push(`冷却剩余 ${formatDuration(cooldownRemaining)}`);
          }
          const text = viewParts.length ? viewParts.join(' · ') : '等待风险数据…';
          if (view.meta) {
            view.meta.textContent = text;
          }
        }
        return;
        const thresholdSummary = getRiskThresholdSummary();
        if (thresholdSummary) {
          parts.push(thresholdSummary);
        }
        const lastAlertTs = Number(riskSettingsSnapshot?.last_alert_at);
        if (Number.isFinite(lastAlertTs) && lastAlertTs > 0) {
          parts.push(`上次推送 ${formatTimestamp(lastAlertTs) || '—'}`);
        }
        const cooldownRemaining = Number(riskSettingsSnapshot?.cooldown_remaining);
        if (Number.isFinite(cooldownRemaining) && cooldownRemaining > 0.5) {
          parts.push(`冷却剩余 ${formatDuration(cooldownRemaining)}`);
        }
        const text = parts.length ? parts.join(' · ') : '等待风险数据…';
        getRiskViews().forEach((view) => {
          if (view.meta) {
            view.meta.textContent = text;
          }
        });
      }

      function setRiskStatusMessage(message) {
        getRiskViews().forEach((view) => {
          if (view.message) {
            view.message.textContent = message || '未加载';
          }
        });
      }

      function setRiskTestMessage(message) {
        getRiskViews().forEach((view) => {
          if (view.testMessage) {
            view.testMessage.textContent = message || '';
          }
        });
      }

      function describeRiskAlertSource(entry) {
        if (!entry) {
          return '—';
        }
        const source = String(entry.source || 'auto').toLowerCase();
        let label = source === 'test' ? '测试' : '自动';
        if (entry.status === 'error') {
          label += ' · 失败';
        }
        const kind = String(entry.kind || '').toLowerCase();
        if (kind === 'para_stale') {
          label += ' · 数据不新鲜';
        }
        return label;
      }

      function renderRiskHistory(entries) {
        if (!riskHistoryBody || !riskHistoryEmpty) {
          return;
        }
        riskHistoryBody.innerHTML = '';
        if (!Array.isArray(entries) || !entries.length) {
          riskHistoryEmpty.classList.remove('hidden');
          return;
        }
        riskHistoryEmpty.classList.add('hidden');
        const fragment = document.createDocumentFragment();
        for (const entry of entries) {
          const row = document.createElement('tr');
          const timeText = formatTimestamp(entry.timestamp) || '—';
          const sourceText = describeRiskAlertSource(entry);
          const accountLabel = entry.account_label || 'Global';
          const agentLabel = entry.agent_id ? ` (${entry.agent_id})` : '';
          const ratioPercent = Number.isFinite(entry?.ratio_percent)
            ? entry.ratio_percent
            : Number.isFinite(entry?.ratio)
              ? entry.ratio * 100
              : null;
          const ratioText = Number.isFinite(ratioPercent) ? formatPercent(ratioPercent, 1) : '—';
          const baseLabel = entry.base_label ? ` ${entry.base_label}` : '';
          const lossText = `${entry.loss_value || '--'} / ${entry.base_value || '--'}${baseLabel}`;
          row.innerHTML = `
            <td>${escapeHtml(timeText)}</td>
            <td>${escapeHtml(sourceText)}</td>
            <td>${escapeHtml(accountLabel + agentLabel)}</td>
            <td>${escapeHtml(ratioText)}</td>
            <td>${escapeHtml(lossText)}</td>
          `;
          fragment.appendChild(row);
        }
        riskHistoryBody.appendChild(fragment);
      }

          function renderParaRiskHistory(entries) {
            if (!paraRiskHistoryBody || !paraRiskHistoryEmpty) {
              return;
            }
            paraRiskHistoryBody.innerHTML = '';
            const filtered = Array.isArray(entries)
              ? entries.filter((entry) => {
                  const kind = String(entry?.kind || '').toLowerCase();
                  return kind === 'para_risk' || kind === 'para_stale';
                })
              : [];
            if (!filtered.length) {
              paraRiskHistoryEmpty.classList.remove('hidden');
              if (paraRiskHistoryStatus) {
                paraRiskHistoryStatus.textContent = '暂无告警';
              }
              return;
            }
            paraRiskHistoryEmpty.classList.add('hidden');
            const fragment = document.createDocumentFragment();
            for (const entry of filtered) {
              const row = document.createElement('tr');
              const timeText = formatTimestamp(entry.timestamp) || '—';
              const sourceText = describeRiskAlertSource(entry);
              const accountLabel = entry.account_label || '—';
              const agentLabel = entry.agent_id ? ` (${entry.agent_id})` : '';
              const ratioPercent = Number.isFinite(entry?.ratio_percent)
                ? entry.ratio_percent
                : Number.isFinite(entry?.ratio)
                  ? entry.ratio * 100
                  : null;
              const ratioText = Number.isFinite(ratioPercent) ? formatPercent(ratioPercent, 1) : '—';
              const baseLabel = entry.base_label ? ` ${entry.base_label}` : ' 裕量';
              const lossText = `${entry.loss_value || '--'} / ${entry.base_value || '--'}${baseLabel}`;
              row.innerHTML = `
                <td>${escapeHtml(timeText)}</td>
                <td>${escapeHtml(sourceText)}</td>
                <td>${escapeHtml(accountLabel + agentLabel)}</td>
                <td>${escapeHtml(ratioText)}</td>
                <td>${escapeHtml(lossText)}</td>
              `;
              fragment.appendChild(row);
            }
            paraRiskHistoryBody.appendChild(fragment);
            if (paraRiskHistoryStatus) {
              paraRiskHistoryStatus.textContent = `已加载 ${filtered.length} 条告警（PARA）`;
            }
          }

      async function loadRiskHistory({ silent = false } = {}) {
        if (riskHistoryBusy) {
          return;
        }
        const now = performance.now();
        if (silent && now - lastRiskHistoryFetch < RISK_HISTORY_REFRESH_INTERVAL) {
          return;
        }
        riskHistoryBusy = true;
        if (!silent && riskHistoryStatus) {
          riskHistoryStatus.textContent = '读取告警历史…';
        }
        try {
          const response = await fetch('/risk_alert/history', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          riskHistoryEntries = Array.isArray(result?.history) ? result.history : [];
          renderRiskHistory(riskHistoryEntries);
          paraRiskHistoryEntries = riskHistoryEntries;
          renderParaRiskHistory(paraRiskHistoryEntries);
          lastRiskHistoryFetch = performance.now();
          if (riskHistoryStatus) {
            riskHistoryStatus.textContent = `已加载 ${riskHistoryEntries.length} 条告警`;
          }
          if (paraRiskHistoryStatus) {
            const paraCount = Array.isArray(paraRiskHistoryEntries)
              ? paraRiskHistoryEntries.filter((entry) => {
                  const kind = String(entry?.kind || '').toLowerCase();
                  return kind === 'para_risk' || kind === 'para_stale';
                }).length
              : 0;
            paraRiskHistoryStatus.textContent = paraCount
              ? `已加载 ${paraCount} 条告警（PARA）`
              : '暂无告警';
          }
        } catch (error) {
          if (riskHistoryStatus) {
            riskHistoryStatus.textContent = `读取失败：${error}`;
          }
          if (paraRiskHistoryStatus) {
            paraRiskHistoryStatus.textContent = `读取失败：${error}`;
          }
        } finally {
          riskHistoryBusy = false;
        }
      }

      function maybeRefreshRiskHistory() {
        loadRiskHistory({ silent: true });
      }

      function updateRiskInputsState() {
        getRiskViews().forEach((view) => {
          const viewBusy = view.mode === 'para' ? paraRiskSettingsBusy : riskSettingsBusy;
          const enabled = Boolean(view.enabledInput?.checked);
          const disableThreshold = viewBusy || !enabled;
          [view.thresholdSlider, view.thresholdInput, view.resetInput, view.cooldownInput].forEach((input) => {
            if (input) {
              input.disabled = disableThreshold && input !== view.enabledInput;
            }
          });
          [view.barkUrlInput, view.barkTimeoutInput, view.titleTemplateInput, view.bodyTemplateInput, view.barkAppendInput].forEach((input) => {
            if (input) {
              input.disabled = viewBusy;
            }
          });
        });
      }

      function updateRiskButtons() {
        getRiskViews().forEach((view) => {
          const disabled = view.mode === 'para' ? paraRiskSettingsBusy : riskSettingsBusy;
          [view.saveButton, view.refreshButton].forEach((button) => {
            if (button) {
              button.disabled = disabled;
            }
          });
          if (view.disableButton) {
            const enabled = Boolean(view.enabledInput?.checked);
            view.disableButton.disabled = disabled || !enabled;
          }
          if (view.testButton) {
            const viewBarkUrl = view.barkUrlInput ? getInputValue(view.barkUrlInput) : '';
            const hasDestination = Boolean(String(viewBarkUrl || '').trim());
            view.testButton.disabled = disabled || riskTestBusy || !hasDestination;
            view.testButton.textContent = riskTestBusy ? '测试中…' : '测试 Bark';
          }
        });
        updateRiskInputsState();
      }

      function markRiskSettingsDirty() {
        if (riskSettingsBusy) {
          return;
        }
        riskSettingsDirty = true;
        setRiskStatusMessage('配置未保存');
      }

      let globalRiskSettingsSnapshot = null;
      let paraRiskSettingsSnapshot = null;

      function normalizeRiskSettingsSnapshot(settings) {
        const snapshot = settings ? { ...settings } : null;
        if (snapshot) {
          if (!Number.isFinite(snapshot.threshold_percent) && Number.isFinite(snapshot.threshold)) {
            snapshot.threshold_percent = Number(snapshot.threshold) * 100;
          }
          if (!Number.isFinite(snapshot.cooldown) && Number.isFinite(snapshot.cooldown_minutes)) {
            snapshot.cooldown = Number(snapshot.cooldown_minutes) * 60;
          }
        }
        return snapshot;
      }

      function applyRiskSettings(settings, { markClean = false, scope = 'global' } = {}) {
        const normalized = normalizeRiskSettingsSnapshot(settings);
        if (scope === 'para') {
          paraRiskSettingsSnapshot = normalized;
        } else {
          globalRiskSettingsSnapshot = normalized;
        }

        const activeSnapshot = scope === 'para' ? paraRiskSettingsSnapshot : globalRiskSettingsSnapshot;
        const views = scope === 'para' ? getRiskViews().filter((view) => view.scope === 'para') : getRiskViews().filter((view) => view.scope !== 'para');

        const hasThreshold = Number.isFinite(activeSnapshot?.threshold_percent)
          ? Number(activeSnapshot.threshold_percent) > 0
          : Number(activeSnapshot?.threshold) > 0;
        const enabled = Boolean(activeSnapshot?.enabled && hasThreshold);
        const thresholdPercent = Number(activeSnapshot?.threshold_percent ?? (activeSnapshot?.threshold ?? 0) * 100);
        const resetPercent = Number(activeSnapshot?.reset_ratio_percent ?? (activeSnapshot?.reset_ratio ?? 0) * 100);
        const cooldownMinutes = Number.isFinite(activeSnapshot?.cooldown_minutes)
          ? Number(activeSnapshot.cooldown_minutes)
          : (Number.isFinite(activeSnapshot?.cooldown) ? Number(activeSnapshot.cooldown) / 60 : 0);

        views.forEach((view) => {
          if (view.enabledInput) {
            view.enabledInput.checked = enabled;
          }
          if (view.thresholdSlider) {
            const sliderValue = Number.isFinite(thresholdPercent) ? clamp(thresholdPercent, 5, 90) : 30;
            view.thresholdSlider.value = sliderValue;
          }
          if (view.thresholdInput) {
            view.thresholdInput.value = Number.isFinite(thresholdPercent) ? thresholdPercent.toFixed(1) : '';
          }
          if (view.resetInput) {
            view.resetInput.value = Number.isFinite(resetPercent) ? resetPercent.toFixed(1) : '';
          }
          if (view.cooldownInput) {
            view.cooldownInput.value = Number.isFinite(cooldownMinutes) ? Math.max(0, cooldownMinutes).toFixed(1) : '';
          }
          if (view.barkUrlInput) {
            view.barkUrlInput.value = activeSnapshot?.bark_url ?? '';
          }
          if (view.barkAppendInput) {
            view.barkAppendInput.checked = Boolean(activeSnapshot?.bark_append_payload ?? true);
          }
          if (view.barkTimeoutInput) {
            view.barkTimeoutInput.value = activeSnapshot?.bark_timeout ?? '';
          }
          if (view.titleTemplateInput) {
            view.titleTemplateInput.value = activeSnapshot?.title_template ?? '';
          }
          if (view.bodyTemplateInput) {
            view.bodyTemplateInput.value = activeSnapshot?.body_template ?? '';
          }
          if (view.statusPill) {
            view.statusPill.textContent = enabled ? `已启用 · ${getRiskThresholdSummary()}` : '未启用';
          }
        });
        if (scope !== 'para') {
          updateRiskThresholdLabel(thresholdPercent);
        }
        if (markClean) {
          riskSettingsDirty = false;
          setRiskStatusMessage('配置已同步');
        }
        updateRiskButtons();
        updateRiskMeta();
      }

      function buildRiskSettingsPayload({ enabledOverride } = {}) {
        const payload = {};
        const views = getRiskViews();

        const pickValue = (...inputs) => {
          for (const input of inputs) {
            const value = getInputValue(input);
            if (value !== '' && value !== undefined && value !== null) {
              return value;
            }
          }
          return '';
        };

        const pickNumber = (...inputs) => {
          let candidate = null;
          for (const input of inputs) {
            if (!input) {
              continue;
            }
            const raw = getInputValue(input);
            if (raw === '') {
              continue;
            }
            const parsed = parseDecimal(raw);
            if (Number.isFinite(parsed)) {
              candidate = parsed;
              continue;
            }
            if (input.value !== undefined && input.value !== null && String(input.value).trim() !== '') {
              const numeric = Number(input.value);
              if (Number.isFinite(numeric)) {
                candidate = numeric;
              }
            }
          }
          return candidate;
        };

        const enabledFromInputs = views.some((view) => Boolean(view.enabledInput?.checked));
        const enabled = enabledOverride !== undefined ? enabledOverride : enabledFromInputs;
        payload.enabled = enabled;

        const thresholdPercent = pickNumber(
          ...views.map((v) => v.thresholdInput),
          ...views.map((v) => v.thresholdSlider),
          riskThresholdInput,
          paraRiskThresholdInput,
          riskThresholdSlider,
          paraRiskThresholdSlider,
        );
        if (enabled) {
          if (!Number.isFinite(thresholdPercent) || thresholdPercent <= 0) {
            throw new Error('请设置大于 0 的触发阈值');
          }
          payload.threshold_percent = thresholdPercent;
          const resetPercent = pickNumber(...views.map((v) => v.resetInput), riskResetInput, paraRiskResetInput);
          if (Number.isFinite(resetPercent) && resetPercent > 0) {
            payload.reset_ratio_percent = resetPercent;
          }
        }

        const cooldownMinutes = pickNumber(...views.map((v) => v.cooldownInput), riskCooldownInput, paraRiskCooldownInput);
        if (Number.isFinite(cooldownMinutes) && cooldownMinutes >= 0) {
          payload.cooldown_minutes = cooldownMinutes;
        }

        const barkUrl = pickValue(...views.map((v) => v.barkUrlInput), riskBarkUrlInput, paraRiskBarkUrlInput);
        if (barkUrl) {
          payload.bark_url = barkUrl;
        }

        const pickCheckbox = (...inputs) => {
          let candidate = null;
          for (const input of inputs) {
            if (!input) continue;
            candidate = Boolean(input.checked);
          }
          return candidate;
        };

        const barkAppendValue = pickCheckbox(...views.map((v) => v.barkAppendInput), riskBarkAppendInput);
        if (barkAppendValue !== null) {
          payload.bark_append_payload = barkAppendValue;
        }

        const barkTimeout = pickNumber(...views.map((v) => v.barkTimeoutInput), riskBarkTimeoutInput, paraRiskBarkTimeoutInput);
        if (Number.isFinite(barkTimeout) && barkTimeout > 0) {
          payload.bark_timeout = barkTimeout;
        }

        const titleTemplate = pickValue(...views.map((v) => v.titleTemplateInput), riskTitleTemplateInput, paraRiskTitleTemplateInput);
        if (titleTemplate) {
          payload.title_template = titleTemplate;
        }

        const bodyTemplate = pickValue(...views.map((v) => v.bodyTemplateInput), riskBodyTemplateInput, paraRiskBodyTemplateInput);
        if (bodyTemplate) {
          payload.body_template = bodyTemplate;
        }

        return payload;
      }

      async function loadRiskSettings({ silent = false } = {}) {
        if (!getRiskViews().length || riskSettingsBusy) {
          return;
        }
        riskSettingsBusy = true;
        updateRiskButtons();
        if (!silent) {
          setRiskStatusMessage('读取风险配置…');
        }
        try {
          const response = await fetch('/risk_alert/settings', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyRiskSettings(result.settings, { markClean: true, scope: 'global' });
          if (!silent) {
            setRiskStatusMessage('配置已同步');
          }
        } catch (error) {
          setRiskStatusMessage(`读取失败：${error}`);
        } finally {
          riskSettingsBusy = false;
          updateRiskButtons();
        }
      }

      async function loadParaRiskSettings({ silent = false } = {}) {
        if (!paraRiskPanel || paraRiskSettingsBusy) {
          return;
        }
        paraRiskSettingsBusy = true;
        updateRiskButtons();
        if (!silent) {
          setRiskStatusMessage('读取 PARA 风险配置…');
        }
        try {
          const response = await fetch('/para/risk_alert/settings', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyRiskSettings(result.settings, { markClean: true, scope: 'para' });
          if (!silent) {
            setRiskStatusMessage('PARA 配置已同步');
          }
        } catch (error) {
          setRiskStatusMessage(`读取失败：${error}`);
        } finally {
          paraRiskSettingsBusy = false;
          updateRiskButtons();
        }
      }

      async function saveRiskSettings({ enabledOverride } = {}) {
        if (!getRiskViews().length || riskSettingsBusy) {
          return;
        }
        let payload;
        try {
          payload = buildRiskSettingsPayload({ enabledOverride });
        } catch (error) {
          setRiskStatusMessage(error.message || String(error));
          return;
        }
    riskSettingsBusy = true;
        updateRiskButtons();
        setRiskStatusMessage('保存风险配置…');
        try {
          const response = await fetch('/risk_alert/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyRiskSettings(result.settings, { markClean: true });
          setRiskStatusMessage('配置已保存');
          await refreshMetrics();
        } catch (error) {
          setRiskStatusMessage(`保存失败：${error}`);
        } finally {
          riskSettingsBusy = false;
          updateRiskButtons();
        }
      }

      async function saveParaRiskSettings({ enabledOverride } = {}) {
        if (!paraRiskPanel || paraRiskSettingsBusy) {
          return;
        }
        let payload;
        try {
          payload = buildRiskSettingsPayload({ enabledOverride });
        } catch (error) {
          setRiskStatusMessage(error.message || String(error));
          return;
        }
        paraRiskSettingsBusy = true;
        updateRiskButtons();
        setRiskStatusMessage('保存 PARA 风险配置…');
        try {
          const response = await fetch('/para/risk_alert/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyRiskSettings(result.settings, { markClean: true });
          setRiskStatusMessage('PARA 配置已保存');
          await refreshMetrics();
        } catch (error) {
          setRiskStatusMessage(`保存失败：${error}`);
        } finally {
          paraRiskSettingsBusy = false;
          updateRiskButtons();
        }
      }

      async function disableRiskAlerts() {
        await saveRiskSettings({ enabledOverride: false });
      }

      async function disableParaRiskAlerts() {
        await saveParaRiskSettings({ enabledOverride: false });
      }

      async function triggerRiskTest() {
        const hasTestButton = getRiskViews().some((view) => view.testButton);
        if (!hasTestButton || riskTestBusy) {
          return;
        }
        riskTestBusy = true;
        updateRiskButtons();
        setRiskTestMessage('推送测试通知…（将出现在「告警历史」中）');
        try {
          const payload = {};
          if (Number.isFinite(latestGlobalRiskRatio) && latestGlobalRiskRatio > 0) {
            payload.ratio = latestGlobalRiskRatio;
          }
          const response = await fetch('/risk_alert/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          const alert = result?.alert || {};
          const ratioPercent = Number(alert.ratio_percent);
          const ratioText = Number.isFinite(ratioPercent) ? `${ratioPercent.toFixed(1)}%` : '--%';
          setRiskTestMessage(`推送成功 · 风险 ${ratioText}`);
        } catch (error) {
          setRiskTestMessage(`推送失败：${error}`);
        } finally {
          riskTestBusy = false;
          updateRiskButtons();
        }
      }

      async function triggerParaRiskTest() {
        if (!paraRiskPanel || riskTestBusy) {
          return;
        }
        riskTestBusy = true;
        updateRiskButtons();
        setRiskTestMessage('推送 PARA 测试通知…（将出现在「告警历史 (PARA)」中）');
        try {
          const payload = { kind: 'para_risk' };
          if (Number.isFinite(paraLatestRiskRatio) && paraLatestRiskRatio > 0) {
            payload.ratio = paraLatestRiskRatio;
          }
          const response = await fetch('/risk_alert/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          const alert = result?.alert || {};
          const server = result?.server || null;
          const debug = result?.debug || null;
          const ratioPercent = Number(alert.ratio_percent);
          const ratioText = Number.isFinite(ratioPercent) ? `${ratioPercent.toFixed(1)}%` : '--%';
          const serverText = server?.pid ? ` · pid=${server.pid}` : '';
          const debugText = debug
            ? ` · kind=${debug.parsed_kind || '--'} use_para=${debug.use_para ? 'Y' : 'N'} base=${debug.base_label || '--'}`
            : '';
          setRiskTestMessage(`推送成功 · PARA 风险 ${ratioText}${serverText}${debugText}`);
        } catch (error) {
          setRiskTestMessage(`推送失败：${error}`);
        } finally {
          riskTestBusy = false;
          updateRiskButtons();
          // Force refresh history after testing to avoid confusion.
          loadRiskHistory({ silent: false });
        }
      }

      function extractBaseAsset(symbol) {
        if (!symbol) {
          return null;
        }
        let text = normalizeSymbolLabel(symbol);
        if (!text) {
          return null;
        }
        text = text.replace(/[:_\-\s]+/g, '/');
        const parts = text.split('/').filter(Boolean);
        let candidate = parts.length ? parts[0] : text;
        const suffixes = ['PERP', 'FUTURES', 'FUT', 'USD', 'USDT', 'USDC'];
        let stripped = true;
        while (stripped && candidate.length > 0) {
          stripped = false;
          for (const suffix of suffixes) {
            if (candidate.endsWith(suffix) && candidate.length > suffix.length) {
              candidate = candidate.slice(0, -suffix.length);
              stripped = true;
              break;
            }
          }
        }
        const match = candidate.match(/[A-Z]+/);
        return match ? match[0] : null;
      }

      function resolveMarginTier(baseAsset, notionalValue) {
        if (!baseAsset || !Number.isFinite(notionalValue) || notionalValue <= 0) {
          return null;
        }
        const schedule = (MARGIN_SCHEDULES[baseAsset] && MARGIN_SCHEDULES[baseAsset].length)
          ? MARGIN_SCHEDULES[baseAsset]
          : DEFAULT_MARGIN_SCHEDULE;
        for (const tier of schedule) {
          if (notionalValue <= tier.maxNotional) {
            return tier;
          }
        }
        return schedule[schedule.length - 1] ?? null;
      }

      function computePositionMargin(position) {
        if (!position) {
          return null;
        }

        // Prefer API-provided margins if present
        const apiInitial = parseDecimal(position.initial_margin ?? position.initialMargin);
        const apiMaint = parseDecimal(position.maintenance_margin ?? position.maintenanceMargin);
        let notional = parseDecimal(position.notional_value ?? position.notional);

        const size = parseDecimal(position.net_size ?? position.size ?? position.quantity);
        let price = parseDecimal(position.mark_price ?? position.markPrice);
        if (!Number.isFinite(price)) {
          price = parseDecimal(position.entry_price ?? position.entryPrice);
        }
        if (!Number.isFinite(notional) && Number.isFinite(size) && Number.isFinite(price)) {
          notional = Math.abs(size * price);
        }

        const baseAsset = extractBaseAsset(position.symbol);

        // If API margins are available, return them directly (with rates when possible)
        if (Number.isFinite(apiInitial) || Number.isFinite(apiMaint)) {
          const effectiveNotional = Number.isFinite(notional) ? notional : null;
          return {
            baseAsset,
            notional: effectiveNotional,
            initialMargin: Number.isFinite(apiInitial) ? apiInitial : null,
            maintenanceMargin: Number.isFinite(apiMaint) ? apiMaint : null,
            initialRate: Number.isFinite(apiInitial) && Number.isFinite(effectiveNotional) && effectiveNotional > 0
              ? apiInitial / effectiveNotional
              : null,
            maintenanceRate: Number.isFinite(apiMaint) && Number.isFinite(effectiveNotional) && effectiveNotional > 0
              ? apiMaint / effectiveNotional
              : null,
          };
        }

        if (!Number.isFinite(size) || !Number.isFinite(price) || !Number.isFinite(notional) || notional <= 0) {
          return null;
        }

        const tier = resolveMarginTier(baseAsset, notional);
        if (!tier) {
          return { baseAsset, notional };
        }
        return {
          baseAsset,
          notional,
          initialMargin: notional * tier.initial,
          maintenanceMargin: notional * tier.maintenance,
          initialRate: tier.initial,
          maintenanceRate: tier.maintenance,
        };
      }

      function estimateTransferableFunds(input) {
        if (!input) {
          return null;
        }

        const pickFirstFinite = (...values) => {
          for (const value of values) {
            if (Number.isFinite(value)) {
              return Number(value);
            }
          }
          return null;
        };

        const equity = pickFirstFinite(
          input.equityValue,
          input.availableEquityValue,
          Number.isFinite(input.walletValue) && Number.isFinite(input.unrealizedPnl)
            ? Number(input.walletValue) + Number(input.unrealizedPnl)
            : null
        );
        if (equity === null) {
          return null;
        }

        const initialMargin = Number.isFinite(input.totalInitialMargin) && input.totalInitialMargin > 0
          ? Number(input.totalInitialMargin)
          : 0;
        const unrealizedProfit = Number.isFinite(input.unrealizedPnl) && input.unrealizedPnl > 0
          ? Number(input.unrealizedPnl)
          : 0;
        const estimated = equity - initialMargin - unrealizedProfit;
        if (!Number.isFinite(estimated)) {
          return null;
        }

        const clipped = Math.max(0, estimated);
        return {
          raw: estimated,
          value: clipped,
          basis: 'equity',
          initialMargin,
          unrealized: unrealizedProfit,
        };
      }

      function acceptRiskCapacityValue(state, value, timestamp) {
        const targetState = state || riskCapacityBufferState;
        targetState.acceptedValue = Number.isFinite(value) ? value : null;
        targetState.acceptedAt = Number.isFinite(timestamp) ? timestamp : Date.now() / 1000;
        targetState.pendingValue = null;
        targetState.pendingCycles = 0;
        targetState.pendingDeltaPct = 0;
        targetState.pendingSince = null;
      }

      function evaluateRiskCapacityBuffer({ hasValue, value, timestamp, baseNote, state = riskCapacityBufferState }) {
        const targetState = state || riskCapacityBufferState;
        const safeBaseNote = baseNote || '';
        const safeTimestamp = Number.isFinite(timestamp) ? timestamp : Date.now() / 1000;

        if (!hasValue || !Number.isFinite(value)) {
          targetState.pendingValue = null;
          targetState.pendingCycles = 0;
          targetState.pendingDeltaPct = 0;
          targetState.pendingSince = null;
          const accepted = targetState.acceptedValue;
          if (!Number.isFinite(accepted)) {
            return { displayValue: null, note: safeBaseNote || '缺少风险基数数据', status: 'missing' };
          }
          const noteParts = [];
          if (safeBaseNote) {
            noteParts.push(safeBaseNote);
          }
          noteParts.push('沿用上次值');
          return {
            displayValue: accepted,
            note: noteParts.join(' · '),
            status: 'stale',
          };
        }

        const previous = targetState.acceptedValue;
        if (!Number.isFinite(previous)) {
          acceptRiskCapacityValue(targetState, value, safeTimestamp);
          return { displayValue: value, note: safeBaseNote, status: 'fresh' };
        }

        const delta = Math.abs(value - previous);
        const base = Math.max(Math.abs(previous), 1);
        const percentDelta = delta / base;
        const exceedsThreshold = percentDelta >= RISK_CAPACITY_DEVIATION_THRESHOLD && delta >= RISK_CAPACITY_MIN_ABS_DELTA;

        if (!exceedsThreshold) {
          acceptRiskCapacityValue(targetState, value, safeTimestamp);
          return { displayValue: value, note: safeBaseNote, status: 'fresh' };
        }

        const tolerance = Math.max(Math.abs(value), 1) * RISK_CAPACITY_PENDING_TOLERANCE;
        if (Number.isFinite(targetState.pendingValue) && Math.abs(targetState.pendingValue - value) <= tolerance) {
          targetState.pendingCycles += 1;
        } else {
          targetState.pendingValue = value;
          targetState.pendingCycles = 1;
          targetState.pendingSince = safeTimestamp;
        }
        targetState.pendingDeltaPct = percentDelta;

        if (targetState.pendingCycles >= RISK_CAPACITY_CONFIRMATION_CYCLES) {
          acceptRiskCapacityValue(targetState, value, safeTimestamp);
          return { displayValue: value, note: safeBaseNote, status: 'fresh' };
        }

        const noteParts = [];
        if (safeBaseNote) {
          noteParts.push(safeBaseNote);
        }
  noteParts.push(`数据确认中 (${targetState.pendingCycles}/${RISK_CAPACITY_CONFIRMATION_CYCLES})`);
        noteParts.push(`偏差 ${formatPercent(percentDelta * 100, 1)}`);
        return {
          displayValue: previous,
          note: noteParts.join(' · '),
          status: 'pending',
        };
      }

      function updateGrvtSymbolOptions(symbols) {
        if (!grvtAdjustSymbolsSelect) {
          return;
        }
        const normalized = Array.from(
          new Set((Array.isArray(symbols) ? symbols : []).map((symbol) => normalizeSymbolLabel(symbol)).filter(Boolean))
        ).sort();
        const previousValue = normalizeSymbolLabel(grvtAdjustSymbolsSelect.value);
        grvtAdjustSymbolsSelect.innerHTML = '';
        grvtAdjustSymbolsSelect.disabled = normalized.length === 0;
        if (grvtResetSymbolButton) {
          grvtResetSymbolButton.disabled = normalized.length === 0;
        }
        let matched = false;
        for (const symbol of normalized) {
          const option = document.createElement('option');
          option.value = symbol;
          option.textContent = symbol;
          if (previousValue === symbol) {
            option.selected = true;
            matched = true;
          }
          grvtAdjustSymbolsSelect.appendChild(option);
        }

        if (!matched) {
          grvtAdjustSymbolsSelect.selectedIndex = -1;
        }
      }

      function getSelectedGrvtSymbols() {
        if (!grvtAdjustSymbolsSelect) {
          return null;
        }
        const value = grvtAdjustSymbolsSelect.value;
        if (!value) {
          return null;
        }
        return [value];
      }

      function clearGrvtSymbolSelection() {
        if (!grvtAdjustSymbolsSelect) {
          return;
        }
        grvtAdjustSymbolsSelect.value = '';
        grvtAdjustSymbolsSelect.selectedIndex = -1;
      }

      function updateParaSymbolOptions(symbols) {
        if (!paraAdjustSymbolsSelect) {
          return;
        }
        const normalized = Array.from(
          new Set((Array.isArray(symbols) ? symbols : []).map((symbol) => normalizeSymbolLabel(symbol)).filter(Boolean))
        ).sort();
        const previousValue = normalizeSymbolLabel(paraAdjustSymbolsSelect.value);
        paraAdjustSymbolsSelect.innerHTML = '';
        paraAdjustSymbolsSelect.disabled = normalized.length === 0;
        if (paraResetSymbolButton) {
          paraResetSymbolButton.disabled = normalized.length === 0;
        }
        let matched = false;
        for (const symbol of normalized) {
          const option = document.createElement('option');
          option.value = symbol;
          option.textContent = symbol;
          if (previousValue === symbol) {
            option.selected = true;
            matched = true;
          }
          paraAdjustSymbolsSelect.appendChild(option);
        }
        if (!matched) {
          paraAdjustSymbolsSelect.selectedIndex = -1;
        }
      }

      function getSelectedParaSymbols() {
        if (!paraAdjustSymbolsSelect) {
          return null;
        }
        const value = paraAdjustSymbolsSelect.value;
        if (!value) {
          return null;
        }
        return [value];
      }

      function clearParaSymbolSelection() {
        if (!paraAdjustSymbolsSelect) {
          return;
        }
        paraAdjustSymbolsSelect.value = '';
        paraAdjustSymbolsSelect.selectedIndex = -1;
      }

      function updateParaAdjustButtons() {
        const disabled = paraAdjustLocked;
        [paraAdjustAddButton, paraAdjustReduceButton].forEach((button) => {
          if (button) {
            button.disabled = disabled;
          }
        });
      }

      function clampTwapDurationSeconds(raw) {
        const value = Number.parseInt(raw, 10);
        if (!Number.isFinite(value)) {
          return null;
        }
        const clamped = Math.min(86400, Math.max(30, value));
        return Math.round(clamped / 30) * 30;
      }

      function updateTwapVisibility() {
        const mode = (paraOrderModeSelect?.value || 'market').toLowerCase();
        if (paraTwapDurationWrapper) {
          paraTwapDurationWrapper.style.display = mode === 'twap' ? 'block' : 'none';
        }
      }

      async function sendParaAdjustment(action) {
        if (!action || paraAdjustLocked) {
          return;
        }
        const rawMagnitude = parseFloat(paraAdjustSizeInput?.value ?? '1');
        const magnitude = Number.isFinite(rawMagnitude) && rawMagnitude > 0 ? rawMagnitude : 1;
        paraAdjustLocked = true;
        updateParaAdjustButtons();
        if (paraAdjustStatus) {
          paraAdjustStatus.textContent = `提交${describeAdjustmentAction(action)}请求…`;
        }

        const payload = { action, magnitude };
        const symbols = getSelectedParaSymbols();
        if (symbols) {
          payload.symbols = symbols;
        }

        const orderMode = (paraOrderModeSelect?.value || 'market').toLowerCase();
        if (orderMode === 'twap') {
          const duration = clampTwapDurationSeconds(paraTwapDurationInput?.value ?? 0) || 900;
          payload.order_mode = 'twap';
          payload.twap_duration_seconds = duration;
        } else {
          payload.order_mode = 'market';
        }

        try {
          const response = await fetch('/para/adjust', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const responsePayload = await response.json();
          paraPendingRequestId = responsePayload?.request?.request_id ?? null;
          if (paraAdjustStatus) {
            paraAdjustStatus.textContent = '等待 VPS ACK…';
          }
          await refreshMetrics();
        } catch (error) {
          paraAdjustLocked = false;
          updateParaAdjustButtons();
          if (paraAdjustStatus) {
            paraAdjustStatus.textContent = `请求失败：${error}`;
          }
        }
      }

      function renderParaAdjustments(summary) {
        if (!paraAdjustPanel || !paraAdjustHistoryBody) {
          return;
        }
        renderParaTransferHistory(summary);
        const allRequests = Array.isArray(summary?.requests) ? summary.requests : [];
        const adjustmentRequests = allRequests.filter((request) => (request?.action || '').toLowerCase() !== 'transfer');
        const active = summary?.active_request;
        const activeIsAdjustment = (active?.action || '').toLowerCase() !== 'transfer';
        const effectiveActive = activeIsAdjustment ? active : null;
        let locked = false;

        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const scopeFor = (request) => describeSymbolScope(request?.target_symbols ?? request?.symbols);

        if (effectiveActive && ['pending', 'in_progress'].includes(normalizeStatus(effectiveActive.overall_status))) {
          locked = true;
          paraPendingRequestId = effectiveActive.request_id || null;
          const agents = Array.isArray(effectiveActive.agents) ? effectiveActive.agents : [];
          const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
          if (paraAdjustStatus) {
            const total = agents.length || 0;
            const pendingCount = pendingAgents.length;
            const scopeText = scopeFor(effectiveActive);
            paraAdjustStatus.textContent = `等待 ${pendingCount}/${total || '-'} 个 VPS ACK（${scopeText}）`;
          }
        } else if (adjustmentRequests.length) {
          const latest = adjustmentRequests[0];
          const statusText = normalizeStatus(latest.overall_status || 'pending');
          if (['pending', 'in_progress'].includes(statusText)) {
            locked = true;
            paraPendingRequestId = latest.request_id || null;
            const agents = Array.isArray(latest.agents) ? latest.agents : [];
            const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
            if (paraAdjustStatus) {
              const scopeText = scopeFor(latest);
              paraAdjustStatus.textContent = `等待 ${pendingAgents.length}/${agents.length || '-'} 个 VPS ACK（${scopeText}）`;
            }
          } else if (paraAdjustStatus) {
            const scopeText = scopeFor(latest);
            if (statusText === 'completed') {
              paraAdjustStatus.textContent = `最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）已完成`;
            } else if (statusText === 'failed') {
              paraAdjustStatus.textContent = `最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）部分失败`;
            } else {
              paraAdjustStatus.textContent = `最近状态：${statusText}（${scopeText}）`;
            }
          }
        } else if (paraAdjustStatus) {
          paraAdjustStatus.textContent = '等待指令…（默认全部币种）';
        }

        paraAdjustLocked = locked;
        if (!locked) {
          paraPendingRequestId = null;
        }
        updateParaAdjustButtons();

        if (!adjustmentRequests.length) {
          paraAdjustHistoryBody.innerHTML = '<tr><td colspan="6">暂无广播记录</td></tr>';
        } else {
          const historyRows = [];
          for (const request of adjustmentRequests.slice(0, 6)) {
            const statusText = request.overall_status || 'pending';
            const createdText = formatTimestamp(request.created_at) ?? '--';
            const agents = Array.isArray(request.agents) ? request.agents : [];
            const scopeText = scopeFor(request);
            const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
            const failedAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'failed');
            const statusMeta = [];
            if (pendingAgents.length) {
              statusMeta.push(`待ACK ${pendingAgents.length}`);
            }
            if (failedAgents.length) {
              statusMeta.push(`失败 ${failedAgents.length}`);
            }
            const statusCombined = statusMeta.length ? `${statusText}（${statusMeta.join(' / ')}）` : statusText;
            const badges = agents
              .map((agent) => {
                const status = normalizeStatus(agent.status || 'pending');
                const label = escapeHtml(agent.agent_id || 'agent');
                const cls = status === 'completed'
                  ? 'badge-success'
                  : status === 'failed'
                    ? 'badge-danger'
                    : 'badge-muted';
                return `<span class="badge ${cls}" title="${escapeHtml(status)}">${label}</span>`;
              })
              .join(' ');
            historyRows.push(`
              <tr>
                <td>${escapeHtml(createdText)}</td>
                <td>${escapeHtml(describeAdjustmentAction(request.action))}</td>
                <td>${escapeHtml(String(request.magnitude ?? '--'))}</td>
                <td>${escapeHtml(scopeText)}</td>
                <td>${escapeHtml(statusCombined)}</td>
                <td>${badges || '—'}</td>
              </tr>
            `);
          }
          paraAdjustHistoryBody.innerHTML = historyRows.join('');
        }
      }

      function updateGrvtAdjustButtons() {
        const disabled = grvtAdjustLocked;
        [grvtAdjustAddButton, grvtAdjustReduceButton].forEach((button) => {
          if (button) {
            button.disabled = disabled;
          }
        });
      }

      async function sendGrvtAdjustment(action) {
        if (!action || grvtAdjustLocked) {
          return;
        }
        const rawMagnitude = parseFloat(grvtAdjustSizeInput?.value ?? '1');
        const magnitude = Number.isFinite(rawMagnitude) && rawMagnitude > 0 ? rawMagnitude : 1;
        grvtAdjustLocked = true;
        updateGrvtAdjustButtons();
        if (grvtAdjustStatus) {
          grvtAdjustStatus.textContent = `提交${describeAdjustmentAction(action)}请求…`;
        }

        const payload = { action, magnitude };
        const selectedSymbols = getSelectedGrvtSymbols();
        if (selectedSymbols) {
          payload.symbols = selectedSymbols;
        }

        try {
          const response = await fetch('/grvt/adjust', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const responsePayload = await response.json();
          grvtPendingRequestId = responsePayload?.request?.request_id ?? null;
          if (grvtAdjustStatus) {
            grvtAdjustStatus.textContent = '等待 VPS ACK…';
          }
          await refreshMetrics();
        } catch (error) {
          grvtAdjustLocked = false;
          updateGrvtAdjustButtons();
          if (grvtAdjustStatus) {
            grvtAdjustStatus.textContent = `请求失败：${error}`;
          }
        }
      }

      function renderGrvtAdjustments(summary) {
        if (!grvtAdjustPanel || !grvtAdjustHistoryBody) {
          return;
        }
        const allRequests = Array.isArray(summary?.requests) ? summary.requests : [];
        const adjustmentRequests = allRequests.filter((request) => (request?.action || '').toLowerCase() !== 'transfer');
        const active = summary?.active_request;
        const activeIsAdjustment = (active?.action || '').toLowerCase() !== 'transfer';
        const effectiveActive = activeIsAdjustment ? active : null;
        let locked = false;

        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const scopeFor = (request) => describeSymbolScope(request?.target_symbols ?? request?.symbols);

        if (effectiveActive && ['pending', 'in_progress'].includes(normalizeStatus(effectiveActive.overall_status))) {
            locked = true;
            grvtPendingRequestId = effectiveActive.request_id || null;
            const agents = Array.isArray(effectiveActive.agents) ? effectiveActive.agents : [];
            const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
            if (grvtAdjustStatus) {
              const total = agents.length || 0;
              const pendingCount = pendingAgents.length;
              const scopeText = scopeFor(effectiveActive);
              grvtAdjustStatus.textContent = `等待 ${pendingCount}/${total || '-'} 个 VPS ACK（${scopeText}）`;
            }
        } else if (adjustmentRequests.length) {
          const latest = adjustmentRequests[0];
          const statusText = normalizeStatus(latest.overall_status || 'pending');
          if (['pending', 'in_progress'].includes(statusText)) {
            locked = true;
            grvtPendingRequestId = latest.request_id || null;
            const agents = Array.isArray(latest.agents) ? latest.agents : [];
            const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
            if (grvtAdjustStatus) {
              const scopeText = scopeFor(latest);
              grvtAdjustStatus.textContent = `等待 ${pendingAgents.length}/${agents.length || '-'} 个 VPS ACK（${scopeText}）`;
            }
          } else if (grvtAdjustStatus) {
            const scopeText = scopeFor(latest);
            if (statusText === 'completed') {
              grvtAdjustStatus.textContent = `最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）已完成`;
            } else if (statusText === 'failed') {
              grvtAdjustStatus.textContent = `最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）部分失败`;
            } else {
              grvtAdjustStatus.textContent = `最近状态：${statusText}（${scopeText}）`;
            }
          }
        } else if (grvtAdjustStatus) {
          grvtAdjustStatus.textContent = '等待指令…（默认全部币种）';
        }

        grvtAdjustLocked = locked;
        if (!locked) {
          grvtPendingRequestId = null;
        }
        updateGrvtAdjustButtons();

        if (!adjustmentRequests.length) {
          grvtAdjustHistoryBody.innerHTML = '<tr><td colspan="6">暂无广播记录</td></tr>';
        } else {
          const historyRows = [];
          for (const request of adjustmentRequests.slice(0, 6)) {
            const statusText = request.overall_status || 'pending';
            const createdText = formatTimestamp(request.created_at) ?? '--';
            const agents = Array.isArray(request.agents) ? request.agents : [];
            const scopeText = scopeFor(request);
            const badges = agents
              .map((agent) => {
                const status = normalizeStatus(agent.status || 'pending');
                const label = escapeHtml(agent.agent_id || 'agent');
                let icon = '⏳';
                if (status === 'acknowledged') {
                  icon = '✅';
                } else if (status === 'failed') {
                  icon = '⚠️';
                } else if (status === 'expired') {
                  icon = '⌛';
                }
                const cls = `adjust-badge status-${status}`;
                return `<span class="${cls}">${icon} ${label}</span>`;
              })
              .join(' ');

            historyRows.push(`
            <tr>
              <td>${escapeHtml(createdText)}</td>
              <td>${escapeHtml(describeAdjustmentAction(request.action))}</td>
              <td>${escapeHtml(numberFormatter.format(toNumber(request.magnitude ?? 0)))}</td>
              <td>${escapeHtml(scopeText)}</td>
              <td>${escapeHtml(statusText)}</td>
              <td>${badges || '—'}</td>
            </tr>
          `);
          }

          grvtAdjustHistoryBody.innerHTML = historyRows.join('');
        }
        renderGrvtTransferHistory(summary);
      }

      function normalizeRiskCapacitySeries(history, limit = 720) {
        if (!Array.isArray(history)) {
          return [];
        }
        const points = history
          .map((entry) => ({
            ts: Number(entry?.ts ?? entry?.timestamp),
            value: parseDecimal(entry?.total ?? entry?.value),
          }))
          .filter((point) => Number.isFinite(point.ts) && Number.isFinite(point.value));
        if (points.length > limit) {
          return points.slice(points.length - limit);
        }
        return points;
      }

      function normalizePriceSeriesEntry(entry, limit = 720) {
        if (!entry || !Array.isArray(entry.series)) {
          return [];
        }
        const series = entry.series.length > limit
          ? entry.series.slice(entry.series.length - limit)
          : entry.series;
        return series
          .map((point) => ({
            ts: Number(point?.ts ?? point?.time ?? point?.close_time),
            value: parseDecimal(point?.price ?? point?.close ?? point?.value),
          }))
          .filter((point) => Number.isFinite(point.ts) && Number.isFinite(point.value));
      }

      function normalizePercentChangeSeries(points) {
        if (!Array.isArray(points) || !points.length) {
          return [];
        }
        let baseline = null;
        for (const point of points) {
          const value = Number(point?.value);
          if (Number.isFinite(value) && value !== 0) {
            baseline = value;
            break;
          }
        }
        if (!Number.isFinite(baseline) || baseline === 0) {
          return [];
        }
        return points
          .map((point) => {
            const ts = Number(point?.ts);
            const value = Number(point?.value);
            if (!Number.isFinite(ts) || !Number.isFinite(value)) {
              return null;
            }
            const delta = ((value - baseline) / baseline) * 100;
            return { ts, value: delta };
          })
          .filter((point) => point && Number.isFinite(point.value));
      }

      function collectPercentPriceSeries(data) {
        const priceSeriesBlock = data?.volatility?.price_series;
        const priceEntries = priceSeriesBlock && typeof priceSeriesBlock === 'object'
          ? Object.values(priceSeriesBlock)
          : [];
        const rawSeries = [];
        const btcEntry = pickPriceEntry(priceEntries, 'BTC');
        const btcPoints = btcEntry ? normalizePriceSeriesEntry(btcEntry) : [];
        if (btcEntry && btcPoints.length) {
          rawSeries.push({
            label: btcEntry.label || btcEntry.symbol || 'BTC',
            symbol: btcEntry.symbol,
            color: BTC_LINE_COLOR,
            data: btcPoints,
          });
        }
        const ethEntry = pickPriceEntry(priceEntries, 'ETH', btcEntry?.symbol);
        const ethPoints = ethEntry ? normalizePriceSeriesEntry(ethEntry) : [];
        if (ethEntry && ethPoints.length) {
          rawSeries.push({
            label: ethEntry.label || ethEntry.symbol || 'ETH',
            symbol: ethEntry.symbol,
            color: ETH_LINE_COLOR,
            data: ethPoints,
          });
        }
        if (!rawSeries.length && priceEntries.length) {
          const fallback = priceEntries[0];
          const fallbackPoints = normalizePriceSeriesEntry(fallback);
          if (fallbackPoints.length) {
            rawSeries.push({
              label: fallback.label || fallback.symbol || 'Price',
              symbol: fallback.symbol,
              color: BTC_LINE_COLOR,
              data: fallbackPoints,
            });
          }
        }
        const percentSeries = rawSeries
          .map((series) => {
            const normalized = normalizePercentChangeSeries(series.data);
            if (!normalized.length) {
              return null;
            }
            return { ...series, data: normalized };
          })
          .filter(Boolean);
        const diffSeries = buildPriceDiffSeries(percentSeries);
        return { percentSeries, diffSeries };
      }

      function buildPriceDiffSeries(seriesList) {
        if (!Array.isArray(seriesList) || seriesList.length < 2) {
          return null;
        }
        const matchSeries = (keyword) => seriesList.find((series) => {
          const text = `${String(series.label || '')} ${String(series.symbol || '')}`.toUpperCase();
          return text.includes(keyword);
        });
        const btcSeries = matchSeries('BTC');
        const ethSeries = matchSeries('ETH');
        if (!btcSeries || !ethSeries) {
          return null;
        }
        const btcData = Array.isArray(btcSeries.data) ? btcSeries.data : [];
        const ethData = Array.isArray(ethSeries.data) ? ethSeries.data : [];
        if (!btcData.length || !ethData.length) {
          return null;
        }
        const diffPoints = [];
        let i = 0;
        let j = 0;
        while (i < btcData.length && j < ethData.length) {
          const btcPoint = btcData[i];
          const ethPoint = ethData[j];
          const btcTs = Number(btcPoint?.ts);
          const ethTs = Number(ethPoint?.ts);
          if (!Number.isFinite(btcTs)) {
            i += 1;
            continue;
          }
          if (!Number.isFinite(ethTs)) {
            j += 1;
            continue;
          }
          if (btcTs === ethTs) {
            const btcVal = Number(btcPoint?.value);
            const ethVal = Number(ethPoint?.value);
            if (Number.isFinite(btcVal) && Number.isFinite(ethVal)) {
              diffPoints.push({ ts: btcTs, value: btcVal - ethVal });
            }
            i += 1;
            j += 1;
          } else if (btcTs < ethTs) {
            i += 1;
          } else {
            j += 1;
          }
        }
        if (diffPoints.length < 2) {
          return null;
        }
        return {
          label: 'BTC-ETH Δ%',
          color: PRICE_DIFF_LINE_COLOR,
          data: diffPoints,
        };
      }

      function pickPriceEntry(entries, keyword, excludeSymbol = null) {
        if (!Array.isArray(entries)) {
          return null;
        }
        const upperKeyword = keyword ? keyword.toUpperCase() : null;
        for (const entry of entries) {
          const symbol = String(entry?.symbol || '').toUpperCase();
          if (excludeSymbol && symbol === String(excludeSymbol || '').toUpperCase()) {
            continue;
          }
          if (!upperKeyword) {
            return entry;
          }
          const label = `${symbol}${String(entry?.label || '').toUpperCase()}`;
          if (label.includes(upperKeyword)) {
            return entry;
          }
        }
        return null;
      }

      function computeNumericBounds(values) {
        let min = Infinity;
        let max = -Infinity;
        for (const value of values) {
          if (!Number.isFinite(value)) {
            continue;
          }
          if (value < min) {
            min = value;
          }
          if (value > max) {
            max = value;
          }
        }
        if (!Number.isFinite(min) || !Number.isFinite(max)) {
          return null;
        }
        if (min === max) {
          const epsilon = Math.abs(min) * 0.05 || 1;
          min -= epsilon;
          max += epsilon;
        }
        return { min, max };
      }

      function formatRangeLabel(minTs, maxTs) {
        if (!Number.isFinite(minTs) || !Number.isFinite(maxTs) || maxTs <= minTs) {
          return null;
        }
        const seconds = maxTs - minTs;
        if (seconds >= 3600) {
          return `覆盖约 ${(seconds / 3600).toFixed(1)} 小时`;
        }
        return `覆盖约 ${(seconds / 60).toFixed(0)} 分钟`;
      }

      function renderPriceChartFor(view, data) {
        const wrapper = view?.wrapper;
        const canvas = view?.canvas;
        const note = view?.note;
        const legend = view?.legend;
        if (!wrapper || !canvas) {
          return;
        }
        const { percentSeries } = collectPercentPriceSeries(data);
        if (!percentSeries.length) {
          wrapper.classList.add('hidden');
          if (note) {
            note.textContent = '等待数据…';
          }
          if (legend) {
            legend.innerHTML = '<span><span class="legend-dot legend-btc"></span>BTC</span><span><span class="legend-dot legend-eth"></span>ETH</span>';
          }
          return;
        }
        const chartResult = renderPriceCanvasFor(canvas, percentSeries);
        if (!chartResult) {
          wrapper.classList.add('hidden');
          if (note) {
            note.textContent = '等待数据…';
          }
          return;
        }
        wrapper.classList.remove('hidden');
        if (note) {
          const rangeText = formatRangeLabel(chartResult.minTs, chartResult.maxTs);
          note.textContent = rangeText || '最新数据';
        }
        if (legend) {
          legend.innerHTML = percentSeries
            .map((series) => (
              `<span><span class="legend-dot" style="background:${series.color}"></span>${escapeHtml(series.label)}</span>`
            ))
            .join('');
        }
      }

      function renderPriceChart(data) {
        renderPriceChartFor({
          wrapper: grvtPriceChartWrapper,
          canvas: grvtPriceChartCanvas,
          note: grvtPriceChartNote,
          legend: grvtPriceChartLegend,
        }, data);
      }

      function renderParaPriceChart(data) {
        renderPriceChartFor({
          wrapper: paraPriceChartWrapper,
          canvas: paraPriceChartCanvas,
          note: paraPriceChartNote,
          legend: paraPriceChartLegend,
        }, data);
      }

      function renderPriceCanvasFor(canvas, seriesList) {
        if (!canvas) {
          return null;
        }
        const setup = prepareCanvas(canvas);
        if (!setup) {
          return null;
        }
        const { ctx, width, height } = setup;
        const layout = { top: 28, right: 48, bottom: 36, left: 68 };
        const innerWidth = Math.max(10, width - layout.left - layout.right);
        const innerHeight = Math.max(10, height - layout.top - layout.bottom);
        let minTs = Infinity;
        let maxTs = -Infinity;
        const values = [];
        for (const series of seriesList) {
          for (const point of series.data) {
            const ts = Number(point.ts);
            const value = Number(point.value);
            if (!Number.isFinite(ts) || !Number.isFinite(value)) {
              continue;
            }
            if (ts < minTs) {
              minTs = ts;
            }
            if (ts > maxTs) {
              maxTs = ts;
            }
            values.push(value);
          }
        }
        if (!Number.isFinite(minTs) || !Number.isFinite(maxTs)) {
          return null;
        }
        if (maxTs - minTs < 60) {
          maxTs = minTs + 60;
        }
        const bounds = computeNumericBounds(values);
        if (!bounds) {
          return null;
        }
        const rangeX = maxTs - minTs;
        const mapX = (ts) => layout.left + ((ts - minTs) / rangeX) * innerWidth;
        const mapY = (value) => {
          const ratio = (value - bounds.min) / (bounds.max - bounds.min);
          return layout.top + (1 - ratio) * innerHeight;
        };
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(layout.left, layout.top);
        ctx.lineTo(layout.left, layout.top + innerHeight);
        ctx.moveTo(width - layout.right, layout.top);
        ctx.lineTo(width - layout.right, layout.top + innerHeight);
        ctx.moveTo(layout.left, layout.top + innerHeight);
        ctx.lineTo(width - layout.right, layout.top + innerHeight);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        const gridLines = 4;
        for (let index = 1; index < gridLines; index += 1) {
          const y = layout.top + (innerHeight / gridLines) * index;
          ctx.beginPath();
          ctx.moveTo(layout.left, y);
          ctx.lineTo(width - layout.right, y);
          ctx.stroke();
        }
        const zeroY = mapY(0);
        if (zeroY >= layout.top && zeroY <= layout.top + innerHeight) {
          ctx.strokeStyle = 'rgba(255,255,255,0.18)';
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(layout.left, zeroY);
          ctx.lineTo(width - layout.right, zeroY);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        for (const series of seriesList) {
          drawTimedSeries(ctx, series.data, mapX, mapY, series.color, 2.5);
        }
        ctx.fillStyle = '#8a94a6';
        ctx.font = '12px "Segoe UI", system-ui, sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(formatSignedPercent(bounds.max, 2), layout.left - 8, layout.top + 12);
        ctx.fillText(formatSignedPercent(bounds.min, 2), layout.left - 8, layout.top + innerHeight + 2);
        return { minTs, maxTs };
      }

      function renderPriceCanvas(seriesList) {
        return renderPriceCanvasFor(grvtPriceChartCanvas, seriesList);
      }

      function renderTransferChart(data) {
        if (!grvtTransferChartWrapper || !grvtTransferChartCanvas) {
          return;
        }
        const { diffSeries } = collectPercentPriceSeries(data);
        const activeDiffSeries = diffSeries && Array.isArray(diffSeries.data) && diffSeries.data.length >= 2
          ? diffSeries
          : null;
        const updateLegend = () => {
          if (!grvtTransferChartLegend) {
            return;
          }
          const entries = [
            '<span><span class="legend-dot legend-transfer"></span>风险基数</span>',
          ];
          if (activeDiffSeries) {
            entries.push(
              `<span><span class="legend-dot legend-diff"></span>${escapeHtml(activeDiffSeries.label || 'BTC-ETH Δ%')}</span>`
            );
          }
          grvtTransferChartLegend.innerHTML = entries.join('');
        };
        const riskCapacityPoints = normalizeRiskCapacitySeries(data?.transferable_history);
        updateLegend();
        if (!riskCapacityPoints.length) {
          grvtTransferChartWrapper.classList.add('hidden');
          if (grvtTransferChartNote) {
            grvtTransferChartNote.textContent = '等待数据…';
          }
          return;
        }
        const chartResult = renderRiskCapacityCanvas(riskCapacityPoints, activeDiffSeries);
        if (!chartResult) {
          grvtTransferChartWrapper.classList.add('hidden');
          if (grvtTransferChartNote) {
            grvtTransferChartNote.textContent = '等待数据…';
          }
          return;
        }
        grvtTransferChartWrapper.classList.remove('hidden');
        if (grvtTransferChartNote) {
          const rangeText = formatRangeLabel(chartResult.minTs, chartResult.maxTs);
          grvtTransferChartNote.textContent = rangeText || '最新数据';
        }
      }

      function renderRiskCapacityCanvas(riskCapacityPoints, diffSeries = null) {
        if (!grvtTransferChartCanvas) {
          return null;
        }
        const setup = prepareCanvas(grvtTransferChartCanvas);
        if (!setup) {
          return null;
        }
        const { ctx, width, height } = setup;
        const layout = { top: 30, right: 56, bottom: 36, left: 72 };
        const innerWidth = Math.max(10, width - layout.left - layout.right);
        const innerHeight = Math.max(10, height - layout.top - layout.bottom);
        let minTs = Infinity;
        let maxTs = -Infinity;
  const values = [];
  const diffValues = [];
  let filteredDiffPoints = null;
        for (const point of riskCapacityPoints) {
          const ts = Number(point?.ts);
          const value = Number(point?.value);
          if (!Number.isFinite(ts) || !Number.isFinite(value)) {
            continue;
          }
          if (ts < minTs) {
            minTs = ts;
          }
          if (ts > maxTs) {
            maxTs = ts;
          }
          values.push(value);
        }
        if (!Number.isFinite(minTs) || !Number.isFinite(maxTs)) {
          return null;
        }
        if (maxTs - minTs < 60) {
          maxTs = minTs + 60;
        }
        const bounds = computeNumericBounds(values);
        if (!bounds) {
          return null;
        }
        if (diffSeries && Array.isArray(diffSeries.data)) {
          const withinRange = [];
          for (const point of diffSeries.data) {
            const ts = Number(point?.ts);
            const value = Number(point?.value);
            if (!Number.isFinite(ts) || !Number.isFinite(value)) {
              continue;
            }
            if (ts < minTs || ts > maxTs) {
              continue;
            }
            withinRange.push({ ts, value });
            diffValues.push(value);
          }
          if (withinRange.length >= 2) {
            filteredDiffPoints = withinRange;
          }
        }
        const diffBounds = diffValues.length ? computeNumericBounds(diffValues) : null;
        const rangeX = maxTs - minTs;
        const mapX = (ts) => layout.left + ((ts - minTs) / rangeX) * innerWidth;
        const mapY = (value) => {
          const ratio = (value - bounds.min) / (bounds.max - bounds.min);
          return layout.top + (1 - ratio) * innerHeight;
        };
        const mapDiffY = diffBounds
          ? (value) => {
              const ratio = (value - diffBounds.min) / (diffBounds.max - diffBounds.min);
              return layout.top + (1 - ratio) * innerHeight;
            }
          : null;
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(layout.left, layout.top);
        ctx.lineTo(layout.left, layout.top + innerHeight);
        ctx.moveTo(width - layout.right, layout.top);
        ctx.lineTo(width - layout.right, layout.top + innerHeight);
        ctx.moveTo(layout.left, layout.top + innerHeight);
        ctx.lineTo(width - layout.right, layout.top + innerHeight);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        const gridLines = 4;
        for (let index = 1; index < gridLines; index += 1) {
          const y = layout.top + (innerHeight / gridLines) * index;
          ctx.beginPath();
          ctx.moveTo(layout.left, y);
          ctx.lineTo(width - layout.right, y);
          ctx.stroke();
        }
  drawTimedSeries(ctx, riskCapacityPoints, mapX, mapY, RISK_CAPACITY_LINE_COLOR, 2.8);
        if (filteredDiffPoints && diffBounds && mapDiffY) {
          const zeroDiffY = mapDiffY(0);
          if (zeroDiffY >= layout.top && zeroDiffY <= layout.top + innerHeight) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(layout.left, zeroDiffY);
            ctx.lineTo(width - layout.right, zeroDiffY);
            ctx.stroke();
            ctx.setLineDash([]);
          }
          drawTimedSeries(
            ctx,
            filteredDiffPoints,
            mapX,
            mapDiffY,
            diffSeries.color || PRICE_DIFF_LINE_COLOR,
            2.2,
          );
        }
        ctx.fillStyle = '#8a94a6';
        ctx.font = '12px "Segoe UI", system-ui, sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(numberFormatter.format(bounds.max), layout.left - 8, layout.top + 12);
        ctx.fillText(numberFormatter.format(bounds.min), layout.left - 8, layout.top + innerHeight + 2);
        if (filteredDiffPoints && diffBounds && mapDiffY) {
          ctx.textAlign = 'left';
          const rightAxisX = width - layout.right + 8;
          ctx.fillText(formatSignedPercent(diffBounds.max, 2), rightAxisX, layout.top + 12);
          ctx.fillText(formatSignedPercent(diffBounds.min, 2), rightAxisX, layout.top + innerHeight + 2);
        }
        return { minTs, maxTs };
      }

      function computeRiskRatio(totalValue, balanceValue) {
        if (!Number.isFinite(totalValue) || totalValue >= 0) {
          return null;
        }
        if (!Number.isFinite(balanceValue) || balanceValue <= 0) {
          return null;
        }
        return Math.abs(totalValue) / balanceValue;
      }

      function resolveRiskBand(ratio, bands = RISK_GRADIENTS) {
        if (!Number.isFinite(ratio) || ratio < 0) {
          return null;
        }
        const targetBands = Array.isArray(bands) && bands.length ? bands : RISK_GRADIENTS;
        for (const band of targetBands) {
          if (ratio <= band.max) {
            return band;
          }
        }
        return targetBands[targetBands.length - 1];
      }

      function applyRiskTone(element, ratio, { variant = 'summary', bands = RISK_GRADIENTS } = {}) {
        if (!element) {
          return;
        }
        element.classList.add('risk-pill');
        element.classList.toggle('risk-pill-inline', variant === 'inline');
        element.classList.toggle('risk-pill-summary', variant === 'summary');
        if (!Number.isFinite(ratio) || ratio < 0) {
          element.style.removeProperty('background');
          element.style.removeProperty('color');
          element.style.removeProperty('box-shadow');
          element.dataset.riskLevel = 'unknown';
          return;
        }
  const activeBands = Array.isArray(bands) && bands.length ? bands : RISK_GRADIENTS;
  const band = resolveRiskBand(ratio, activeBands) ?? activeBands[activeBands.length - 1];
        element.style.background = band.gradient;
        element.style.color = band.color;
        element.style.boxShadow = band.shadow;
        element.dataset.riskLevel = band.label;
      }

      function buildAccountSortKey(agentId, account, summary) {
        const safeAgent = (agentId ?? '').toString().toLowerCase();
        const accountIdentifiers = [
          account?.account_id,
          account?.id,
          account?.address,
          account?.name,
          summary?.account_id,
          summary?.address,
        ];
        let identifier = accountIdentifiers.find((value) => {
          if (value === null || value === undefined) {
            return false;
          }
          const text = String(value).trim();
          return text.length > 0;
        });
        if (identifier === undefined) {
          identifier = account ? 'account' : 'summary';
        }
        return `${safeAgent}::${String(identifier).toLowerCase()}`;
      }

      function renderPara(data) {
        if (!paraAccountCount || !paraEmpty || !paraCard) {
          return;
        }

        try {

        // Prefer top-level paradex map, but fall back to agent payloads in case coordinator
        // snapshots omit the flattened map (backward compatibility with older snapshots).
        const mergedParaMap = {};
        const directMap = data?.paradex_accounts;
        if (directMap && typeof directMap === 'object') {
          for (const [agentId, snapshot] of Object.entries(directMap)) {
            if (snapshot) {
              mergedParaMap[agentId] = snapshot;
            }
          }
        }
        if (!Object.keys(mergedParaMap).length && data?.agents && typeof data.agents === 'object') {
          for (const [agentId, payload] of Object.entries(data.agents)) {
            const snapshot = payload?.paradex_accounts;
            if (snapshot) {
              mergedParaMap[agentId] = snapshot;
            }
          }
        }

  const entries = Object.entries(mergedParaMap);
  const nowSec = Date.now() / 1000;

        if (!entries.length) {
          paraLatestRiskRatio = null;
          recomputeGlobalRiskRatio();
          paraCard.classList.add('hidden');
          paraEmpty.classList.remove('hidden');
          paraAccountCount.textContent = '0 accounts';
          paraTotalPnl.textContent = '--';
          paraEthPnl.textContent = '--';
          paraBtcPnl.textContent = '--';
          paraTotalEquity.textContent = '--';
          paraWalletBalance.textContent = 'Wallet --';
          if (paraSourceUpdates) {
            paraSourceUpdates.textContent = '--';
            paraSourceUpdates.innerHTML = '';
          }
          if (paraAvgMaint) {
            paraAvgMaint.textContent = '--';
            paraAvgMaint.removeAttribute('title');
          }
          if (paraTransferableTotal) {
            paraTransferableTotal.textContent = '--';
          }
          if (paraTransferableNote) {
            paraTransferableNote.textContent = '等待风险裕量数据…';
          }
          if (paraRiskLevel) {
            paraRiskLevel.textContent = '--';
            applyRiskTone(paraRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
          }
          if (paraRiskDetail) {
            paraRiskDetail.textContent = 'Awaiting data…';
          }
          paraSummaryTime.textContent = '--';
          paraSummaryUpdated.textContent = 'Updated —';
          if (paraAccountGrid) {
            paraAccountGrid.innerHTML = '';
          }
          if (paraAccountsEmpty) {
            paraAccountsEmpty.classList.add('hidden');
          }
          updateParaSymbolOptions([]);
          updateParaTransferAgents([]);
          return;
        }

        paraEmpty.classList.add('hidden');
        paraCard.classList.remove('hidden');

        let aggregateAccountCount = 0;
        let aggregateTotalPnl = 0;
        let aggregateEthPnl = 0;
        let aggregateBtcPnl = 0;
        let aggregateEquity = 0;
        let aggregateWallet = 0;
        let aggregateInitialMargin = 0;
  let aggregateMaintRequirement = 0;
  let aggregateMaintBase = 0;
  let hasTotal = false;
  let hasEth = false;
  let hasBtc = false;
  let hasEquity = false;
  let hasWallet = false;
  let latestUpdate = 0;
  let maxAbsPnl = null;
  let maxInitialMargin = null;
  const flattenedAccounts = [];
  const symbolCandidates = new Set();
    const transferOptions = [];
        let worstLossAccount = null;

        for (const [agentId, snapshot] of entries) {
          try {
            if (!snapshot || typeof snapshot !== 'object') {
              continue; 
            }
            const summaryRaw = snapshot.summary;
            const summary = summaryRaw && typeof summaryRaw === 'object' ? summaryRaw : {};
            const transferDefaults = snapshot.transfer_defaults && typeof snapshot.transfer_defaults === 'object'
              ? snapshot.transfer_defaults
              : {};
            const agentLabel = summary?.label || summary?.account_label || summary?.name || agentId;
            transferOptions.push({ agentId, label: agentLabel, defaults: transferDefaults });
            const accountsRaw = snapshot.accounts;
            const accounts = Array.isArray(accountsRaw) ? accountsRaw : [];
            const snapshotTs = Number(summary.updated_at ?? snapshot.updated_at);
            if (Number.isFinite(snapshotTs) && snapshotTs > latestUpdate) {
              latestUpdate = snapshotTs;
            }

            if (accounts.length) {
              aggregateAccountCount += accounts.length;
              for (const account of accounts) {
                const accountObj = account && typeof account === 'object' ? account : {};
                const total = parseDecimal(accountObj.total_pnl);
                const eth = parseDecimal(accountObj.eth_pnl);
                const btc = parseDecimal(accountObj.btc_pnl);
                const equity = parseDecimal(accountObj.equity ?? accountObj.available_equity);
                const wallet = parseDecimal(accountObj.balance ?? accountObj.available_balance);
                const available = parseDecimal(accountObj.available_balance ?? accountObj.available_equity);
                const availableEquity = parseDecimal(accountObj.available_equity ?? accountObj.equity);
                const initialMarginFromApi = parseDecimal(accountObj.initial_margin_requirement);
                let initialMarginTotal = Number.isFinite(initialMarginFromApi) ? initialMarginFromApi : 0;
                const positionsList = Array.isArray(accountObj.positions) ? accountObj.positions : [];
                if (!Number.isFinite(initialMarginTotal) || initialMarginTotal === 0) {
                  initialMarginTotal = 0;
                  if (positionsList.length) {
                    for (const position of positionsList) {
                      const leverage = parseDecimal(position.leverage);
                      const marginInfo = computePositionMargin(position);
                      const notionalValue = Number.isFinite(marginInfo?.notional)
                        ? marginInfo.notional
                        : (() => {
                            const notionalRaw = parseDecimal(position.notional_value ?? position.notional);
                            if (Number.isFinite(notionalRaw)) return notionalRaw;
                            const sizeVal = parseDecimal(position.net_size ?? position.size ?? position.quantity);
                            const priceVal = parseDecimal(position.mark_price ?? position.markPrice ?? position.entry_price ?? position.entryPrice);
                            return Number.isFinite(sizeVal) && Number.isFinite(priceVal) ? Math.abs(sizeVal * priceVal) : null;
                          })();
                      const initialMarginViaLeverage = Number.isFinite(notionalValue) && Number.isFinite(leverage) && leverage > 0
                        ? notionalValue / leverage
                        : null;
                      const initialMarginValue = Number.isFinite(initialMarginViaLeverage)
                        ? initialMarginViaLeverage
                        : (Number.isFinite(marginInfo?.initialMargin) ? marginInfo.initialMargin : null);
                      if (Number.isFinite(initialMarginValue)) {
                        initialMarginTotal += initialMarginValue;
                      }
                    }
                  }
                }
                if (Number.isFinite(total)) {
                  aggregateTotalPnl += total;
                  hasTotal = true;
                  const absPnl = Math.abs(total);
                  if (!Number.isFinite(maxAbsPnl) || absPnl > maxAbsPnl) {
                    maxAbsPnl = absPnl;
                  }
                  if (total < 0) {
                    const absLoss = absPnl;
                    if (!worstLossAccount || absLoss > worstLossAccount.lossValue) {
                      worstLossAccount = {
                        lossValue: absLoss,
                        accountName: accountObj.name ?? accountObj.account_id ?? accountObj.id ?? 'Account',
                        agentId,
                      };
                    }
                  }
                }
                if (Number.isFinite(eth)) {
                  aggregateEthPnl += eth;
                  hasEth = true;
                }
                if (Number.isFinite(btc)) {
                  aggregateBtcPnl += btc;
                  hasBtc = true;
                }
                if (Number.isFinite(equity)) {
                  aggregateEquity += equity;
                  hasEquity = true;
                }
                if (Number.isFinite(wallet)) {
                  aggregateWallet += wallet;
                  hasWallet = true;
                }
                if (Number.isFinite(initialMarginTotal)) {
                  aggregateInitialMargin += initialMarginTotal;
                  if (!Number.isFinite(maxInitialMargin) || initialMarginTotal > maxInitialMargin) {
                    maxInitialMargin = initialMarginTotal;
                  }
                }
                const transferableEstimate = estimateTransferableFunds({
                  walletValue: wallet,
                  equityValue: equity,
                  availableBalanceValue: available,
                  availableEquityValue: availableEquity,
                  totalInitialMargin: initialMarginTotal,
                  unrealizedPnl: total,
                });
                const transferableValue = transferableEstimate && Number.isFinite(transferableEstimate.value)
                  ? transferableEstimate.value
                  : null;

                flattenedAccounts.push({
                  agentId,
                  name: accountObj.name ?? accountObj.account_id ?? accountObj.id ?? 'Account',
                  total,
                  eth,
                  btc,
                  equity,
                  wallet,
                  available,
                  availableEquity,
                  transferableEstimate,
                  transferableValue,
                  positions: positionsList,
                  initialMarginTotal,
                  updatedTs: snapshotTs,
                  sortKey: buildAccountSortKey(agentId, accountObj, summary),
                });
              }
            } else {
              const total = parseDecimal(summary.total_pnl);
              const eth = parseDecimal(summary.eth_pnl);
              const btc = parseDecimal(summary.btc_pnl);
              const equity = parseDecimal(summary.equity ?? summary.available_equity);
              const wallet = parseDecimal(summary.balance ?? summary.available_balance);
              const available = parseDecimal(summary.available_balance ?? summary.available_equity);
              const availableEquity = parseDecimal(summary.available_equity ?? summary.equity);
              const initialMarginTotal = parseDecimal(summary.initial_margin_requirement);
              if (Number.isFinite(total)) {
                aggregateTotalPnl += total;
                hasTotal = true;
                const absPnl = Math.abs(total);
                if (!Number.isFinite(maxAbsPnl) || absPnl > maxAbsPnl) {
                  maxAbsPnl = absPnl;
                }
                if (total < 0) {
                  const absLoss = absPnl;
                  if (!worstLossAccount || absLoss > worstLossAccount.lossValue) {
                    worstLossAccount = {
                      lossValue: absLoss,
                      accountName: summary.name ?? summary.label ?? agentId,
                      agentId,
                    };
                  }
                }
              }
              if (Number.isFinite(eth)) {
                aggregateEthPnl += eth;
                hasEth = true;
              }
              if (Number.isFinite(btc)) {
                aggregateBtcPnl += btc;
                hasBtc = true;
              }
              if (Number.isFinite(equity)) {
                aggregateEquity += equity;
                hasEquity = true;
              }
              if (Number.isFinite(wallet)) {
                aggregateWallet += wallet;
                hasWallet = true;
              }
              if (Number.isFinite(initialMarginTotal)) {
                aggregateInitialMargin += initialMarginTotal;
                if (!Number.isFinite(maxInitialMargin) || initialMarginTotal > maxInitialMargin) {
                  maxInitialMargin = initialMarginTotal;
                }
              }
              // summary path lacks per-position IM, assume 0
              const accountCountFallback = Number(summary.account_count ?? 0);
              if (Number.isFinite(accountCountFallback) && accountCountFallback > 0) {
                aggregateAccountCount += accountCountFallback;
              }
              const transferableEstimate = estimateTransferableFunds({
                walletValue: wallet,
                equityValue: equity,
                availableBalanceValue: available,
                availableEquityValue: availableEquity,
                totalInitialMargin: Number.isFinite(initialMarginTotal) ? initialMarginTotal : 0,
                unrealizedPnl: total,
              });
              const transferableValue = transferableEstimate && Number.isFinite(transferableEstimate.value)
                ? transferableEstimate.value
                : null;

              flattenedAccounts.push({
                agentId,
                name: summary.name ?? summary.label ?? agentId,
                total,
                eth,
                btc,
                equity,
                wallet,
                available,
                availableEquity,
                transferableEstimate,
                transferableValue,
                positions: [],
                initialMarginTotal: Number.isFinite(initialMarginTotal) ? initialMarginTotal : 0,
                updatedTs: snapshotTs,
                sortKey: buildAccountSortKey(agentId, null, summary),
              });
            }
          } catch (err) {
            console.warn('PARA render error for agent', agentId, err);
          }
        }

        const sourcesLabel = entries.length === 1 ? 'source' : 'sources';
        const accountLabel = aggregateAccountCount === 1 ? 'account' : 'accounts';
        paraAccountCount.textContent = `${aggregateAccountCount} ${accountLabel} across ${entries.length} ${sourcesLabel}`;

        paraTotalPnl.textContent = hasTotal ? numberFormatter.format(aggregateTotalPnl) : '--';
        paraEthPnl.textContent = hasEth ? numberFormatter.format(aggregateEthPnl) : '--';
        paraBtcPnl.textContent = hasBtc ? numberFormatter.format(aggregateBtcPnl) : '--';
        paraTotalEquity.textContent = hasEquity ? numberFormatter.format(aggregateEquity) : '--';
        paraWalletBalance.textContent = hasWallet
          ? `Wallet ${numberFormatter.format(aggregateWallet)}`
          : 'Wallet --';

        const maxAbsPnlValue = Number.isFinite(maxAbsPnl) ? maxAbsPnl : 0;
        const maxInitialMarginValue = Number.isFinite(maxInitialMargin) ? maxInitialMargin : 0;
        const rawRiskAllowance = hasEquity
          ? aggregateEquity - 1.5 * maxInitialMarginValue
          : null;
        const hasRiskAllowanceValue = Number.isFinite(rawRiskAllowance) && rawRiskAllowance > 0;
        const riskAllowanceBaseNote = hasRiskAllowanceValue
          ? `覆盖 ${aggregateAccountCount} 个账户 · 风险裕量 = Equity - 1.5×max(IM ${numberFormatter.format(maxInitialMarginValue)})`
          : '缺少风险裕量数据';
        const bufferedRiskCapacity = evaluateRiskCapacityBuffer({
          hasValue: hasRiskAllowanceValue,
          value: hasRiskAllowanceValue ? rawRiskAllowance : null,
          timestamp: latestUpdate,
          baseNote: riskAllowanceBaseNote,
          state: paraRiskCapacityBufferState,
        });
        const effectiveRiskCapacity = Number.isFinite(bufferedRiskCapacity.displayValue)
          ? bufferedRiskCapacity.displayValue
          : null;

        if (paraTransferableTotal) {
          paraTransferableTotal.textContent = Number.isFinite(effectiveRiskCapacity)
            ? numberFormatter.format(effectiveRiskCapacity)
            : '--';
        }
        if (paraTransferableNote) {
          paraTransferableNote.textContent = bufferedRiskCapacity.note;
        }

        let paraRiskRatio = null;
        paraLatestRiskRatio = null;
        if (paraRiskLevel && paraRiskDetail) {
          const denominator = Number.isFinite(effectiveRiskCapacity) && effectiveRiskCapacity > 0
            ? effectiveRiskCapacity
            : null;
          const numerator = Number.isFinite(maxAbsPnlValue) ? maxAbsPnlValue : null;
          if (worstLossAccount && denominator && Number.isFinite(numerator)) {
            paraRiskRatio = numerator / denominator;
            paraRiskLevel.textContent = formatPercent(paraRiskRatio * 100, 2);
            applyRiskTone(paraRiskLevel, paraRiskRatio, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            const accountLabelText = worstLossAccount.accountName
              ? `${worstLossAccount.accountName} (${worstLossAccount.agentId})`
              : worstLossAccount.agentId;
            const lossText = numberFormatter.format(numerator ?? 0);
            const riskCapacityText = numberFormatter.format(denominator);
            paraRiskDetail.textContent = `${accountLabelText}亏损 ${lossText} / 裕量 ${riskCapacityText} · ${getRiskThresholdSummary()}`;
            paraLatestRiskRatio = paraRiskRatio;
          } else if (worstLossAccount && !denominator) {
            paraRiskLevel.textContent = '—';
            applyRiskTone(paraRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            paraRiskDetail.textContent = '缺少风险裕量数据，无法计算 RISK';
          } else {
            paraRiskLevel.textContent = '—';
            applyRiskTone(paraRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            paraRiskDetail.textContent = '无亏损或缺少盈亏数据';
          }
        }

        recomputeGlobalRiskRatio();

        const updatedText = formatTimestamp(latestUpdate);
        paraSummaryTime.textContent = updatedText ?? '--';
        paraSummaryUpdated.textContent = updatedText ? `Updated ${updatedText}` : 'Updated —';

        // ---- PARA reduce suggestion (BTC/ETH) ----
        if (paraReduceSuggestionMain && paraReduceSuggestionDetail) {
          const meaningfulAccounts = flattenedAccounts.filter((acc) => Array.isArray(acc.positions) && acc.positions.length);
          const suggestion = computeParaReduceSuggestion(meaningfulAccounts.length ? meaningfulAccounts : flattenedAccounts);
          if (suggestion?.ok) {
            paraReduceSuggestionMain.textContent = suggestion.message || '--';
            paraReduceSuggestionDetail.textContent = suggestion.details || '—';
          } else {
            paraReduceSuggestionMain.textContent = '—';
            paraReduceSuggestionDetail.textContent = suggestion?.message || '等待账户与持仓数据…';
          }
        }

        if (paraSourceUpdates) {
          paraSourceUpdates.innerHTML = '';
          for (const [agentId, snapshot] of entries) {
            const summary = snapshot?.summary && typeof snapshot.summary === 'object' ? snapshot.summary : {};
            const agentLabel = summary.label || summary.account_label || summary.name || agentId;
            const ts = Number(summary.updated_at ?? snapshot?.updated_at);
            const span = document.createElement('span');
            span.classList.add('badge');
            if (Number.isFinite(ts)) {
              const ageSec = Math.max(0, nowSec - ts);
              const freshnessText = `${formatDuration(ageSec)} ago`;
              if (ageSec >= PARA_STALE_CRIT_SEC) {
                span.classList.add('badge-danger');
                span.textContent = `${agentLabel}: stale · ${freshnessText}`;
              } else if (ageSec >= PARA_STALE_WARN_SEC) {
                span.classList.add('badge-warn');
                span.textContent = `${agentLabel}: delayed · ${freshnessText}`;
              } else {
                span.classList.add('badge-info');
                span.textContent = `${agentLabel}: fresh · ${freshnessText}`;
              }
            } else {
              span.classList.add('badge-muted');
              span.textContent = `${agentLabel}: time N/A`;
            }
            paraSourceUpdates.appendChild(span);
          }
          if (!paraSourceUpdates.childElementCount) {
            paraSourceUpdates.textContent = '--';
          }
        }

        updateRiskMeta();

        recomputeGlobalRiskRatio();
        if (!paraAccountGrid) {
          return;
        }

        paraAccountGrid.innerHTML = '';

        if (!flattenedAccounts.length) {
          if (paraAvgMaint) {
            paraAvgMaint.textContent = '--';
            paraAvgMaint.removeAttribute('title');
          }
          if (paraSourceUpdates) {
            paraSourceUpdates.textContent = '--';
            paraSourceUpdates.innerHTML = '';
          }
          if (paraAccountsEmpty) {
            paraAccountsEmpty.classList.remove('hidden');
            const sourcesLabel = entries.length === 1 ? 'source' : 'sources';
            paraAccountsEmpty.textContent = entries.length
              ? `Received ${entries.length} ${sourcesLabel} but no account rows; check monitor payload shape.`
              : 'Waiting for account data…';
          }
          return;
        }

        if (paraAccountsEmpty) {
          paraAccountsEmpty.classList.add('hidden');
        }

        flattenedAccounts.sort((a, b) => {
          const aKey = a.sortKey ?? '';
          const bKey = b.sortKey ?? '';
          if (aKey !== bKey) {
            return aKey.localeCompare(bKey);
          }
          return (Number(b.updatedTs ?? 0) || 0) - (Number(a.updatedTs ?? 0) || 0);
        });

        for (const entry of flattenedAccounts) {
          const positions = Array.isArray(entry.positions)
            ? entry.positions.slice().sort((a, b) => {
                const aPnl = parseDecimal(a?.pnl);
                const bPnl = parseDecimal(b?.pnl);
                const aAbs = Number.isFinite(aPnl) ? Math.abs(aPnl) : -1;
                const bAbs = Number.isFinite(bPnl) ? Math.abs(bPnl) : -1;
                if (aAbs !== bAbs) {
                  return bAbs - aAbs;
                }
                const aSymbol = (a?.symbol ?? '').toString();
                const bSymbol = (b?.symbol ?? '').toString();
                return aSymbol.localeCompare(bSymbol, undefined, { sensitivity: 'base' });
              })
            : [];

          const card = document.createElement('article');
          card.className = 'grvt-account-card';

          const totalText = Number.isFinite(entry.total) ? numberFormatter.format(entry.total) : '--';
          const equityText = Number.isFinite(entry.equity) ? numberFormatter.format(entry.equity) : '--';
          const walletText = Number.isFinite(entry.wallet) ? numberFormatter.format(entry.wallet) : '--';
          const initialMarginText = Number.isFinite(entry.initialMarginTotal)
            ? numberFormatter.format(entry.initialMarginTotal)
            : '--';
          const transferableCandidate = Number.isFinite(entry.transferableValue)
            ? entry.transferableValue
            : (entry.transferableEstimate && Number.isFinite(entry.transferableEstimate.value)
              ? entry.transferableEstimate.value
              : null);
          const transferableText = Number.isFinite(transferableCandidate)
            ? numberFormatter.format(Math.max(0, transferableCandidate))
            : '--';
          const updatedText = formatTimestamp(entry.updatedTs) ?? '—';
          const ageSec = Number.isFinite(entry.updatedTs) ? Math.max(0, nowSec - entry.updatedTs) : null;
          let freshnessBadge = '';
          if (Number.isFinite(ageSec)) {
            const freshnessText = `${formatDuration(ageSec)} ago`;
            if (ageSec >= PARA_STALE_CRIT_SEC) {
              freshnessBadge = `<span class="badge badge-danger">Stale · ${escapeHtml(freshnessText)}</span>`;
            } else if (ageSec >= PARA_STALE_WARN_SEC) {
              freshnessBadge = `<span class="badge badge-warn">Delayed · ${escapeHtml(freshnessText)}</span>`;
            } else {
              freshnessBadge = `<span class="badge badge-info">Fresh · ${escapeHtml(freshnessText)}</span>`;
            }
          } else {
            freshnessBadge = '<span class="badge badge-muted">Time N/A</span>';
          }

          const positionsCountText = `${positions.length} pos`;

          card.innerHTML = `
            <header>
              <div>
                <span class="grvt-account-name">${escapeHtml(entry.name ?? 'Account')}</span>
                <span class="badge badge-info grvt-source-badge">${escapeHtml(entry.agentId ?? 'source')}</span>
              </div>
              <div class="grvt-account-badges">${freshnessBadge}</div>
              <span class="grvt-account-updated">${escapeHtml(updatedText)}</span>
            </header>
            <dl class="grvt-account-metrics">
              <div><dt>Total</dt><dd>${escapeHtml(totalText)}</dd></div>
              <div><dt>Positions</dt><dd>${escapeHtml(positionsCountText)}</dd></div>
              <div><dt>Equity</dt><dd>${escapeHtml(equityText)}</dd></div>
              <div><dt>Balance</dt><dd>${escapeHtml(walletText)}</dd></div>
              <div><dt>Init Margin</dt><dd>${escapeHtml(initialMarginText)}</dd></div>
              <div><dt>Transferable</dt><dd>${escapeHtml(transferableText)}</dd></div>
              <div data-metric="maintenance"><dt>Maint.</dt><dd><span class="maintenance-ratio">—</span></dd></div>
            </dl>
          `;

          const maintenanceRequirementTotal = Number.isFinite(entry.initialMarginTotal)
            ? 0.5 * entry.initialMarginTotal
            : 0;
          const ratioBaseValue = Number.isFinite(entry.equity) && entry.equity > 0
            ? entry.equity
            : null;

          if (positions.length) {
            const table = document.createElement('table');
            table.className = 'grvt-positions-table';
            table.innerHTML = `
              <thead>
                <tr>
                  <th>Symbol</th>
                  <th>Side</th>
                  <th>Size</th>
                  <th>Entry</th>
                  <th>Mark</th>
                  <th>PnL</th>
                  <th>Value</th>
                  <th>Leverage</th>
                  <th>Init Margin</th>
                </tr>
              </thead>
              <tbody></tbody>
            `;
            const body = table.querySelector('tbody');
            const limit = Number.isFinite(MAX_PARA_POSITIONS) ? MAX_PARA_POSITIONS : positions.length;
            const trimmed = positions.slice(0, limit);
            for (const pos of trimmed) {
              const symbol = pos.symbol ?? '--';
              if (symbol) {
                symbolCandidates.add(normalizeSymbolLabel(symbol));
              }
              const side = (pos.side ?? '').toString().toUpperCase();
              const sizeValue = parseDecimal(pos.net_size ?? pos.size ?? pos.quantity);
              const sizeText = Number.isFinite(sizeValue)
                ? numberFormatter.format(sizeValue)
                : (pos.net_size ?? pos.size ?? '--');
              const entryPriceText = formatDecimal(pos.entry_price, 4);
              const markPriceText = formatDecimal(pos.mark_price, 4);
              const pnlValue = parseDecimal(pos.pnl);
              const pnlText = Number.isFinite(pnlValue) ? formatSignedNumber(pnlValue, 6) : (pos.pnl ?? '--');
              const pnlClass = percentClass(pnlValue);
              const marginInfo = computePositionMargin(pos);
              const leverageValue = parseDecimal(pos.leverage);
              const notionalValue = Number.isFinite(marginInfo?.notional)
                ? marginInfo.notional
                : (() => {
                    const notionalRaw = parseDecimal(pos.notional_value ?? pos.notional);
                    if (Number.isFinite(notionalRaw)) return notionalRaw;
                    const sizeVal = parseDecimal(pos.net_size ?? pos.size ?? pos.quantity);
                    const priceVal = parseDecimal(pos.mark_price ?? pos.markPrice ?? pos.entry_price ?? pos.entryPrice);
                    return Number.isFinite(sizeVal) && Number.isFinite(priceVal) ? Math.abs(sizeVal * priceVal) : null;
                  })();
              const notionalText = Number.isFinite(notionalValue)
                ? numberFormatter.format(notionalValue)
                : '--';
              const leverageText = Number.isFinite(leverageValue)
                ? `${formatDecimal(leverageValue, 2)}x`
                : '--';
              const initialMarginValue = Number.isFinite(notionalValue) && Number.isFinite(leverageValue) && leverageValue > 0
                ? notionalValue / leverageValue
                : (Number.isFinite(marginInfo?.initialMargin) ? marginInfo.initialMargin : null);
              const initialMarginText = Number.isFinite(initialMarginValue)
                ? numberFormatter.format(initialMarginValue)
                : '--';
              const row = document.createElement('tr');
              row.innerHTML = `
                <td>${escapeHtml(symbol)}</td>
                <td>${escapeHtml(side || '--')}</td>
                <td>${escapeHtml(sizeText)}</td>
                <td>${escapeHtml(entryPriceText)}</td>
                <td>${escapeHtml(markPriceText)}</td>
                <td class="${pnlClass}">${escapeHtml(pnlText)}</td>
                <td>${escapeHtml(notionalText)}</td>
                <td>${escapeHtml(leverageText)}</td>
                <td>${escapeHtml(initialMarginText)}</td>
              `;
              body.appendChild(row);
            }
            card.appendChild(table);
          } else {
            const empty = document.createElement('p');
            empty.className = 'grvt-positions-empty';
            empty.textContent = 'No positions';
            card.appendChild(empty);
          }

          const maintenanceBadge = card.querySelector('[data-metric="maintenance"] .maintenance-ratio');
          if (maintenanceBadge) {
            if (ratioBaseValue && Number.isFinite(maintenanceRequirementTotal) && maintenanceRequirementTotal >= 0) {
              const ratio = maintenanceRequirementTotal / ratioBaseValue;
              maintenanceBadge.textContent = formatPercent(ratio * 100, 2);
              aggregateMaintRequirement += maintenanceRequirementTotal;
              aggregateMaintBase += ratioBaseValue;
            } else if (ratioBaseValue) {
              maintenanceBadge.textContent = formatPercent(0, 2);
            } else {
              maintenanceBadge.textContent = '—';
            }
          }

          paraAccountGrid.appendChild(card);
        }

        if (paraAvgMaint) {
          const avgMaintPercent = computePercent(aggregateMaintRequirement, aggregateMaintBase);
          if (Number.isFinite(avgMaintPercent)) {
            paraAvgMaint.textContent = formatPercent(avgMaintPercent, 2);
            paraAvgMaint.title = `Maint req ${numberFormatter.format(aggregateMaintRequirement)} / Base ${numberFormatter.format(aggregateMaintBase)}`;
          } else {
            paraAvgMaint.textContent = '--';
            paraAvgMaint.removeAttribute('title');
          }
        }

        updateParaTransferAgents(transferOptions);
        updateParaSymbolOptions(Array.from(symbolCandidates));
        recomputeGlobalRiskRatio();
        } catch (err) {
          console.warn('renderPara error', err);
          if (paraEmpty) {
            paraEmpty.classList.remove('hidden');
            paraEmpty.textContent = 'Per-account render failed; see console for details.';
          }
          if (paraCard) {
            paraCard.classList.add('hidden');
          }
          updateParaTransferAgents([]);
        }
      }

      function renderGrvt(data) {
        if (!grvtAccountCount || !grvtEmpty || !grvtCard) {
          return;
        }

        const grvtMap = data?.grvt_accounts ?? {};
        const entries = Object.entries(grvtMap);
        const symbolCandidates = new Set();
        const instrumentList = Array.isArray(data?.instruments) ? data.instruments : [];
        for (const instrument of instrumentList) {
          const symbolText = normalizeSymbolLabel(instrument);
          if (symbolText) {
            symbolCandidates.add(symbolText);
          }
        }

        if (!entries.length) {
          grvtLatestRiskRatio = null;
          recomputeGlobalRiskRatio();
          grvtCard.classList.add('hidden');
          grvtEmpty.classList.remove('hidden');
          grvtAccountCount.textContent = '0 accounts';
          if (grvtTotalEquity) {
            grvtTotalEquity.textContent = '--';
          }
          if (grvtWalletBalance) {
            grvtWalletBalance.textContent = 'Wallet --';
          }
          if (grvtTransferableTotal) {
            grvtTransferableTotal.textContent = '--';
          }
          if (grvtTransferableNote) {
            grvtTransferableNote.textContent = '等待风险基数数据…';
          }
          if (grvtRiskLevel) {
            grvtRiskLevel.textContent = '--';
            applyRiskTone(grvtRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
          }
          if (grvtRiskDetail) {
            grvtRiskDetail.textContent = 'Awaiting data…';
          }
          if (grvtAccountGrid) {
            grvtAccountGrid.innerHTML = '';
          }
          if (grvtAccountsEmpty) {
            grvtAccountsEmpty.classList.add('hidden');
          }
          updateGrvtTransferAgents([]);
          updateGrvtSymbolOptions(Array.from(symbolCandidates));
          return;
        }

        grvtEmpty.classList.add('hidden');
        grvtCard.classList.remove('hidden');

        let aggregateAccountCount = 0;
        let aggregateTotalPnl = 0;
        let aggregateEthPnl = 0;
        let aggregateBtcPnl = 0;
        let latestUpdate = 0;
        let hasTotal = false;
        let hasEth = false;
        let hasBtc = false;
        const flattenedAccounts = [];
        const transferOptions = [];

        for (const [agentId, snapshot] of entries) {
          if (!snapshot) {
            continue;
          }

          const summary = snapshot.summary ?? {};
          const transferDefaults = snapshot.transfer_defaults && typeof snapshot.transfer_defaults === 'object'
            ? snapshot.transfer_defaults
            : {};
          const agentLabel = summary?.label || summary?.account_label || summary?.name || agentId;
          transferOptions.push({ agentId, label: agentLabel, defaults: transferDefaults });
          const accounts = Array.isArray(snapshot.accounts) ? snapshot.accounts : [];
          const snapshotTs = Number(summary.updated_at ?? snapshot.updated_at);
          if (Number.isFinite(snapshotTs) && snapshotTs > latestUpdate) {
            latestUpdate = snapshotTs;
          }

          const accountCountFallback = Number(summary.account_count ?? 0);
          if (accounts.length) {
            aggregateAccountCount += accounts.length;
          } else if (Number.isFinite(accountCountFallback) && accountCountFallback > 0) {
            aggregateAccountCount += accountCountFallback;
          }

          let sourceHasTotal = false;
          let sourceHasEth = false;
          let sourceHasBtc = false;

          if (accounts.length) {
            for (const account of accounts) {
              const accountTotal = parseDecimal(account.total_pnl);
              if (Number.isFinite(accountTotal)) {
                aggregateTotalPnl += accountTotal;
                hasTotal = true;
                sourceHasTotal = true;
              }

              const accountEth = parseDecimal(account.eth_pnl);
              if (Number.isFinite(accountEth)) {
                aggregateEthPnl += accountEth;
                hasEth = true;
                sourceHasEth = true;
              }

              const accountBtc = parseDecimal(account.btc_pnl);
              if (Number.isFinite(accountBtc)) {
                aggregateBtcPnl += accountBtc;
                hasBtc = true;
                sourceHasBtc = true;
              }

              const walletValue = parseDecimal(
                account.balance ??
                account.available_balance ??
                summary.balance ??
                summary.available_balance ??
                snapshot.balance ??
                snapshot.available_balance
              );
              const availableBalanceValue = parseDecimal(
                account.available_balance ??
                summary.available_balance ??
                snapshot.available_balance
              );
              const equityValue = parseDecimal(
                account.equity ??
                account.available_equity ??
                summary.equity ??
                summary.available_equity ??
                snapshot.equity ??
                snapshot.available_equity
              );
              const availableEquityValue = parseDecimal(
                account.available_equity ??
                summary.available_equity ??
                snapshot.available_equity
              );
              const positionsList = Array.isArray(account.positions) ? account.positions : [];
              let initialMarginTotal = 0;
              if (positionsList.length) {
                for (const position of positionsList) {
                  const marginInfo = computePositionMargin(position);
                  if (marginInfo && Number.isFinite(marginInfo.initialMargin)) {
                    initialMarginTotal += marginInfo.initialMargin;
                  }
                }
              }
              const transferableEstimate = estimateTransferableFunds({
                walletValue,
                equityValue,
                availableBalanceValue,
                availableEquityValue,
                totalInitialMargin: initialMarginTotal,
                unrealizedPnl: accountTotal,
              });
              const riskBaseValue = Number.isFinite(equityValue) ? equityValue : walletValue;
              const accountTs = Number(account.updated_at ?? snapshotTs);
              flattenedAccounts.push({
                agentId,
                account,
                summary,
                updatedTs: accountTs,
                totalValue: accountTotal,
                ethValue: accountEth,
                btcValue: accountBtc,
                equityValue,
                walletValue,
                availableBalanceValue,
                availableEquityValue,
                initialMarginTotal,
                transferableEstimate,
                riskBaseValue,
                riskRatio: computeRiskRatio(accountTotal, riskBaseValue),
                sortKey: buildAccountSortKey(agentId, account, summary),
              });
            }
          }

          if (!sourceHasTotal) {
            const totalValue = parseDecimal(summary.total_pnl);
            if (Number.isFinite(totalValue)) {
              aggregateTotalPnl += totalValue;
              hasTotal = true;
            }
          }

          if (!sourceHasEth) {
            const ethValue = parseDecimal(summary.eth_pnl);
            if (Number.isFinite(ethValue)) {
              aggregateEthPnl += ethValue;
              hasEth = true;
            }
          }

          if (!sourceHasBtc) {
            const btcValue = parseDecimal(summary.btc_pnl);
            if (Number.isFinite(btcValue)) {
              aggregateBtcPnl += btcValue;
              hasBtc = true;
            }
          }

          if (!accounts.length) {
            const placeholderTotal = parseDecimal(summary.total_pnl);
            const placeholderEth = parseDecimal(summary.eth_pnl);
            const placeholderBtc = parseDecimal(summary.btc_pnl);
            const fallbackWallet = parseDecimal(
              summary.balance ??
              summary.available_balance ??
              snapshot.balance ??
              snapshot.available_balance
            );
            const fallbackEquity = parseDecimal(
              summary.equity ??
              summary.available_equity ??
              snapshot.equity ??
              snapshot.available_equity
            );
            const fallbackAvailableBalance = parseDecimal(
              summary.available_balance ??
              snapshot.available_balance
            );
            const fallbackAvailableEquity = parseDecimal(
              summary.available_equity ??
              snapshot.available_equity
            );
            const placeholderInitialMargin = 0;
            const placeholderTransferable = estimateTransferableFunds({
              walletValue: fallbackWallet,
              equityValue: fallbackEquity,
              availableBalanceValue: fallbackAvailableBalance,
              availableEquityValue: fallbackAvailableEquity,
              totalInitialMargin: placeholderInitialMargin,
              unrealizedPnl: placeholderTotal,
            });
            const riskBaseValue = Number.isFinite(fallbackEquity) ? fallbackEquity : fallbackWallet;
            flattenedAccounts.push({
              agentId,
              account: null,
              summary,
              updatedTs: snapshotTs,
              totalValue: placeholderTotal,
              ethValue: placeholderEth,
              btcValue: placeholderBtc,
              equityValue: fallbackEquity,
              walletValue: fallbackWallet,
              availableBalanceValue: fallbackAvailableBalance,
              availableEquityValue: fallbackAvailableEquity,
              initialMarginTotal: placeholderInitialMargin,
              transferableEstimate: placeholderTransferable,
              riskBaseValue,
              riskRatio: computeRiskRatio(placeholderTotal, riskBaseValue),
              sortKey: buildAccountSortKey(agentId, null, summary),
            });
          }
        }

    let aggregateEquity = 0;
    let aggregateWallet = 0;
  let aggregateInitialMargin = 0;
  let hasEquity = false;
  let hasWallet = false;
        let worstLossAccount = null;

        for (const entry of flattenedAccounts) {
          if (Number.isFinite(entry.equityValue)) {
            aggregateEquity += entry.equityValue;
            hasEquity = true;
          }
          if (Number.isFinite(entry.walletValue)) {
            aggregateWallet += entry.walletValue;
            hasWallet = true;
          }
          if (Number.isFinite(entry.initialMarginTotal)) {
            aggregateInitialMargin += entry.initialMarginTotal;
          }
          const totalValue = Number(entry.totalValue);
          if (Number.isFinite(totalValue) && totalValue < 0) {
            const absLoss = Math.abs(totalValue);
            if (!worstLossAccount || absLoss > worstLossAccount.lossValue) {
              worstLossAccount = {
                lossValue: absLoss,
                accountName: entry.account?.name ? String(entry.account.name) : null,
                agentId: entry.agentId ?? 'Source',
              };
            }
          }
        }

        const sourcesLabel = entries.length === 1 ? 'source' : 'sources';
        const accountLabel = aggregateAccountCount === 1 ? 'account' : 'accounts';
        grvtAccountCount.textContent = `${aggregateAccountCount} ${accountLabel} across ${entries.length} ${sourcesLabel}`;

        grvtTotalPnl.textContent = hasTotal ? numberFormatter.format(aggregateTotalPnl) : '--';
        grvtEthPnl.textContent = hasEth ? numberFormatter.format(aggregateEthPnl) : '--';
        grvtBtcPnl.textContent = hasBtc ? numberFormatter.format(aggregateBtcPnl) : '--';
        if (grvtTotalEquity) {
          grvtTotalEquity.textContent = hasEquity ? numberFormatter.format(aggregateEquity) : '--';
        }
        if (grvtWalletBalance) {
          grvtWalletBalance.textContent = hasWallet
            ? `Wallet ${numberFormatter.format(aggregateWallet)}`
            : 'Wallet --';
        }
        const rawRiskCapacity = hasEquity ? aggregateEquity - aggregateInitialMargin : null;
        const hasRiskCapacityValue = Number.isFinite(rawRiskCapacity) && rawRiskCapacity > 0;
        const riskCapacityBaseNote = hasRiskCapacityValue
          ? `覆盖 ${aggregateAccountCount} 个账户 · Equity-IM`
          : '缺少风险基数数据';
        const bufferedRiskCapacity = evaluateRiskCapacityBuffer({
          hasValue: hasRiskCapacityValue,
          value: hasRiskCapacityValue ? rawRiskCapacity : null,
          timestamp: latestUpdate,
          baseNote: riskCapacityBaseNote,
        });
        const effectiveRiskCapacity = Number.isFinite(bufferedRiskCapacity.displayValue)
          ? bufferedRiskCapacity.displayValue
          : null;

        if (grvtTransferableTotal) {
          grvtTransferableTotal.textContent = Number.isFinite(effectiveRiskCapacity)
            ? numberFormatter.format(effectiveRiskCapacity)
            : '--';
        }
        if (grvtTransferableNote) {
          grvtTransferableNote.textContent = bufferedRiskCapacity.note;
        }

        grvtLatestRiskRatio = null;
        if (grvtRiskLevel && grvtRiskDetail) {
          const denominator = Number.isFinite(effectiveRiskCapacity) && effectiveRiskCapacity > 0
            ? effectiveRiskCapacity
            : null;
          if (worstLossAccount && denominator) {
            const riskRatio = worstLossAccount.lossValue / denominator;
            grvtLatestRiskRatio = riskRatio;
            grvtRiskLevel.textContent = formatPercent(riskRatio * 100, 2);
            applyRiskTone(grvtRiskLevel, riskRatio, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            const accountLabelText = worstLossAccount.accountName
              ? `${worstLossAccount.accountName} (${worstLossAccount.agentId})`
              : worstLossAccount.agentId;
            const lossText = numberFormatter.format(worstLossAccount.lossValue ?? 0);
            const riskCapacityText = numberFormatter.format(denominator);
            grvtRiskDetail.textContent = `${accountLabelText}亏损 ${lossText} / 基数 ${riskCapacityText} · ${getRiskThresholdSummary()}`;
          } else if (worstLossAccount && !denominator) {
            grvtRiskLevel.textContent = '—';
            applyRiskTone(grvtRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            grvtRiskDetail.textContent = '缺少风险基数数据，无法计算 RISK';
          } else {
            grvtRiskLevel.textContent = '—';
            applyRiskTone(grvtRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            grvtRiskDetail.textContent = '无亏损或缺少盈亏数据';
          }
          recomputeGlobalRiskRatio();
          updateRiskMeta();
        }

        const updatedText = formatTimestamp(latestUpdate);
        grvtSummaryTime.textContent = updatedText ?? '--';
        grvtSummaryUpdated.textContent = updatedText ? `Updated ${updatedText}` : 'Updated —';

        updateGrvtTransferAgents(transferOptions);

        if (!grvtAccountGrid) {
          return;
        }

        grvtAccountGrid.innerHTML = '';

        if (!flattenedAccounts.length) {
          if (grvtAccountsEmpty) {
            grvtAccountsEmpty.classList.remove('hidden');
            grvtAccountsEmpty.textContent = 'Waiting for account data…';
          }
          return;
        }

        if (grvtAccountsEmpty) {
          grvtAccountsEmpty.classList.add('hidden');
        }

        flattenedAccounts.sort((a, b) => {
          const aKey = a.sortKey ?? '';
          const bKey = b.sortKey ?? '';
          if (aKey !== bKey) {
            return aKey.localeCompare(bKey);
          }
          const aTs = Number(a.updatedTs) || 0;
          const bTs = Number(b.updatedTs) || 0;
          return bTs - aTs;
        });

        for (const entry of flattenedAccounts) {
          const agentId = entry.agentId ?? 'Source';
          const account = entry.account;
          const fallbackName = account && account.name ? String(account.name) : 'Account';
          const displayName = account && account.name ? String(account.name) : `${agentId} ${fallbackName}`;
          const accountUpdated = formatTimestamp(entry.updatedTs);
          const equityValue = entry.equityValue;
          const walletValue = entry.walletValue;
          const riskPercent = Number.isFinite(entry.riskRatio) ? entry.riskRatio * 100 : null;

          if (Array.isArray(account?.positions)) {
            for (const position of account.positions) {
              const symbolText = normalizeSymbolLabel(position?.symbol);
              if (symbolText) {
                symbolCandidates.add(symbolText);
              }
            }
          }

          const card = document.createElement('article');
          card.className = 'grvt-account-card';
          card.innerHTML = `
            <header>
              <div>
                <span class="grvt-account-name">${escapeHtml(displayName)}</span>
                <span class="badge badge-info grvt-source-badge">${escapeHtml(agentId)}</span>
              </div>
              <span class="grvt-account-updated">${escapeHtml(accountUpdated ?? '—')}</span>
            </header>
          `;

          const metrics = document.createElement('dl');
          metrics.className = 'grvt-account-metrics';
          metrics.innerHTML = `
            <div><dt>Equity</dt><dd>${escapeHtml(Number.isFinite(equityValue) ? numberFormatter.format(equityValue) : '--')}</dd></div>
            <div><dt>Wallet</dt><dd>${escapeHtml(Number.isFinite(walletValue) ? numberFormatter.format(walletValue) : '--')}</dd></div>
            <div><dt>Total</dt><dd>${escapeHtml(Number.isFinite(entry.totalValue) ? numberFormatter.format(entry.totalValue) : '--')}</dd></div>
            <div data-metric="transfer"><dt>可转</dt><dd><span class="transfer-amount">—</span></dd></div>
            <div data-metric="maintenance"><dt>Maint.</dt><dd><span class="maintenance-ratio">—</span></dd></div>
            <div data-metric="risk"><dt>Risk</dt><dd><span class="risk-pill risk-pill-inline">—</span></dd></div>
          `;
          card.appendChild(metrics);

          const riskBadge = metrics.querySelector('[data-metric="risk"] .risk-pill');
          if (riskBadge) {
            if (Number.isFinite(riskPercent)) {
              riskBadge.textContent = formatPercent(riskPercent, 2);
            } else {
              riskBadge.textContent = '—';
            }
            const entryRiskRatio = Number.isFinite(entry.riskRatio) ? entry.riskRatio : null;
            applyRiskTone(riskBadge, entryRiskRatio, { variant: 'inline' });
          }

          const maintenanceBadge = metrics.querySelector('[data-metric="maintenance"] .maintenance-ratio');
          let maintenanceRequirementTotal = 0;
          const initialMarginRequirementTotal = Number.isFinite(entry.initialMarginTotal)
            ? entry.initialMarginTotal
            : 0;

          const positions = Array.isArray(account?.positions)
            ? account.positions
                .slice()
                .sort((a, b) => {
                  const aSymbol = normalizeSymbolLabel(a?.symbol);
                  const bSymbol = normalizeSymbolLabel(b?.symbol);
                  return aSymbol.localeCompare(bSymbol, undefined, { sensitivity: 'base' });
                })
                .slice(0, MAX_GRVT_POSITIONS)
            : [];
          if (positions.length) {
            const table = document.createElement('table');
            table.className = 'grvt-positions-table';
            table.innerHTML = `
              <thead>
                <tr>
                  <th>Symbol</th>
                  <th>Side</th>
                  <th>Size</th>
                  <th>Entry</th>
                  <th>Mark</th>
                  <th>PnL</th>
                  <th>Value</th>
                  <th>Init Margin</th>
                </tr>
              </thead>
              <tbody></tbody>
            `;
            const body = table.querySelector('tbody');
            for (const position of positions) {
              const side = position.side ? String(position.side).toUpperCase() : '—';
              const sizeText = formatDecimal(position.net_size, 4);
              const entryText = formatDecimal(position.entry_price, 4);
              const markText = formatDecimal(position.mark_price, 4);
              const pnlText = formatDecimal(position.pnl, 6);
              const marginInfo = computePositionMargin(position);
              if (marginInfo && Number.isFinite(marginInfo.maintenanceMargin)) {
                maintenanceRequirementTotal += marginInfo.maintenanceMargin;
              }
              const notionalText = marginInfo && Number.isFinite(marginInfo.notional)
                ? numberFormatter.format(marginInfo.notional)
                : '--';
              const initialMarginText = marginInfo && Number.isFinite(marginInfo.initialMargin)
                ? numberFormatter.format(marginInfo.initialMargin)
                : '--';
              const row = document.createElement('tr');
              row.innerHTML = `
                <td>${escapeHtml(position.symbol ?? '--')}</td>
                <td>${escapeHtml(side)}</td>
                <td>${escapeHtml(sizeText)}</td>
                <td>${escapeHtml(entryText)}</td>
                <td>${escapeHtml(markText)}</td>
                <td>${escapeHtml(pnlText)}</td>
                <td>${escapeHtml(notionalText)}</td>
                <td>${escapeHtml(initialMarginText)}</td>
              `;
              body.appendChild(row);
            }
            card.appendChild(table);
          } else {
            const empty = document.createElement('p');
            empty.className = 'grvt-positions-empty';
            empty.textContent = account ? 'No open positions' : 'Awaiting account snapshot';
            card.appendChild(empty);
          }

          const transferBadge = metrics.querySelector('[data-metric="transfer"] .transfer-amount');
          if (transferBadge) {
            const transferableEstimate = entry.transferableEstimate;
            if (transferableEstimate) {
              transferBadge.textContent = numberFormatter.format(transferableEstimate.value);
              transferBadge.title = `估算：权益 - 初始保证金 - 未实现盈利 ≈ ${numberFormatter.format(transferableEstimate.raw)}`;
              transferBadge.dataset.state = transferableEstimate.value <= 0 ? 'empty' : 'ok';
            } else {
              transferBadge.textContent = '—';
              transferBadge.title = '缺少必要的账户或仓位数据，无法估算';
              transferBadge.dataset.state = 'unknown';
            }
          }

          if (maintenanceBadge) {
            const ratioBaseValue = Number.isFinite(equityValue) && equityValue > 0
              ? equityValue
              : Number.isFinite(walletValue) && walletValue > 0
                ? walletValue
                : null;
            if (ratioBaseValue && Number.isFinite(maintenanceRequirementTotal) && maintenanceRequirementTotal >= 0) {
              const ratio = maintenanceRequirementTotal / ratioBaseValue;
              maintenanceBadge.textContent = formatPercent(ratio * 100, 2);
            } else if (ratioBaseValue) {
              maintenanceBadge.textContent = formatPercent(0, 2);
            } else {
              maintenanceBadge.textContent = '—';
            }
          }

          grvtAccountGrid.appendChild(card);
        }

        updateGrvtSymbolOptions(Array.from(symbolCandidates));
      }

      function renderAggregate(data) {
        const position = toNumber(data.position ?? data?.aggregate?.position);
        const pnl = toNumber(data.cumulative_pnl ?? data?.aggregate?.cumulative_pnl);
        const volume = toNumber(data.cumulative_volume ?? data?.aggregate?.cumulative_volume);
        const cyclesRaw = Number(data.total_cycles ?? data?.aggregate?.total_cycles ?? 0);
        const available = toNumber(
          data.available_balance ??
          data.total_available_balance ??
          data?.aggregate?.available_balance
        );
        const accountValue = toNumber(
          data.total_account_value ??
          data.account_value ??
          data?.aggregate?.total_account_value ??
          data?.aggregate?.account_value
        );

        document.getElementById('position').textContent = numberFormatter.format(position);
        document.getElementById('pnl').textContent = numberFormatter.format(pnl);
        document.getElementById('volume').textContent = numberFormatter.format(volume);
        document.getElementById('cycles').textContent = Number.isFinite(cyclesRaw) ? cyclesRaw : '--';
        document.getElementById('available-balance').textContent = numberFormatter.format(available);
        document.getElementById('account-value').textContent = numberFormatter.format(accountValue);
        const runtimeSeconds = toNumber(data.runtime_seconds ?? data?.aggregate?.runtime_seconds);
        if (runtimeElement) {
          const agentEntries = Object.entries(data?.agents ?? {});
          if (!agentEntries.length) {
            runtimeElement.classList.remove('runtime-multiple');
            runtimeElement.textContent = formatDuration(runtimeSeconds);
          } else {
            runtimeElement.classList.add('runtime-multiple');
            runtimeElement.innerHTML = '';
            agentEntries
              .slice()
              .sort((a, b) => a[0].localeCompare(b[0], undefined, { sensitivity: 'base' }))
              .forEach(([agentId, agentMetrics]) => {
                const row = document.createElement('div');
                row.className = 'runtime-row';

                const label = document.createElement('span');
                label.className = 'runtime-row-label';
                label.textContent = agentId;

                const value = document.createElement('span');
                value.className = 'runtime-row-value';
                const agentSeconds = toNumber(agentMetrics?.runtime_seconds ?? agentMetrics?.runtime ?? 0);
                value.textContent = formatDuration(agentSeconds);

                row.append(label, value);
                runtimeElement.appendChild(row);
              });
          }
        }

        if (data.last_update_ts) {
          const updatedDate = new Date(Number(data.last_update_ts) * 1000);
          const latestAgent = data.last_agent_id ? ` (agent: ${data.last_agent_id})` : '';
          updatedElement.textContent = `Last update: ${updatedDate.toLocaleString()}${latestAgent}`;
        } else {
          updatedElement.textContent = 'Awaiting data…';
        }
      }

      function updateBatchButtons() {
        if (!pauseAllButton || !resumeAllButton) {
          return;
        }

        if (batchBusy) {
          pauseAllButton.disabled = true;
          resumeAllButton.disabled = true;
        } else {
          pauseAllButton.disabled = lastDefaultPaused;
          resumeAllButton.disabled = !lastDefaultPaused;
        }

        pauseAllButton.classList.toggle('button-ghost', lastDefaultPaused);
        resumeAllButton.classList.toggle('button-ghost', !lastDefaultPaused);
      }

      function redirectIfUnauthorized(response) {
        if (response && response.status === 401) {
          window.location.href = '/login';
        }
      }

      async function sendControl(agentId, action, button) {
        if (!agentId || !action) {
          return;
        }

        const previousText = button?.textContent ?? '';
        if (button) {
          button.disabled = true;
          button.textContent = action === 'pause' ? 'Pausing…' : 'Resuming…';
        }

        try {
          const response = await fetch('/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ agent_id: agentId, action })
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          await refreshMetrics();
        } catch (error) {
          updatedElement.textContent = `Control update failed: ${error}`;
        } finally {
          if (button) {
            button.disabled = false;
            button.textContent = previousText || (action === 'pause' ? 'Pause' : 'Resume');
          }
        }
      }

      async function sendBatchControl(action, button) {
        if (!action) {
          return;
        }

        const buttons = [pauseAllButton, resumeAllButton].filter(Boolean);
        const previousTexts = new Map();

        batchBusy = true;
        updateBatchButtons();

        if (button) {
          previousTexts.set(button, button.textContent);
          button.textContent = action === 'pause' ? 'Pausing…' : 'Resuming…';
        }

        try {
          const response = await fetch('/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ scope: 'all', action })
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          await refreshMetrics();
        } catch (error) {
          updatedElement.textContent = `Control update failed: ${error}`;
        } finally {
          batchBusy = false;
          buttons.forEach((btn) => {
            if (btn && previousTexts.has(btn)) {
              btn.textContent = previousTexts.get(btn);
            }
          });
          updateBatchButtons();
        }
      }

      function renderAgents(data) {
        try {
          let agentMap = data?.agents;
          if (!agentMap || typeof agentMap !== 'object') {
            agentMap = {};
          }

        // Fallback: if no agents payload, synthesize from other sections (PARA/GRVT) so Per-VPS pane
        // still shows the sources we have data for.
        if (Object.keys(agentMap).length === 0) {
          const synthetic = {};
          const paradexMap = data?.paradex_accounts;
          if (paradexMap && typeof paradexMap === 'object') {
            for (const [agentId, snapshot] of Object.entries(paradexMap)) {
              if (!synthetic[agentId]) {
                const summaryTs = Number(snapshot?.summary?.updated_at ?? snapshot?.updated_at ?? 0);
                synthetic[agentId] = {
                  position: 0,
                  total_cycles: 0,
                  cumulative_pnl: 0,
                  cumulative_volume: 0,
                  available_balance: snapshot?.summary?.balance,
                  total_account_value: snapshot?.summary?.equity ?? snapshot?.summary?.available_equity,
                  instrument: snapshot?.summary?.instrument ?? 'PARADEX',
                  last_update_ts: Number.isFinite(summaryTs) ? summaryTs : undefined,
                };
              }
            }
          }
          const grvtMap = data?.grvt_accounts;
          if (grvtMap && typeof grvtMap === 'object') {
            for (const [agentId, snapshot] of Object.entries(grvtMap)) {
              if (!synthetic[agentId]) {
                const summaryTs = Number(snapshot?.summary?.updated_at ?? snapshot?.updated_at ?? 0);
                synthetic[agentId] = {
                  position: 0,
                  total_cycles: 0,
                  cumulative_pnl: 0,
                  cumulative_volume: 0,
                  available_balance: snapshot?.summary?.total_equity ?? snapshot?.summary?.wallet_balance,
                  total_account_value: snapshot?.summary?.total_equity,
                  instrument: snapshot?.summary?.instrument ?? 'GRVT',
                  last_update_ts: Number.isFinite(summaryTs) ? summaryTs : undefined,
                };
              }
            }
          }
          const syntheticKeys = Object.keys(synthetic);
          if (syntheticKeys.length) {
            agentMap = synthetic;
          }
        }

          const entries = Object.entries(agentMap ?? {});
          const staleSet = new Set(data?.stale_agents ?? []);
          const lastAgentId = data?.last_agent_id ?? null;
          const controls = data?.controls ?? {};

          agentGrid.innerHTML = '';

          if (!entries.length) {
            agentGrid.classList.add('hidden');
            agentEmpty.classList.remove('hidden');
            const agentCountValue = toNumber(data?.agent_count);
            if (agentCountValue > 0) {
              agentEmpty.textContent = `有 ${agentCountValue} 台 VPS 在统计，但未收到明细；检查 /metrics 是否返回 agents 字段`;
            } else {
              agentEmpty.textContent = 'Waiting for VPS metrics…';
            }
            agentCount.textContent = `${agentCountValue || 0} active`;
            return;
          }

        agentGrid.classList.remove('hidden');
        agentEmpty.classList.add('hidden');

        entries.sort((a, b) => a[0].localeCompare(b[0], undefined, { sensitivity: 'base' }));

        let activeCount = 0;
        let pausedCount = 0;

  for (const [agentId, metrics] of entries) {
          const safeId = escapeHtml(agentId);
          const position = numberFormatter.format(toNumber(metrics.position));
          const pnl = numberFormatter.format(toNumber(metrics.cumulative_pnl));
          const volume = numberFormatter.format(toNumber(metrics.cumulative_volume));
          const available = numberFormatter.format(
            toNumber(
              metrics.available_balance ??
              metrics.available ??
              metrics.total_available_balance
            )
          );
          const accountValue = numberFormatter.format(
            toNumber(
              metrics.total_account_value ??
              metrics.account_value ??
              metrics.total_asset_value
            )
          );
          const instrumentText = metrics.instrument ? escapeHtml(metrics.instrument) : '—';
          const runtimeSeconds = toNumber(metrics.runtime_seconds);
          const runtimeDisplay = escapeHtml(formatDuration(runtimeSeconds));
          let depthDisplay = '—';
          if (metrics.depths && typeof metrics.depths === 'object') {
            const depthEntries = Object.entries(metrics.depths)
              .map(([key, value]) => {
                const depthValue = Number(value);
                if (!Number.isFinite(depthValue)) {
                  return null;
                }
                return `${escapeHtml(String(key))} ${depthValue}`;
              })
              .filter(Boolean);
            if (depthEntries.length) {
              depthDisplay = depthEntries.join(' · ');
            }
          }
          const cyclesRaw = Number(metrics.total_cycles ?? 0);
          const cycles = Number.isFinite(cyclesRaw) ? cyclesRaw : '--';

          const updatedTs = Number(metrics.last_update_ts ?? 0) * 1000;
          const updatedText = Number.isFinite(updatedTs) && updatedTs > 0
            ? new Date(updatedTs).toLocaleString()
            : 'Awaiting data…';

          const control = controls[agentId] ?? {};
          const isPaused = Boolean(control.paused);
          const controlTs = Number(control.updated_at ?? 0) * 1000;
          const pausedSinceText = isPaused && Number.isFinite(controlTs) && controlTs > 0
            ? new Date(controlTs).toLocaleString()
            : null;

          const card = document.createElement('article');
          card.className = 'agent-card card';

          const isStale = staleSet.has(agentId);
          if (isStale) {
            card.classList.add('stale');
          }
          if (isPaused) {
            card.classList.add('paused');
            pausedCount += 1;
          }
          if (!isStale && !isPaused) {
            activeCount += 1;
          }
          if (lastAgentId && agentId === lastAgentId) {
            card.classList.add('recent');
          }

          const statusParts = [];
          statusParts.push(isPaused ? 'Paused' : 'Active');
          if (isStale) {
            statusParts.push('Stale');
          }
          if (pausedSinceText) {
            statusParts.push(`since ${pausedSinceText}`);
          }
          const statusText = statusParts.join(' · ');

          card.innerHTML = `
            <header>
              <span class="agent-name">${safeId}</span>
              <span class="badge-group">
                ${lastAgentId && agentId === lastAgentId ? '<span class="badge badge-info">Latest</span>' : ''}
                ${isPaused ? '<span class="badge badge-muted">Paused</span>' : ''}
                ${isStale ? '<span class="badge badge-warn">Stale</span>' : ''}
              </span>
            </header>
            <dl class="agent-metrics">
              <div><dt>Position</dt><dd>${position}</dd></div>
              <div><dt>Total Cycles</dt><dd>${cycles}</dd></div>
              <div><dt>Runtime</dt><dd>${runtimeDisplay}</dd></div>
              <div><dt>Cumulative PnL</dt><dd>${pnl}</dd></div>
              <div><dt>Total Volume</dt><dd>${volume}</dd></div>
              <div><dt>Available</dt><dd>${available}</dd></div>
              <div><dt>Account Value</dt><dd>${accountValue}</dd></div>
              <div><dt>Instrument</dt><dd>${instrumentText}</dd></div>
              <div><dt>Depth</dt><dd>${escapeHtml(depthDisplay)}</dd></div>
            </dl>
            <p class="timestamp">${escapeHtml(statusText || 'Status unknown')}</p>
            <div class="control-actions">
              <button type="button" data-agent="${safeId}">${isPaused ? 'Resume' : 'Pause'}</button>
              <span class="updated-note">Updated ${escapeHtml(updatedText)}</span>
            </div>
          `;

          const controlButton = card.querySelector('button');
          if (controlButton) {
            controlButton.addEventListener('click', () => {
              const action = isPaused ? 'resume' : 'pause';
              sendControl(agentId, action, controlButton);
            });
          }

          agentGrid.appendChild(card);
        }

        const summaryParts = [];
        summaryParts.push(`${activeCount} active`);
        summaryParts.push(`${pausedCount} paused`);
        summaryParts.push(`${entries.length} total`);
        agentCount.textContent = summaryParts.join(' · ');

        const defaultPaused = Boolean(data?.default_paused);
        if (defaultPauseIndicator) {
          defaultPauseIndicator.classList.toggle('hidden', !defaultPaused);
        }

        lastDefaultPaused = defaultPaused;
        updateBatchButtons();
        } catch (err) {
          console.warn('renderAgents error', err);
          if (agentEmpty) {
            agentEmpty.classList.remove('hidden');
            agentEmpty.textContent = 'Per-VPS section failed to render; check console for details.';
          }
          if (agentGrid) {
            agentGrid.classList.add('hidden');
          }
        }
      }

      function describeStrategyAction(action) {
        if (!action) {
          return '—';
        }
        let text = String(action).trim();
        if (text.includes('.')) {
          text = text.split('.').pop() || text;
        }
        text = text.replace(/_/g, ' ');
        return text.charAt(0).toUpperCase() + text.slice(1);
      }

      function describeStrategyDirection(direction) {
        if (!direction) {
          return '—';
        }
        let text = String(direction).trim();
        if (text.includes('.')) {
          text = text.split('.').pop() || text;
        }
        return text.replace(/_/g, ' ').toUpperCase();
      }

      function renderStrategy(data) {
        if (!strategyAgentCount || !strategyCard) {
          return;
        }

        const strategyMap = data?.strategy_metrics ?? {};
        const entries = Object.entries(strategyMap);
        const label = entries.length === 1 ? 'strategy' : 'strategies';
        strategyAgentCount.textContent = `${entries.length} ${label}`;

        if (!entries.length) {
          strategyCard.classList.add('hidden');
          strategyEmpty.classList.remove('hidden');
          strategyEmpty.textContent = 'Waiting for strategy metrics…';
          if (strategyAgentLabel) {
            strategyAgentLabel.classList.add('hidden');
          }
          if (strategyAgentSelect) {
            strategyAgentSelect.innerHTML = '';
          }
          selectedStrategyAgent = null;
          lastStrategyOptionsKey = '';
          return;
        }

        strategyEmpty.classList.add('hidden');
        strategyCard.classList.remove('hidden');

        if (!selectedStrategyAgent || !strategyMap[selectedStrategyAgent]) {
          selectedStrategyAgent = entries[0][0];
        }

        if (strategyAgentSelect) {
          const optionsKey = entries.map(([agent]) => agent).join('|');
          if (optionsKey !== lastStrategyOptionsKey) {
            strategyAgentSelect.innerHTML = '';
            for (const [agent] of entries) {
              const option = document.createElement('option');
              option.value = agent;
              option.textContent = agent;
              strategyAgentSelect.appendChild(option);
            }
            lastStrategyOptionsKey = optionsKey;
          }
          strategyAgentSelect.value = selectedStrategyAgent;
          if (strategyAgentLabel) {
            strategyAgentLabel.classList.toggle('hidden', entries.length <= 1);
          }
        }

        const metrics = strategyMap[selectedStrategyAgent] ?? {};
        const summary = metrics.summary ?? {};
        const totalPnl = parseDecimal(summary.total_pnl ?? metrics.total_pnl);
        strategyNetPnl.textContent = Number.isFinite(totalPnl)
          ? numberFormatter.format(totalPnl)
          : '--';

        const tradeCountRaw = Number(summary.trade_count ?? metrics.trade_count ?? 0);
        strategyTradeCount.textContent = `Trades ${Number.isFinite(tradeCountRaw) ? tradeCountRaw : '--'}`;

        if (strategyTotalVolume) {
          const totalVolume = parseDecimal(summary.total_volume ?? metrics.total_volume);
          strategyTotalVolume.textContent = Number.isFinite(totalVolume)
            ? numberFormatter.format(totalVolume)
            : '--';
        }

        if (strategyPnlRatio) {
          const ratioRaw = parseDecimal(summary.pnl_over_volume ?? metrics.pnl_over_volume);
          if (Number.isFinite(ratioRaw)) {
            strategyPnlRatio.textContent = `${(ratioRaw * 100).toFixed(2)}%`;
          } else {
            strategyPnlRatio.textContent = '--';
          }
        }

        const openPosition = metrics.open_position;
        if (openPosition && openPosition.direction) {
          const qtyValue = parseDecimal(openPosition.quantity);
          const positionParts = [describeStrategyDirection(openPosition.direction)];
          if (Number.isFinite(qtyValue)) {
            positionParts.push(qtyValue.toFixed(4));
          }
          strategyOpenPosition.textContent = positionParts.join(' ');

          const detailsParts = [];
          const entryTs = Number(openPosition.entry_timestamp);
          if (Number.isFinite(entryTs) && entryTs > 0) {
            detailsParts.push(new Date(entryTs * 1000).toLocaleString());
          }
          const entrySpread = parseDecimal(openPosition.entry_spread);
          if (Number.isFinite(entrySpread)) {
            detailsParts.push(`Spread ${entrySpread.toFixed(6)}`);
          }
          const ticksHeld = Number(openPosition.ticks_held);
          if (Number.isFinite(ticksHeld) && ticksHeld > 0) {
            detailsParts.push(`${ticksHeld} ticks elapsed`);
          }
          strategyOpenDetails.textContent = detailsParts.length ? detailsParts.join(' · ') : '—';
        } else {
          strategyOpenPosition.textContent = 'None';
          strategyOpenDetails.textContent = '—';
        }

        const eventsRaw = Array.isArray(metrics.recent_events) ? metrics.recent_events.slice(-MAX_STRATEGY_EVENTS) : [];
        const lastEvent = eventsRaw.length ? eventsRaw[eventsRaw.length - 1] : null;
        if (lastEvent) {
          const actionText = describeStrategyAction(lastEvent.action);
          const directionText = describeStrategyDirection(lastEvent.direction);
          const forced = Boolean(lastEvent.forced);
          const decisionParts = [actionText];
          if (directionText !== '—') {
            decisionParts.push(directionText);
          }
          if (forced) {
            decisionParts.push('(forced)');
          }
          strategyLastDecision.textContent = decisionParts.join(' ');

          const ts = Number(lastEvent.timestamp);
          if (Number.isFinite(ts) && ts > 0) {
            strategyLastDecisionTime.textContent = new Date(ts * 1000).toLocaleString();
          } else {
            strategyLastDecisionTime.textContent = '—';
          }
        } else {
          strategyLastDecision.textContent = '—';
          strategyLastDecisionTime.textContent = '—';
        }

        if (!strategyEventsBody) {
          return;
        }

        strategyEventsBody.innerHTML = '';
        if (!eventsRaw.length) {
          const emptyRow = document.createElement('tr');
          emptyRow.innerHTML = '<td colspan="8">Awaiting decision events…</td>';
          strategyEventsBody.appendChild(emptyRow);
          return;
        }

        for (let index = eventsRaw.length - 1; index >= 0; index -= 1) {
          const event = eventsRaw[index];
          const ts = Number(event.timestamp);
          const timeText = Number.isFinite(ts) && ts > 0
            ? new Date(ts * 1000).toLocaleTimeString()
            : '—';
          const actionText = describeStrategyAction(event.action);
          const directionText = describeStrategyDirection(event.direction);
          const spreadText = formatDecimal(event.spread, 6);
          const zScoreText = formatDecimal(event.z_score, 4);
          const quantityText = formatDecimal(event.quantity, 4);
          const pnlText = formatDecimal(event.pnl, 6);
          const reasonText = event.reason ? escapeHtml(event.reason) : (event.forced ? 'Forced exit' : '—');

          let actionClass = 'action-other';
          if (event.forced) {
            actionClass = 'action-forced';
          } else if (String(event.action).toLowerCase() === 'enter') {
            actionClass = 'action-enter';
          } else if (String(event.action).toLowerCase() === 'exit') {
            actionClass = 'action-exit';
          }

          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${escapeHtml(timeText)}</td>
            <td class="${actionClass}">${escapeHtml(actionText)}</td>
            <td>${escapeHtml(directionText)}</td>
            <td>${escapeHtml(spreadText)}</td>
            <td>${escapeHtml(zScoreText)}</td>
            <td>${escapeHtml(quantityText)}</td>
            <td>${escapeHtml(pnlText)}</td>
            <td>${reasonText}</td>
          `;
          strategyEventsBody.appendChild(row);
        }
      }

      function renderSpread(data) {

            if (Number.isFinite(limit) && positions.length > trimmed.length) {
              const hint = document.createElement('p');
              hint.className = 'summary-sub';
              hint.style.marginTop = '0.6rem';
              hint.textContent = `仅展示前 ${trimmed.length} 条持仓（共 ${positions.length} 条）。`;
              card.appendChild(hint);
            }
        if (!spreadAgentCount || !spreadEmpty || !spreadCard) {
          return;
        }

        const spreads = data?.spread_metrics ?? {};
        const entries = Object.entries(spreads);
        const monitorLabel = entries.length === 1 ? 'monitor' : 'monitors';
        spreadAgentCount.textContent = `${entries.length} ${monitorLabel}`;

        if (!entries.length) {
          spreadCard.classList.add('hidden');
          spreadEmpty.classList.remove('hidden');
          spreadEmpty.textContent = 'Waiting for spread data…';
          if (spreadAgentLabel) {
            spreadAgentLabel.classList.add('hidden');
          }
          if (spreadTableBody) {
            spreadTableBody.innerHTML = '';
          }
          return;
        }

        spreadEmpty.classList.add('hidden');
        spreadCard.classList.remove('hidden');

        if (!selectedSpreadAgent || !spreads[selectedSpreadAgent]) {
          selectedSpreadAgent = entries[0][0];
        }

        if (spreadAgentSelect) {
          const optionsKey = entries.map(([agent]) => agent).join('|');
          if (optionsKey !== lastSpreadOptionsKey) {
            spreadAgentSelect.innerHTML = '';
            for (const [agent] of entries) {
              const option = document.createElement('option');
              option.value = agent;
              option.textContent = agent;
              spreadAgentSelect.appendChild(option);
            }
            lastSpreadOptionsKey = optionsKey;
          }
          spreadAgentSelect.value = selectedSpreadAgent;
          if (spreadAgentLabel) {
            spreadAgentLabel.classList.toggle('hidden', entries.length <= 1);
          }
        }

  const metrics = spreads[selectedSpreadAgent] ?? {};
  const historyRaw = Array.isArray(metrics.history) ? metrics.history : [];
  const history = historyRaw.slice(-MAX_SPREAD_HISTORY_POINTS);

        if (spreadInstrument) {
          const ticker = metrics?.aster?.ticker ?? '';
          const symbol = metrics?.lighter?.symbol ?? '';
          const instrumentText = metrics.instrument || `${ticker}${ticker && symbol ? ' / ' : ''}${symbol}`;
          spreadInstrument.textContent = instrumentText ? `Instrument ${escapeHtml(instrumentText)}` : 'Instrument —';
        }

        if (spreadUpdated) {
          const tsSource = Number(metrics.updated_at ?? (historyRaw.length ? historyRaw[historyRaw.length - 1]?.timestamp : Date.now() / 1000));
          if (Number.isFinite(tsSource)) {
            spreadUpdated.textContent = `Updated ${new Date(tsSource * 1000).toLocaleString()}`;
          } else {
            spreadUpdated.textContent = 'Updated —';
          }
        }

        if (!spreadTableBody) {
          return;
        }

        spreadTableBody.innerHTML = '';
        if (!history.length) {
          const emptyRow = document.createElement('tr');
          emptyRow.innerHTML = '<td colspan="8">Awaiting history…</td>';
          spreadTableBody.appendChild(emptyRow);
          if (spreadChartWrapper) {
            spreadChartWrapper.classList.add('hidden');
          }
          return;
        }

        const chartLabels = [];
        const chartSellAster = [];
        const chartSellLighter = [];
        const tableRows = [];

        for (const row of history) {
          const timestamp = Number(row.timestamp);
          const timeLabel = row.iso_time
            ? new Date(row.iso_time).toLocaleTimeString()
            : (Number.isFinite(timestamp) ? new Date(timestamp * 1000).toLocaleTimeString() : '--');

          const asterBid = parseDecimal(row.aster_bid);
          const asterAsk = parseDecimal(row.aster_ask);
          const lighterBid = parseDecimal(row.lighter_bid);
          const lighterAsk = parseDecimal(row.lighter_ask);
          const spreadSellAsterRaw = Number.isFinite(asterBid) && Number.isFinite(lighterAsk)
            ? asterBid - lighterAsk
            : parseDecimal(row.spread_aster_bid_minus_lighter_ask);
          const spreadSellLighterRaw = Number.isFinite(lighterBid) && Number.isFinite(asterAsk)
            ? lighterBid - asterAsk
            : parseDecimal(row.spread_lighter_bid_minus_aster_ask);

          const basisAsterDenom = Number.isFinite(lighterAsk) ? Math.abs(lighterAsk) : Number.isFinite(asterBid) ? Math.abs(asterBid) : null;
          const basisLighterDenom = Number.isFinite(asterAsk) ? Math.abs(asterAsk) : Number.isFinite(lighterBid) ? Math.abs(lighterBid) : null;

          chartLabels.push(timeLabel);
          chartSellAster.push(computePercent(spreadSellAsterRaw ?? NaN, basisAsterDenom ?? NaN));
          chartSellLighter.push(computePercent(spreadSellLighterRaw ?? NaN, basisLighterDenom ?? NaN));

          tableRows.push([
            escapeHtml(timeLabel),
            escapeHtml(formatDecimal(row.aster_bid, 4)),
            escapeHtml(formatDecimal(row.aster_ask, 4)),
            escapeHtml(formatDecimal(row.lighter_bid, 4)),
            escapeHtml(formatDecimal(row.lighter_ask, 4)),
            escapeHtml(formatDecimal(row.spread_aster_bid_minus_lighter_ask, 6)),
            escapeHtml(formatDecimal(row.spread_lighter_bid_minus_aster_ask, 6)),
            escapeHtml(formatDecimal(row.mid_price_diff, 6))
          ]);
        }

        for (let index = tableRows.length - 1; index >= 0; index -= 1) {
          const tr = document.createElement('tr');
          tr.innerHTML = tableRows[index].map((value) => `<td>${value}</td>`).join('');
          spreadTableBody.appendChild(tr);
        }

        const hasChartPoints = chartSellAster.some((value) => Number.isFinite(value)) ||
          chartSellLighter.some((value) => Number.isFinite(value));

        if (spreadChartWrapper) {
          if (hasChartPoints) {
            spreadChartWrapper.classList.remove('hidden');
            renderSpreadCanvas(chartLabels, chartSellAster, chartSellLighter);
          } else {
            spreadChartWrapper.classList.add('hidden');
          }
        }
      }

      function renderVolatility(data) {
        if (!volCard || !volEmpty) {
          return;
        }
        const block = data?.volatility;
        if (!block || !block.symbols || !Object.keys(block.symbols).length) {
          volCard.classList.add('hidden');
          volEmpty.classList.remove('hidden');
          if (volUpdated) {
            volUpdated.textContent = '等待行情…';
          }
          if (volSourceBadge) {
            volSourceBadge.classList.add('hidden');
          }
          if (volErrorBadge) {
            volErrorBadge.classList.add('hidden');
            volErrorBadge.textContent = '';
          }
          return;
        }

        volEmpty.classList.add('hidden');
        volCard.classList.remove('hidden');
        const updatedTs = parseDecimal(block.updated_at);
        if (volUpdated) {
          if (Number.isFinite(updatedTs) && updatedTs > 0) {
            volUpdated.textContent = `Updated ${new Date(updatedTs * 1000).toLocaleString()}`;
          } else {
            volUpdated.textContent = 'Updated —';
          }
        }
        if (volSourceBadge) {
          const sourceText = (block.source || 'market').toUpperCase();
          volSourceBadge.textContent = sourceText;
          volSourceBadge.classList.remove('hidden');
        }
        if (volErrorBadge) {
          if (block.last_error) {
            volErrorBadge.textContent = block.last_error;
            volErrorBadge.classList.remove('hidden');
          } else {
            volErrorBadge.textContent = '';
            volErrorBadge.classList.add('hidden');
          }
        }

        const timeframeOrder = Array.isArray(block.timeframes) && block.timeframes.length
          ? block.timeframes
          : Object.keys(Object.values(block.symbols)[0]?.timeframes || {});
        buildVolSymbolCards(block.symbols, timeframeOrder);
        buildVolHedgeTable(block.hedge_guidance, timeframeOrder);
      }

      function buildVolSymbolCards(symbols, timeframeOrder) {
        if (!volSymbolGrid) {
          return;
        }
        volSymbolGrid.innerHTML = '';
        const entries = Object.values(symbols || {});
        if (!entries.length) {
          volSymbolGrid.innerHTML = '<p class="empty">等待行情…</p>';
          return;
        }
        const order = Array.isArray(timeframeOrder) && timeframeOrder.length
          ? timeframeOrder
          : Object.keys(entries[0]?.timeframes || {});
        entries.sort((a, b) => {
          const labelA = (a.label || a.symbol || '').toString();
          const labelB = (b.label || b.symbol || '').toString();
          return labelA.localeCompare(labelB);
        });
        for (const entry of entries) {
          const card = document.createElement('article');
          card.className = 'vol-symbol-card';
          const priceText = formatDecimal(entry.last_price, 2);
          const updatedEpoch = parseDecimal(entry.last_updated);
          const updatedText = Number.isFinite(updatedEpoch)
            ? new Date(updatedEpoch * 1000).toLocaleTimeString()
            : '—';
          card.innerHTML = `
            <div class="vol-symbol-header">
              <div>
                <p class="vol-symbol-label">${escapeHtml(entry.label || entry.symbol || '—')}</p>
                <p class="vol-price">${escapeHtml(priceText)}</p>
              </div>
              <p class="vol-updated-note">${escapeHtml(updatedText)}</p>
            </div>
            ${buildVolTable(entry.timeframes || {}, order)}
          `;
          volSymbolGrid.appendChild(card);
        }
      }

      function buildVolTable(timeframes, order) {
        const timeline = Array.isArray(order) && order.length ? order : Object.keys(timeframes || {});
        if (!timeline.length) {
          return '<p class="empty">等待窗口数据…</p>';
        }
        const metrics = [
          { key: 'return_pct', label: 'Δ Price', format: (value) => formatSignedPercent(value, 2), className: percentClass },
          { key: 'realized_vol_pct', label: 'Realized Vol', format: (value) => formatPercent(value, 1) },
          { key: 'atr_pct', label: 'ATR %', format: (value) => formatPercent(value, 2) },
          { key: 'atr_abs', label: 'ATR (abs)', format: (value) => formatDecimal(value, 2) },
          { key: 'amplitude_pct', label: 'Range %', format: (value) => formatPercent(value, 2) },
        ];
        let header = '<table class="vol-metric-table"><thead><tr><th>Metric</th>';
        for (const label of timeline) {
          header += `<th>${escapeHtml(label)}</th>`;
        }
        header += '</tr></thead><tbody>';
        let body = '';
        for (const metric of metrics) {
          body += `<tr><td>${metric.label}</td>`;
          for (const label of timeline) {
            const bucket = timeframes?.[label];
            const rawValue = extractNumeric(bucket, metric.key);
            const display = metric.format(rawValue);
            const cellClass = metric.className ? metric.className(rawValue) : '';
            const classAttr = cellClass ? ` class="${cellClass}"` : '';
            body += `<td${classAttr}>${escapeHtml(display)}</td>`;
          }
          body += '</tr>';
        }
        body += '</tbody></table>';
        return header + body;
      }

      function buildVolHedgeTable(guidance, timeframeOrder) {
        if (!volHedgeBody || !volHedgePair) {
          return;
        }
        if (!guidance || !guidance.timeframes) {
          volHedgePair.textContent = '等待对冲统计…';
          volHedgeBody.innerHTML = '<tr><td colspan="5">等待对冲统计…</td></tr>';
          return;
        }
        const label = guidance.pair || `${guidance.quote_symbol || ''}/${guidance.base_symbol || ''}`;
        volHedgePair.textContent = label ? `Pair ${label}` : 'Pair —';
        const entries = guidance.timeframes || {};
        const order = Array.isArray(timeframeOrder) && timeframeOrder.length
          ? timeframeOrder.filter((item) => entries[item])
          : Object.keys(entries);
        if (!order.length) {
          volHedgeBody.innerHTML = '<tr><td colspan="5">等待对冲统计…</td></tr>';
          return;
        }
        volHedgeBody.innerHTML = '';
        for (const windowLabel of order) {
          const stats = entries[windowLabel];
          if (!stats) {
            continue;
          }
          const corrText = Number.isFinite(stats.corr) ? formatPercent(stats.corr * 100, 1) : '—';
          const volRatioText = formatMultiplier(stats.vol_ratio, 2);
          const betaText = formatMultiplier(stats.beta, 2);
          const spreadValue = extractNumeric(stats, 'return_spread_pct');
          const spreadText = formatSignedPercent(spreadValue, 2);
          const spreadClass = percentClass(spreadValue);
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${escapeHtml(windowLabel)}</td>
            <td>${escapeHtml(corrText)}</td>
            <td>${escapeHtml(volRatioText)}</td>
            <td>${escapeHtml(betaText)}</td>
            <td class="${spreadClass}">${escapeHtml(spreadText)}</td>
          `;
          volHedgeBody.appendChild(row);
        }
        if (!volHedgeBody.children.length) {
          volHedgeBody.innerHTML = '<tr><td colspan="5">等待对冲统计…</td></tr>';
        }
      }

      async function refreshMetrics() {
        try {
          const response = await fetch('/metrics', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();
          lastMetricsSnapshot = data;
          renderAggregate(data);
          renderVolatility(data);
          renderPriceChart(data);
          renderParaPriceChart(data);
          renderTransferChart(data);
          renderAgents(data);
          renderPara(data);
          renderGrvt(data);
          renderParaAdjustments(data?.para_adjustments);
          renderGrvtAdjustments(data?.grvt_adjustments);
          renderAutoBalance(data?.auto_balance, data?.agents);
          renderParaAutoBalance(data?.para_auto_balance, data?.paradex_accounts || data?.agents);
          renderSpread(data);
          renderStrategy(data);
          maybeRefreshRiskHistory();
        } catch (error) {
          updatedElement.textContent = `Dashboard error: ${error}`;
          agentCount.textContent = '—';
          agentGrid.innerHTML = '';
          agentGrid.classList.add('hidden');
          agentEmpty.classList.remove('hidden');
          agentEmpty.textContent = 'Unable to load metrics at the moment.';
          if (spreadAgentCount) {
            spreadAgentCount.textContent = '0 monitors';
          }
          if (spreadCard) {
            spreadCard.classList.add('hidden');
          }
          if (spreadEmpty) {
            spreadEmpty.classList.remove('hidden');
            spreadEmpty.textContent = 'Unable to load spread data at the moment.';
          }
          if (strategyAgentCount) {
            strategyAgentCount.textContent = '0 strategies';
          }
          if (strategyCard) {
            strategyCard.classList.add('hidden');
          }
          if (strategyEmpty) {
            strategyEmpty.classList.remove('hidden');
            strategyEmpty.textContent = 'Unable to load strategy data at the moment.';
          }
          if (volCard) {
            volCard.classList.add('hidden');
          }
          if (volEmpty) {
            volEmpty.classList.remove('hidden');
            volEmpty.textContent = 'Unable to load volatility feed at the moment.';
          }
          if (volSourceBadge) {
            volSourceBadge.classList.add('hidden');
          }
          if (volErrorBadge) {
            volErrorBadge.classList.add('hidden');
            volErrorBadge.textContent = '';
          }
        }
      }

      if (simStartInput) {
        simStartInput.addEventListener('input', () => updateSimulationFromInputs());
      }
      [simBtcInput, simEthInput].forEach((input) => {
        if (!input) {
          return;
        }
        input.addEventListener('input', () => updateSimulationFromInputs());
      });
      if (simRefreshButton) {
        simRefreshButton.addEventListener('click', () => loadSimulationData({ silent: false }));
      }
      if (simOptimizeButton) {
        simOptimizeButton.addEventListener('click', handleSimOptimizeRequest);
      }
      if (pauseAllButton) {
        pauseAllButton.addEventListener('click', () => sendBatchControl('pause', pauseAllButton));
      }
      if (resumeAllButton) {
        resumeAllButton.addEventListener('click', () => sendBatchControl('resume', resumeAllButton));
      }
      if (spreadAgentSelect) {
        spreadAgentSelect.addEventListener('change', (event) => {
          selectedSpreadAgent = event.target.value;
          if (lastMetricsSnapshot) {
            renderSpread(lastMetricsSnapshot);
          }
        });
      }
      if (strategyAgentSelect) {
        strategyAgentSelect.addEventListener('change', (event) => {
          selectedStrategyAgent = event.target.value;
          if (lastMetricsSnapshot) {
            renderStrategy(lastMetricsSnapshot);
          }
        });
      }
      if (grvtAdjustAddButton) {
        grvtAdjustAddButton.addEventListener('click', () => sendGrvtAdjustment('add'));
      }
      if (grvtAdjustReduceButton) {
        grvtAdjustReduceButton.addEventListener('click', () => sendGrvtAdjustment('reduce'));
      }
      if (paraOrderModeSelect) {
        paraOrderModeSelect.addEventListener('change', updateTwapVisibility);
        updateTwapVisibility();
      }
      if (paraAdjustAddButton) {
        paraAdjustAddButton.addEventListener('click', () => sendParaAdjustment('add'));
      }
      if (paraAdjustReduceButton) {
        paraAdjustReduceButton.addEventListener('click', () => sendParaAdjustment('reduce'));
      }
      if (grvtResetSymbolButton) {
        grvtResetSymbolButton.addEventListener('click', () => {
          clearGrvtSymbolSelection();
        });
      }
      if (paraResetSymbolButton) {
        paraResetSymbolButton.addEventListener('click', () => {
          clearParaSymbolSelection();
        });
      }
      const selectAlternativeTarget = () => {
        if (!grvtTransferTargetSelect || !grvtTransferSourceSelect) {
          return;
        }
        if ((grvtTransferTargetSelect.options.length || 0) <= 1) {
          return;
        }
        if (grvtTransferTargetSelect.value !== grvtTransferSourceSelect.value) {
          return;
        }
        const options = Array.from(grvtTransferTargetSelect.options || []);
        const candidate = options.find((option) => option.value && option.value !== grvtTransferSourceSelect.value);
        if (candidate) {
          grvtTransferTargetSelect.value = candidate.value;
          applyGrvtTransferDefaults('target', { forceAll: true });
        }
      };
      const selectAlternativeParaTarget = () => {
        if (!paraTransferTargetSelect || !paraTransferSourceSelect) {
          return;
        }
        if ((paraTransferTargetSelect.options.length || 0) <= 1) {
          return;
        }
        if (paraTransferTargetSelect.value !== paraTransferSourceSelect.value) {
          return;
        }
        const options = Array.from(paraTransferTargetSelect.options || []);
        const candidate = options.find((option) => option.value && option.value !== paraTransferSourceSelect.value);
        if (candidate) {
          paraTransferTargetSelect.value = candidate.value;
          applyParaTransferDefaults('target', { forceAll: true });
        }
      };
      if (grvtTransferSourceSelect) {
        grvtTransferSourceSelect.addEventListener('change', () => {
          applyGrvtTransferDefaults('source', { forceAll: true });
          selectAlternativeTarget();
          updateGrvtTransferButtons();
          syncGrvtTransferSelectionStatus();
        });
      }
      if (grvtTransferTargetSelect) {
        grvtTransferTargetSelect.addEventListener('change', () => {
          applyGrvtTransferDefaults('target', { forceAll: true });
          updateGrvtTransferButtons();
          syncGrvtTransferSelectionStatus();
        });
      }
      if (paraTransferSourceSelect) {
        paraTransferSourceSelect.addEventListener('change', () => {
          applyParaTransferDefaults('source', { forceAll: true });
          selectAlternativeParaTarget();
          updateParaTransferButtons();
          syncParaTransferSelectionStatus();
        });
      }
      if (paraTransferTargetSelect) {
        paraTransferTargetSelect.addEventListener('change', () => {
          applyParaTransferDefaults('target', { forceAll: true });
          updateParaTransferButtons();
          syncParaTransferSelectionStatus();
        });
      }
      if (paraTransferSubmitButton) {
        paraTransferSubmitButton.addEventListener('click', () => {
          sendParaTransfer();
        });
      }
      if (grvtAutoSaveButton) {
        grvtAutoSaveButton.addEventListener('click', () => {
          submitAutoBalanceConfig();
        });
      }
      if (grvtAutoDisableButton) {
        grvtAutoDisableButton.addEventListener('click', () => {
          disableAutoBalance();
        });
      }
      if (grvtAutoRefreshButton) {
        grvtAutoRefreshButton.addEventListener('click', () => {
          loadAutoBalanceConfig({ silent: false });
        });
      }
      if (paraAutoSaveButton) {
        paraAutoSaveButton.addEventListener('click', () => {
          submitParaAutoBalanceConfig();
        });
      }
      if (paraAutoDisableButton) {
        paraAutoDisableButton.addEventListener('click', () => {
          disableParaAutoBalance();
        });
      }
      if (paraAutoRefreshButton) {
        paraAutoRefreshButton.addEventListener('click', () => {
          loadParaAutoBalanceConfig({ silent: false });
        });
      }
      const autoBalanceInputs = [
        grvtAutoEnabledInput,
        grvtAutoAgentASelect,
        grvtAutoAgentBSelect,
        grvtAutoThresholdInput,
        grvtAutoMinTransferInput,
        grvtAutoMaxTransferInput,
        grvtAutoCurrencyInput,
        grvtAutoCooldownInput,
        grvtAutoUseAvailableInput,
      ];
      autoBalanceInputs.forEach((input) => {
        if (!input) {
          return;
        }
        input.addEventListener('input', markAutoBalanceDirty);
        input.addEventListener('change', markAutoBalanceDirty);
      });
      const paraAutoBalanceInputs = [
        paraAutoEnabledInput,
        paraAutoAgentASelect,
        paraAutoAgentBSelect,
        paraAutoThresholdInput,
        paraAutoMinTransferInput,
        paraAutoMaxTransferInput,
        paraAutoCurrencyInput,
        paraAutoCooldownInput,
        paraAutoUseAvailableInput,
      ];
      paraAutoBalanceInputs.forEach((input) => {
        if (!input) {
          return;
        }
        input.addEventListener('input', markParaAutoBalanceDirty);
        input.addEventListener('change', markParaAutoBalanceDirty);
      });
      if (riskSaveButton) {
        riskSaveButton.addEventListener('click', () => {
          saveRiskSettings();
        });
      }
      if (paraRiskSaveButton) {
        paraRiskSaveButton.addEventListener('click', () => {
          saveParaRiskSettings();
        });
      }
      if (riskDisableButton) {
        riskDisableButton.addEventListener('click', () => {
          disableRiskAlerts();
        });
      }
      if (paraRiskDisableButton) {
        paraRiskDisableButton.addEventListener('click', () => {
          disableParaRiskAlerts();
        });
      }
      if (riskTestButton) {
        riskTestButton.addEventListener('click', () => {
          triggerRiskTest();
        });
      }
      if (paraRiskTestButton) {
        paraRiskTestButton.addEventListener('click', () => {
          triggerParaRiskTest();
        });
      }
      if (riskRefreshButton) {
        riskRefreshButton.addEventListener('click', () => {
          loadRiskSettings({ silent: false });
        });
      }
      if (paraRiskRefreshButton) {
        paraRiskRefreshButton.addEventListener('click', () => {
          loadParaRiskSettings({ silent: false });
        });
      }
      if (riskHistoryRefreshButton) {
        riskHistoryRefreshButton.addEventListener('click', () => {
          loadRiskHistory({ silent: false });
        });
      }

      if (paraRiskHistoryRefreshButton) {
        paraRiskHistoryRefreshButton.addEventListener('click', () => {
          loadRiskHistory({ silent: false });
        });
      }
      if (riskAlertEnabledInput) {
        riskAlertEnabledInput.addEventListener('change', () => {
          updateRiskInputsState();
          markRiskSettingsDirty();
        });
      }
      if (paraRiskAlertEnabledInput) {
        paraRiskAlertEnabledInput.addEventListener('change', () => {
          updateRiskInputsState();
          markRiskSettingsDirty();
        });
      }
      if (riskThresholdSlider) {
        riskThresholdSlider.addEventListener('input', (event) => {
          const value = clamp(Number(event.target.value), 5, 90);
          if (riskThresholdInput) {
            riskThresholdInput.value = value.toFixed(1);
          }
          updateRiskThresholdLabel(value);
          markRiskSettingsDirty();
        });
      }
      if (paraRiskThresholdSlider) {
        paraRiskThresholdSlider.addEventListener('input', (event) => {
          const value = clamp(Number(event.target.value), 5, 90);
          if (paraRiskThresholdInput) {
            paraRiskThresholdInput.value = value.toFixed(1);
          }
          updateRiskThresholdLabel(value);
          markRiskSettingsDirty();
        });
      }
      if (riskThresholdInput) {
        riskThresholdInput.addEventListener('input', () => {
          const value = clamp(Number(riskThresholdInput.value), 1, 90);
          if (Number.isFinite(value) && riskThresholdSlider) {
            riskThresholdSlider.value = value;
          }
          updateRiskThresholdLabel(value);
          markRiskSettingsDirty();
        });
      }
      if (paraRiskThresholdInput) {
        paraRiskThresholdInput.addEventListener('input', () => {
          const value = clamp(Number(paraRiskThresholdInput.value), 1, 90);
          if (Number.isFinite(value) && paraRiskThresholdSlider) {
            paraRiskThresholdSlider.value = value;
          }
          updateRiskThresholdLabel(value);
          markRiskSettingsDirty();
        });
      }
      [
        riskResetInput,
        riskCooldownInput,
        riskBarkUrlInput,
        riskBarkTimeoutInput,
        riskTitleTemplateInput,
        riskBodyTemplateInput,
      ].forEach((input) => {
        if (!input) {
          return;
        }
        input.addEventListener('input', markRiskSettingsDirty);
      });
      if (riskBarkAppendInput) {
        riskBarkAppendInput.addEventListener('change', markRiskSettingsDirty);
      }
      [
        paraRiskResetInput,
        paraRiskCooldownInput,
        paraRiskBarkUrlInput,
        paraRiskBarkTimeoutInput,
        paraRiskTitleTemplateInput,
        paraRiskBodyTemplateInput,
      ].forEach((input) => {
        if (!input) {
          return;
        }
        input.addEventListener('input', markRiskSettingsDirty);
      });
    updateGrvtSymbolOptions([]);
    updateParaSymbolOptions([]);
    updateGrvtTransferButtons();
    updateParaTransferButtons();
    updateAutoBalanceButtons();
    updateParaAutoBalanceButtons();
    updateRiskButtons();
    loadRiskHistory({ silent: true });
    loadAutoBalanceConfig({ silent: true });
    loadParaAutoBalanceConfig({ silent: true });
    loadRiskSettings({ silent: true });
    loadSimulationData({ silent: false });
    refreshMetrics();
    setInterval(refreshMetrics, 2000);
    setInterval(() => loadSimulationData({ silent: true }), 300000);
    </script>
  </body>
</html>
