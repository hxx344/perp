<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hedge Metrics Dashboard</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
        background: #111;
        color: #f2f4f8;
      }

      body {
        margin: 0;
        padding: 2rem;
        max-width: 960px;
        margin-inline: auto;
      }

      h1 {
        font-size: 1.75rem;
        margin-bottom: 0.5rem;
      }

      .subtitle {
        color: #8a94a6;
        margin-bottom: 2rem;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.25rem;
      }

      .card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .spread-section {
        margin-top: 2.5rem;
      }

      .spread-card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .spread-chart-wrapper {
        height: 280px;
        margin-bottom: 1.5rem;
      }

      .spread-chart-wrapper canvas {
        width: 100%;
        height: 100%;
      }

      .spread-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin-bottom: 1rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .spread-table-wrapper {
        overflow-x: auto;
      }

      table.spread-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
      }

      table.spread-table thead {
        background: #222635;
      }

      table.spread-table th,
      table.spread-table td {
        padding: 0.65rem 0.75rem;
        text-align: right;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        white-space: nowrap;
      }

      table.spread-table th:first-child,
      table.spread-table td:first-child {
        text-align: left;
      }

      .spread-selector-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .spread-selector-label select {
        background: #1f2533;
        color: #f5f7fb;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 6px;
        padding: 0.35rem 0.65rem;
        font-size: 0.85rem;
      }

      .card h2 {
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        margin: 0 0 0.75rem;
        color: #7f8fa9;
      }

      .value {
        font-size: 2rem;
        font-weight: 600;
      }

      .updated {
        margin-top: 2rem;
        color: #7f8fa9;
        font-size: 0.85rem;
      }

      .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem 1.25rem;
        margin-top: 2.5rem;
        margin-bottom: 1rem;
      }

      .section-header-info {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .section-header h2 {
        margin: 0;
        font-size: 1.25rem;
      }

      .section-header-controls {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        padding: 0.15rem 0.6rem;
        border-radius: 999px;
        font-size: 0.72rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        background: #273042;
        color: #c7d2e8;
      }

      .badge-group {
        display: inline-flex;
        gap: 0.35rem;
        align-items: center;
      }

      .badge-muted {
        background: #1f2533;
        color: #8a94a6;
      }

      .badge-warn {
        background: #4a1f1f;
        color: #ffc9c9;
      }

      .badge-info {
        background: #19314d;
        color: #a4d5ff;
      }

      .agent-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1.25rem;
      }

      .agent-card {
        transition: box-shadow 0.25s ease, transform 0.25s ease;
        border: 1px solid transparent;
      }

      .agent-card.recent {
        box-shadow: 0 0 0 2px rgba(76, 201, 240, 0.25);
      }

      .agent-card.stale {
        border-color: rgba(255, 171, 64, 0.45);
        opacity: 0.7;
      }

      .agent-card.paused {
        border-color: rgba(125, 140, 170, 0.35);
        background: #202431;
      }

      .agent-card header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.1rem;
      }

      .agent-name {
        font-weight: 600;
        font-size: 1.05rem;
        color: #f5f7fb;
      }

      .agent-metrics {
        display: grid;
        gap: 0.6rem;
        margin: 0;
      }

      .agent-metrics div {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
      }

      .agent-metrics dt {
        margin: 0;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .agent-metrics dd {
        margin: 0;
        font-weight: 600;
        font-size: 1.25rem;
      }

      .timestamp {
        margin-top: 1.25rem;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .control-actions {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.25rem;
        align-items: center;
      }

      .updated-note {
        color: #8a94a6;
        font-size: 0.75rem;
      }

      button {
        appearance: none;
        border: none;
        border-radius: 6px;
        padding: 0.55rem 1.1rem;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        background: linear-gradient(135deg, #2b63ff, #7a62ff);
        color: #f5f7fb;
        box-shadow: 0 10px 25px rgba(43, 99, 255, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 14px 28px rgba(43, 99, 255, 0.25);
      }

      button:disabled {
        cursor: wait;
        opacity: 0.65;
        box-shadow: none;
      }

      .button-danger {
        background: linear-gradient(135deg, #ef476f, #ff9a5a);
      }

      .button-success {
        background: linear-gradient(135deg, #2dce89, #28a745);
      }

      .button-ghost {
        background: rgba(39, 48, 66, 0.6);
        color: #dbe4ff;
      }

      .empty {
        margin: 1rem 0 0;
        color: #8a94a6;
        font-size: 0.9rem;
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <h1>Hedging Cycle Overview</h1>
    <p class="subtitle">Live metrics reported by the Aster–Lighter hedging executor.</p>

    <section class="grid">
      <article class="card">
        <h2>Current Position</h2>
        <div class="value" id="position">--</div>
      </article>
      <article class="card">
        <h2>Total Cycles</h2>
        <div class="value" id="cycles">--</div>
      </article>
      <article class="card">
        <h2>Cumulative PnL</h2>
        <div class="value" id="pnl">--</div>
      </article>
      <article class="card">
        <h2>Total Volume</h2>
        <div class="value" id="volume">--</div>
      </article>
      <article class="card">
        <h2>Available Balance</h2>
        <div class="value" id="available-balance">--</div>
      </article>
      <article class="card">
        <h2>Total Account Value</h2>
        <div class="value" id="account-value">--</div>
      </article>
      <article class="card">
        <h2>Runtime</h2>
        <div class="value" id="runtime">--</div>
      </article>
    </section>

    <section class="agent-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>Per-VPS Metrics</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="agent-count">0 active</span>
            <span class="badge badge-info hidden" id="default-pause-indicator">Paused by default</span>
          </div>
        </div>
        <div class="section-header-controls">
          <button type="button" class="button-danger" id="pause-all">Pause All</button>
          <button type="button" class="button-success" id="resume-all">Resume All</button>
        </div>
      </div>
      <p class="empty" id="agent-empty">Waiting for VPS metrics…</p>
      <div class="agent-grid hidden" id="agent-grid"></div>
    </section>

    <section class="spread-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>Aster–Lighter Spread Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="spread-agent-count">0 monitors</span>
          </div>
        </div>
        <div class="section-header-controls">
          <label class="spread-selector-label hidden" id="spread-agent-label">
            Monitor
            <select id="spread-agent-select"></select>
          </label>
        </div>
      </div>
      <p class="empty" id="spread-empty">Waiting for spread data…</p>
      <div class="spread-card hidden" id="spread-card">
        <div class="spread-meta">
          <span id="spread-instrument">Instrument —</span>
          <span id="spread-updated">Updated —</span>
        </div>
        <div class="spread-chart-wrapper hidden" id="spread-chart-wrapper">
          <canvas id="spread-chart"></canvas>
        </div>
        <div class="spread-table-wrapper">
          <table class="spread-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Aster Bid</th>
                <th>Aster Ask</th>
                <th>Lighter Bid</th>
                <th>Lighter Ask</th>
                <th>AsterBid - LighterAsk</th>
                <th>LighterBid - AsterAsk</th>
                <th>Mid Δ</th>
              </tr>
            </thead>
            <tbody id="spread-table-body"></tbody>
          </table>
        </div>
      </div>
    </section>

    <p class="updated" id="updated">Awaiting data…</p>

    <script>
    const agentGrid = document.getElementById('agent-grid');
    const agentEmpty = document.getElementById('agent-empty');
    const agentCount = document.getElementById('agent-count');
    const updatedElement = document.getElementById('updated');
    const defaultPauseIndicator = document.getElementById('default-pause-indicator');
    const pauseAllButton = document.getElementById('pause-all');
    const resumeAllButton = document.getElementById('resume-all');
    const runtimeElement = document.getElementById('runtime');
    const spreadAgentCount = document.getElementById('spread-agent-count');
    const spreadAgentLabel = document.getElementById('spread-agent-label');
    const spreadAgentSelect = document.getElementById('spread-agent-select');
    const spreadEmpty = document.getElementById('spread-empty');
    const spreadCard = document.getElementById('spread-card');
    const spreadTableBody = document.getElementById('spread-table-body');
    const spreadInstrument = document.getElementById('spread-instrument');
    const spreadUpdated = document.getElementById('spread-updated');
  const spreadChartWrapper = document.getElementById('spread-chart-wrapper');
  const spreadChartCanvas = document.getElementById('spread-chart');
      let batchBusy = false;
      let lastDefaultPaused = false;
      let selectedSpreadAgent = null;
      let lastSpreadOptionsKey = '';
      let lastMetricsSnapshot = null;

      const numberFormatter = new Intl.NumberFormat(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 6,
        notation: 'compact'
      });

      function toNumber(value) {
        if (value === null || value === undefined) {
          return 0;
        }
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : 0;
      }

      function parseDecimal(value) {
        if (value === null || value === undefined) {
          return null;
        }
        if (typeof value === 'number') {
          return Number.isFinite(value) ? value : null;
        }
        const normalized = String(value).replace(/,/g, '').trim();
        if (!normalized || normalized === '--') {
          return null;
        }
        const numeric = Number(normalized);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function computePercent(numerator, denominator) {
        if (!Number.isFinite(numerator) || !Number.isFinite(denominator) || Math.abs(denominator) < 1e-12) {
          return null;
        }
        return (numerator / denominator) * 100;
      }

      function formatPercent(value, digits = 2) {
        if (!Number.isFinite(value)) {
          return '—';
        }
        return `${value.toFixed(digits)}%`;
      }

      function getSeriesBounds(...seriesList) {
        let min = Infinity;
        let max = -Infinity;
        let hasValue = false;

        for (const series of seriesList) {
          for (const value of series) {
            if (!Number.isFinite(value)) {
              continue;
            }
            hasValue = true;
            if (value < min) {
              min = value;
            }
            if (value > max) {
              max = value;
            }
          }
        }

        if (!hasValue) {
          return { hasValue: false, min: 0, max: 0 };
        }

        if (min === max) {
          const epsilon = Math.abs(min) > 0 ? Math.abs(min) * 0.05 : 0.05;
          min -= epsilon;
          max += epsilon;
        }

        const padding = (max - min) * 0.08;
        return {
          hasValue: true,
          min: min - padding,
          max: max + padding,
        };
      }

      function prepareCanvas(canvas) {
        if (!canvas) {
          return null;
        }

        const rect = canvas.getBoundingClientRect();
        const width = rect.width || canvas.parentElement?.clientWidth || 600;
        const height = rect.height || 260;
        const dpr = window.devicePixelRatio || 1;

        canvas.width = width * dpr;
        canvas.height = height * dpr;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          return null;
        }

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        return { ctx, width, height };
      }

      function drawSeries(ctx, values, mapX, mapY, color) {
        ctx.beginPath();
        let started = false;
        for (let index = 0; index < values.length; index += 1) {
          const value = values[index];
          if (!Number.isFinite(value)) {
            started = false;
            continue;
          }

          const x = mapX(index);
          const y = mapY(value);
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        }

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function renderSpreadCanvas(labels, seriesA, seriesB) {
        if (!spreadChartCanvas) {
          return;
        }

        const bounds = getSeriesBounds(seriesA, seriesB);
        if (!bounds.hasValue) {
          spreadChartWrapper?.classList.add('hidden');
          return;
        }

        const setup = prepareCanvas(spreadChartCanvas);
        if (!setup) {
          spreadChartWrapper?.classList.add('hidden');
          return;
        }

        const { ctx, width, height } = setup;
        const { min, max } = bounds;
        const range = max - min || 1;

        const mapX = (index) => {
          if (labels.length <= 1) {
            return width / 2;
          }
          return (index / (labels.length - 1)) * width;
        };

        const mapY = (value) => {
          const ratio = (value - min) / range;
          return height - ratio * height;
        };

        ctx.fillStyle = '#1b1d24';
        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        const gridLines = 4;
        for (let i = 0; i <= gridLines; i += 1) {
          const y = (height / gridLines) * i;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        ctx.fillStyle = '#8a94a6';
        ctx.font = '12px "Segoe UI", system-ui';
        ctx.textBaseline = 'middle';

        const tickCount = 4;
        for (let i = 0; i <= tickCount; i += 1) {
          const value = min + (range * i) / tickCount;
          const y = mapY(value);
          ctx.fillText(formatPercent(value, 2), 6, Math.min(Math.max(y, 12), height - 12));
        }

        if (min < 0 && max > 0) {
          const zeroY = mapY(0);
          ctx.strokeStyle = 'rgba(199, 210, 232, 0.35)';
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.moveTo(0, zeroY);
          ctx.lineTo(width, zeroY);
          ctx.stroke();
        }

        drawSeries(ctx, seriesA, mapX, mapY, 'rgba(99, 156, 255, 1)');
        drawSeries(ctx, seriesB, mapX, mapY, 'rgba(255, 160, 86, 1)');

        ctx.textBaseline = 'top';
        ctx.fillStyle = '#c7d2e8';
        ctx.fillText('Aster bid – Lighter ask', 6, 6);
        ctx.fillText('Lighter bid – Aster ask', 6, 24);

        ctx.textBaseline = 'bottom';
        ctx.fillStyle = '#8a94a6';
        const labelCount = Math.min(4, labels.length - 1);
        for (let i = 0; i <= labelCount; i += 1) {
          const position = Math.max(labelCount, 1);
          const index = Math.round((i / position) * (labels.length - 1));
          const x = mapX(index);
          const text = labels[index] ?? '';
          ctx.fillText(text, Math.min(Math.max(x - 24, 4), width - 48), height - 4);
        }
      }

      function escapeHtml(value) {
        return String(value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function formatDecimal(value, fractionDigits = 4) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return '--';
        }
        return numeric.toFixed(fractionDigits);
      }

      function formatDuration(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) {
          return '0s';
        }

        let remaining = Math.round(seconds);
        if (remaining <= 0) {
          remaining = 1;
        }

        const units = [
          { label: 'd', value: 86400 },
          { label: 'h', value: 3600 },
          { label: 'm', value: 60 },
          { label: 's', value: 1 }
        ];

        const parts = [];
        for (const unit of units) {
          if (remaining < unit.value && parts.length === 0 && unit.label !== 's') {
            continue;
          }

          const amount = Math.floor(remaining / unit.value);
          if (amount > 0 || (unit.label === 's' && parts.length === 0)) {
            parts.push(`${amount}${unit.label}`);
          }
          remaining %= unit.value;

          if (parts.length >= 3) {
            break;
          }
        }

        return parts.join(' ');
      }

      function renderAggregate(data) {
        const position = toNumber(data.position ?? data?.aggregate?.position);
        const pnl = toNumber(data.cumulative_pnl ?? data?.aggregate?.cumulative_pnl);
        const volume = toNumber(data.cumulative_volume ?? data?.aggregate?.cumulative_volume);
        const cyclesRaw = Number(data.total_cycles ?? data?.aggregate?.total_cycles ?? 0);
        const available = toNumber(
          data.available_balance ??
          data.total_available_balance ??
          data?.aggregate?.available_balance
        );
        const accountValue = toNumber(
          data.total_account_value ??
          data.account_value ??
          data?.aggregate?.total_account_value ??
          data?.aggregate?.account_value
        );

        document.getElementById('position').textContent = numberFormatter.format(position);
        document.getElementById('pnl').textContent = numberFormatter.format(pnl);
        document.getElementById('volume').textContent = numberFormatter.format(volume);
        document.getElementById('cycles').textContent = Number.isFinite(cyclesRaw) ? cyclesRaw : '--';
        document.getElementById('available-balance').textContent = numberFormatter.format(available);
        document.getElementById('account-value').textContent = numberFormatter.format(accountValue);
        const runtimeSeconds = toNumber(data.runtime_seconds ?? data?.aggregate?.runtime_seconds);
        if (runtimeElement) {
          runtimeElement.textContent = formatDuration(runtimeSeconds);
        }

        if (data.last_update_ts) {
          const updatedDate = new Date(Number(data.last_update_ts) * 1000);
          const latestAgent = data.last_agent_id ? ` (agent: ${data.last_agent_id})` : '';
          updatedElement.textContent = `Last update: ${updatedDate.toLocaleString()}${latestAgent}`;
        } else {
          updatedElement.textContent = 'Awaiting data…';
        }
      }

      function updateBatchButtons() {
        if (!pauseAllButton || !resumeAllButton) {
          return;
        }

        if (batchBusy) {
          pauseAllButton.disabled = true;
          resumeAllButton.disabled = true;
        } else {
          pauseAllButton.disabled = lastDefaultPaused;
          resumeAllButton.disabled = !lastDefaultPaused;
        }

        pauseAllButton.classList.toggle('button-ghost', lastDefaultPaused);
        resumeAllButton.classList.toggle('button-ghost', !lastDefaultPaused);
      }

      async function sendControl(agentId, action, button) {
        if (!agentId || !action) {
          return;
        }

        const previousText = button?.textContent ?? '';
        if (button) {
          button.disabled = true;
          button.textContent = action === 'pause' ? 'Pausing…' : 'Resuming…';
        }

        try {
          const response = await fetch('/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ agent_id: agentId, action })
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          await refreshMetrics();
        } catch (error) {
          updatedElement.textContent = `Control update failed: ${error}`;
        } finally {
          if (button) {
            button.disabled = false;
            button.textContent = previousText || (action === 'pause' ? 'Pause' : 'Resume');
          }
        }
      }

      async function sendBatchControl(action, button) {
        if (!action) {
          return;
        }

        const buttons = [pauseAllButton, resumeAllButton].filter(Boolean);
        const previousTexts = new Map();

        batchBusy = true;
        updateBatchButtons();

        if (button) {
          previousTexts.set(button, button.textContent);
          button.textContent = action === 'pause' ? 'Pausing…' : 'Resuming…';
        }

        try {
          const response = await fetch('/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ scope: 'all', action })
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          await refreshMetrics();
        } catch (error) {
          updatedElement.textContent = `Control update failed: ${error}`;
        } finally {
          batchBusy = false;
          buttons.forEach((btn) => {
            if (btn && previousTexts.has(btn)) {
              btn.textContent = previousTexts.get(btn);
            }
          });
          updateBatchButtons();
        }
      }

      function renderAgents(data) {
        const entries = Object.entries(data?.agents ?? {});
        const staleSet = new Set(data?.stale_agents ?? []);
        const lastAgentId = data?.last_agent_id ?? null;
        const controls = data?.controls ?? {};

        agentGrid.innerHTML = '';

        if (!entries.length) {
          agentGrid.classList.add('hidden');
          agentEmpty.classList.remove('hidden');
          agentEmpty.textContent = 'Waiting for VPS metrics…';
          agentCount.textContent = '0 active';
          return;
        }

        agentGrid.classList.remove('hidden');
        agentEmpty.classList.add('hidden');

        entries.sort((a, b) => a[0].localeCompare(b[0], undefined, { sensitivity: 'base' }));

        let activeCount = 0;
        let pausedCount = 0;

  for (const [agentId, metrics] of entries) {
          const safeId = escapeHtml(agentId);
          const position = numberFormatter.format(toNumber(metrics.position));
          const pnl = numberFormatter.format(toNumber(metrics.cumulative_pnl));
          const volume = numberFormatter.format(toNumber(metrics.cumulative_volume));
          const available = numberFormatter.format(
            toNumber(
              metrics.available_balance ??
              metrics.available ??
              metrics.total_available_balance
            )
          );
          const accountValue = numberFormatter.format(
            toNumber(
              metrics.total_account_value ??
              metrics.account_value ??
              metrics.total_asset_value
            )
          );
          const instrumentText = metrics.instrument ? escapeHtml(metrics.instrument) : '—';
          const runtimeSeconds = toNumber(metrics.runtime_seconds);
          const runtimeDisplay = escapeHtml(formatDuration(runtimeSeconds));
          let depthDisplay = '—';
          if (metrics.depths && typeof metrics.depths === 'object') {
            const depthEntries = Object.entries(metrics.depths)
              .map(([key, value]) => {
                const depthValue = Number(value);
                if (!Number.isFinite(depthValue)) {
                  return null;
                }
                return `${escapeHtml(String(key))} ${depthValue}`;
              })
              .filter(Boolean);
            if (depthEntries.length) {
              depthDisplay = depthEntries.join(' · ');
            }
          }
          const cyclesRaw = Number(metrics.total_cycles ?? 0);
          const cycles = Number.isFinite(cyclesRaw) ? cyclesRaw : '--';

          const updatedTs = Number(metrics.last_update_ts ?? 0) * 1000;
          const updatedText = Number.isFinite(updatedTs) && updatedTs > 0
            ? new Date(updatedTs).toLocaleString()
            : 'Awaiting data…';

          const control = controls[agentId] ?? {};
          const isPaused = Boolean(control.paused);
          const controlTs = Number(control.updated_at ?? 0) * 1000;
          const pausedSinceText = isPaused && Number.isFinite(controlTs) && controlTs > 0
            ? new Date(controlTs).toLocaleString()
            : null;

          const card = document.createElement('article');
          card.className = 'agent-card card';

          const isStale = staleSet.has(agentId);
          if (isStale) {
            card.classList.add('stale');
          }
          if (isPaused) {
            card.classList.add('paused');
            pausedCount += 1;
          }
          if (!isStale && !isPaused) {
            activeCount += 1;
          }
          if (lastAgentId && agentId === lastAgentId) {
            card.classList.add('recent');
          }

          const statusParts = [];
          statusParts.push(isPaused ? 'Paused' : 'Active');
          if (isStale) {
            statusParts.push('Stale');
          }
          if (pausedSinceText) {
            statusParts.push(`since ${pausedSinceText}`);
          }
          const statusText = statusParts.join(' · ');

          card.innerHTML = `
            <header>
              <span class="agent-name">${safeId}</span>
              <span class="badge-group">
                ${lastAgentId && agentId === lastAgentId ? '<span class="badge badge-info">Latest</span>' : ''}
                ${isPaused ? '<span class="badge badge-muted">Paused</span>' : ''}
                ${isStale ? '<span class="badge badge-warn">Stale</span>' : ''}
              </span>
            </header>
            <dl class="agent-metrics">
              <div><dt>Position</dt><dd>${position}</dd></div>
              <div><dt>Total Cycles</dt><dd>${cycles}</dd></div>
              <div><dt>Runtime</dt><dd>${runtimeDisplay}</dd></div>
              <div><dt>Cumulative PnL</dt><dd>${pnl}</dd></div>
              <div><dt>Total Volume</dt><dd>${volume}</dd></div>
              <div><dt>Available</dt><dd>${available}</dd></div>
              <div><dt>Account Value</dt><dd>${accountValue}</dd></div>
              <div><dt>Instrument</dt><dd>${instrumentText}</dd></div>
              <div><dt>Depth</dt><dd>${escapeHtml(depthDisplay)}</dd></div>
            </dl>
            <p class="timestamp">${escapeHtml(statusText || 'Status unknown')}</p>
            <div class="control-actions">
              <button type="button" data-agent="${safeId}">${isPaused ? 'Resume' : 'Pause'}</button>
              <span class="updated-note">Updated ${escapeHtml(updatedText)}</span>
            </div>
          `;

          const controlButton = card.querySelector('button');
          if (controlButton) {
            controlButton.addEventListener('click', () => {
              const action = isPaused ? 'resume' : 'pause';
              sendControl(agentId, action, controlButton);
            });
          }

          agentGrid.appendChild(card);
        }

        const summaryParts = [];
        summaryParts.push(`${activeCount} active`);
        summaryParts.push(`${pausedCount} paused`);
        summaryParts.push(`${entries.length} total`);
        agentCount.textContent = summaryParts.join(' · ');

          const defaultPaused = Boolean(data?.default_paused);
          if (defaultPauseIndicator) {
            defaultPauseIndicator.classList.toggle('hidden', !defaultPaused);
          }

          lastDefaultPaused = defaultPaused;
          updateBatchButtons();
      }

      function renderSpread(data) {
        if (!spreadAgentCount || !spreadEmpty || !spreadCard) {
          return;
        }

        const spreads = data?.spread_metrics ?? {};
        const entries = Object.entries(spreads);
        const monitorLabel = entries.length === 1 ? 'monitor' : 'monitors';
        spreadAgentCount.textContent = `${entries.length} ${monitorLabel}`;

        if (!entries.length) {
          spreadCard.classList.add('hidden');
          spreadEmpty.classList.remove('hidden');
          spreadEmpty.textContent = 'Waiting for spread data…';
          if (spreadAgentLabel) {
            spreadAgentLabel.classList.add('hidden');
          }
          if (spreadTableBody) {
            spreadTableBody.innerHTML = '';
          }
          return;
        }

        spreadEmpty.classList.add('hidden');
        spreadCard.classList.remove('hidden');

        if (!selectedSpreadAgent || !spreads[selectedSpreadAgent]) {
          selectedSpreadAgent = entries[0][0];
        }

        if (spreadAgentSelect) {
          const optionsKey = entries.map(([agent]) => agent).join('|');
          if (optionsKey !== lastSpreadOptionsKey) {
            spreadAgentSelect.innerHTML = '';
            for (const [agent] of entries) {
              const option = document.createElement('option');
              option.value = agent;
              option.textContent = agent;
              spreadAgentSelect.appendChild(option);
            }
            lastSpreadOptionsKey = optionsKey;
          }
          spreadAgentSelect.value = selectedSpreadAgent;
          if (spreadAgentLabel) {
            spreadAgentLabel.classList.toggle('hidden', entries.length <= 1);
          }
        }

        const metrics = spreads[selectedSpreadAgent] ?? {};
        const historyRaw = Array.isArray(metrics.history) ? metrics.history : [];
        const history = historyRaw.slice(-60).reverse();

        if (spreadInstrument) {
          const ticker = metrics?.aster?.ticker ?? '';
          const symbol = metrics?.lighter?.symbol ?? '';
          const instrumentText = metrics.instrument || `${ticker}${ticker && symbol ? ' / ' : ''}${symbol}`;
          spreadInstrument.textContent = instrumentText ? `Instrument ${escapeHtml(instrumentText)}` : 'Instrument —';
        }

        if (spreadUpdated) {
          const tsSource = Number(metrics.updated_at ?? (historyRaw.length ? historyRaw[historyRaw.length - 1]?.timestamp : Date.now() / 1000));
          if (Number.isFinite(tsSource)) {
            spreadUpdated.textContent = `Updated ${new Date(tsSource * 1000).toLocaleString()}`;
          } else {
            spreadUpdated.textContent = 'Updated —';
          }
        }

        if (!spreadTableBody) {
          return;
        }

        spreadTableBody.innerHTML = '';
        if (!history.length) {
          const emptyRow = document.createElement('tr');
          emptyRow.innerHTML = '<td colspan="8">Awaiting history…</td>';
          spreadTableBody.appendChild(emptyRow);
          if (spreadChartWrapper) {
            spreadChartWrapper.classList.add('hidden');
          }
          return;
        }

        const chartLabels = [];
        const chartSellAster = [];
        const chartSellLighter = [];

        for (const row of history) {
          const tr = document.createElement('tr');
          const timestamp = Number(row.timestamp);
          const timeLabel = row.iso_time
            ? new Date(row.iso_time).toLocaleTimeString()
            : (Number.isFinite(timestamp) ? new Date(timestamp * 1000).toLocaleTimeString() : '--');

          const asterBid = parseDecimal(row.aster_bid);
          const asterAsk = parseDecimal(row.aster_ask);
          const lighterBid = parseDecimal(row.lighter_bid);
          const lighterAsk = parseDecimal(row.lighter_ask);
          const spreadSellAsterRaw = Number.isFinite(asterBid) && Number.isFinite(lighterAsk)
            ? asterBid - lighterAsk
            : parseDecimal(row.spread_aster_bid_minus_lighter_ask);
          const spreadSellLighterRaw = Number.isFinite(lighterBid) && Number.isFinite(asterAsk)
            ? lighterBid - asterAsk
            : parseDecimal(row.spread_lighter_bid_minus_aster_ask);

          const basisAsterDenom = Number.isFinite(lighterAsk) ? Math.abs(lighterAsk) : Number.isFinite(asterBid) ? Math.abs(asterBid) : null;
          const basisLighterDenom = Number.isFinite(asterAsk) ? Math.abs(asterAsk) : Number.isFinite(lighterBid) ? Math.abs(lighterBid) : null;

          chartLabels.push(timeLabel);
          chartSellAster.push(computePercent(spreadSellAsterRaw ?? NaN, basisAsterDenom ?? NaN));
          chartSellLighter.push(computePercent(spreadSellLighterRaw ?? NaN, basisLighterDenom ?? NaN));

          const cells = [
            escapeHtml(timeLabel),
            escapeHtml(formatDecimal(row.aster_bid, 4)),
            escapeHtml(formatDecimal(row.aster_ask, 4)),
            escapeHtml(formatDecimal(row.lighter_bid, 4)),
            escapeHtml(formatDecimal(row.lighter_ask, 4)),
            escapeHtml(formatDecimal(row.spread_aster_bid_minus_lighter_ask, 6)),
            escapeHtml(formatDecimal(row.spread_lighter_bid_minus_aster_ask, 6)),
            escapeHtml(formatDecimal(row.mid_price_diff, 6))
          ];
          tr.innerHTML = cells.map((value) => `<td>${value}</td>`).join('');
          spreadTableBody.appendChild(tr);
        }

        const hasChartPoints = chartSellAster.some((value) => Number.isFinite(value)) ||
          chartSellLighter.some((value) => Number.isFinite(value));

        if (spreadChartWrapper) {
          if (hasChartPoints) {
            spreadChartWrapper.classList.remove('hidden');
            renderSpreadCanvas(chartLabels, chartSellAster, chartSellLighter);
          } else {
            spreadChartWrapper.classList.add('hidden');
          }
        }
      }

      async function refreshMetrics() {
        try {
          const response = await fetch('/metrics', { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();
          lastMetricsSnapshot = data;
          renderAggregate(data);
          renderAgents(data);
          renderSpread(data);
        } catch (error) {
          updatedElement.textContent = `Dashboard error: ${error}`;
          agentCount.textContent = '—';
          agentGrid.innerHTML = '';
          agentGrid.classList.add('hidden');
          agentEmpty.classList.remove('hidden');
          agentEmpty.textContent = 'Unable to load metrics at the moment.';
          if (spreadAgentCount) {
            spreadAgentCount.textContent = '0 monitors';
          }
          if (spreadCard) {
            spreadCard.classList.add('hidden');
          }
          if (spreadEmpty) {
            spreadEmpty.classList.remove('hidden');
            spreadEmpty.textContent = 'Unable to load spread data at the moment.';
          }
        }
      }

      if (pauseAllButton) {
        pauseAllButton.addEventListener('click', () => sendBatchControl('pause', pauseAllButton));
      }
      if (resumeAllButton) {
        resumeAllButton.addEventListener('click', () => sendBatchControl('resume', resumeAllButton));
      }
      if (spreadAgentSelect) {
        spreadAgentSelect.addEventListener('change', (event) => {
          selectedSpreadAgent = event.target.value;
          if (lastMetricsSnapshot) {
            renderSpread(lastMetricsSnapshot);
          }
        });
      }

      refreshMetrics();
      setInterval(refreshMetrics, 2000);
    </script>
  </body>
</html>
