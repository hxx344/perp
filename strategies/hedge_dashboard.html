<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hedge Metrics Dashboard</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
        background: #111;
        color: #f2f4f8;
      }

      body {
        margin: 0;
        padding: 2rem;
        max-width: 960px;
        margin-inline: auto;
      }

      h1 {
        font-size: 1.75rem;
        margin-bottom: 0.5rem;
      }

      .subtitle {
        color: #8a94a6;
        margin-bottom: 2rem;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.25rem;
      }

      .card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .spread-section {
        margin-top: 2.5rem;
      }

      .strategy-section {
        margin-top: 2.5rem;
      }

      .strategy-card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
        margin-top: 1rem;
      }

      .grvt-section {
        margin-top: 2.5rem;
      }

      .grvt-card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .grvt-summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.25rem;
        margin-bottom: 1.75rem;
      }

      .grvt-summary-card h3 {
        margin: 0 0 0.35rem;
        font-size: 0.9rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .grvt-summary-card .value {
        font-size: 1.75rem;
        font-weight: 600;
      }

      .grvt-summary-updated {
        margin-top: 0.4rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-risk-detail {
        margin-top: 0.35rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .risk-pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.35rem 0.85rem;
        border-radius: 999px;
        font-weight: 600;
        letter-spacing: 0.04em;
        background: rgba(255, 255, 255, 0.08);
        color: #f5f7fb;
        transition: background 0.25s ease, color 0.25s ease, box-shadow 0.25s ease;
        box-shadow: 0 0 0 rgba(0, 0, 0, 0);
      }

      .risk-pill-summary {
        font-size: 1.35rem;
        min-width: 6rem;
      }

      .risk-pill-inline {
        font-size: 0.85rem;
        padding: 0.15rem 0.6rem;
        min-width: 0;
      }

      .grvt-account-grid {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 1.1rem;
      }

      .grvt-adjust-panel {
        margin-top: 1.5rem;
        padding: 1rem 1.25rem;
        border-radius: 12px;
        background: #1b1f2a;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-transfer-panel {
        margin-top: 1.25rem;
        padding: 1rem 1.25rem 1.25rem;
        border-radius: 12px;
        background: #141823;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .grvt-transfer-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.85rem;
        margin-top: 1rem;
      }

      .grvt-transfer-grid label {
        display: flex;
        flex-direction: column;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .grvt-transfer-grid input,
      .grvt-transfer-grid select,
      .grvt-transfer-grid textarea {
        margin-top: 0.35rem;
        background: #11141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.45rem 0.65rem;
        color: #f5f7fb;
        font-size: 0.9rem;
      }

      .grvt-transfer-grid textarea {
        min-height: 46px;
        resize: vertical;
      }

      .grvt-transfer-actions {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-top: 1.1rem;
        flex-wrap: wrap;
      }

      .grvt-transfer-status {
        flex: 1;
        min-width: 240px;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-transfer-history table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.78rem;
        margin-top: 0.9rem;
      }

      .grvt-transfer-history thead {
        background: rgba(255, 255, 255, 0.03);
      }

      .grvt-transfer-history th,
      .grvt-transfer-history td {
        padding: 0.4rem 0.5rem;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-adjust-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: flex-end;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .grvt-adjust-controls label {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-adjust-controls input {
        margin-top: 0.35rem;
        background: #11141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.4rem 0.65rem;
        color: #f5f7fb;
        min-width: 120px;
        font-size: 0.95rem;
      }

      .grvt-adjust-controls select {
        margin-top: 0.35rem;
        background: #11141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.4rem 0.65rem;
        color: #f5f7fb;
        font-size: 0.85rem;
        min-width: 140px;
      }

      .grvt-symbol-input {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .grvt-symbol-label {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        margin-bottom: 0.35rem;
        color: #8a94a6;
      }

      .grvt-symbol-label small {
        font-size: 0.75rem;
        color: #6d768f;
      }

      .grvt-symbol-reset {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.08);
        color: #f5f7fb;
        padding: 0.35rem 0.8rem;
        font-size: 0.78rem;
        cursor: pointer;
        transition: opacity 0.2s ease;
      }

      .grvt-symbol-reset:hover {
        opacity: 0.8;
      }

      .grvt-adjust-controls label.grvt-adjust-symbols {
        flex: 1;
        min-width: 200px;
        max-width: 240px;
      }

      .grvt-adjust-buttons {
        display: flex;
        gap: 0.75rem;
      }

      .grvt-adjust-status {
        flex: 1;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-adjust-history table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.78rem;
      }

      .grvt-adjust-history thead {
        background: rgba(255, 255, 255, 0.04);
      }

      .grvt-adjust-history th,
      .grvt-adjust-history td {
        padding: 0.4rem 0.5rem;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .adjust-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.15rem 0.5rem;
        border-radius: 999px;
        font-size: 0.7rem;
        margin: 0 0.25rem 0.25rem 0;
        background: rgba(255, 255, 255, 0.08);
      }

      .adjust-badge.status-pending {
        background: rgba(255, 255, 255, 0.08);
        color: #f5f7fb;
      }

      .adjust-badge.status-acknowledged {
        background: rgba(45, 206, 137, 0.15);
        color: #9ff3c9;
      }

      .adjust-badge.status-failed {
        background: rgba(239, 71, 111, 0.18);
        color: #ffb3c1;
      }

      .adjust-badge.status-expired {
        background: rgba(255, 193, 7, 0.18);
        color: #ffe8a3;
      }

      .grvt-account-card {
        background: #1f2533;
        border-radius: 12px;
        padding: 1.25rem;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-account-card header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        margin-bottom: 0.9rem;
      }

      .grvt-account-name {
        font-weight: 600;
        font-size: 1.05rem;
      }

      .grvt-account-updated {
        font-size: 0.75rem;
        color: #8a94a6;
      }

      .grvt-account-metrics {
        display: grid;
        gap: 0.45rem;
        margin: 0 0 0.75rem;
      }

      .grvt-account-metrics div {
        display: flex;
        justify-content: space-between;
        font-variant-numeric: tabular-nums;
        font-size: 0.9rem;
      }

      .grvt-account-metrics dt {
        margin: 0;
        text-transform: uppercase;
        font-size: 0.75rem;
        color: #7f8fa9;
        letter-spacing: 0.05em;
      }

      .grvt-account-metrics dd {
        margin: 0;
        font-weight: 600;
      }

      .grvt-positions-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.8rem;
      }

      .grvt-positions-table thead {
        background: rgba(255, 255, 255, 0.04);
      }

      .grvt-positions-table th,
      .grvt-positions-table td {
        padding: 0.4rem 0.45rem;
        text-align: right;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        white-space: nowrap;
      }

      .grvt-positions-table th:first-child,
      .grvt-positions-table td:first-child {
        text-align: left;
      }

      .grvt-positions-empty {
        margin: 0;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .grvt-source-badge {
        display: inline-flex;
        align-items: center;
        padding: 0.1rem 0.5rem;
        border-radius: 999px;
        font-size: 0.7rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        background: #1f2a38;
        color: #a4d5ff;
        margin-left: 0.5rem;
      }

      .strategy-summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1.25rem;
      }

      .summary-sub {
        margin-top: 0.5rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .strategy-table-wrapper {
        margin-top: 1.5rem;
        overflow-x: auto;
      }

      .strategy-selector-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .strategy-selector-label select {
        background: #1f2533;
        color: #f5f7fb;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 6px;
        padding: 0.35rem 0.65rem;
        font-size: 0.85rem;
      }

      table.strategy-table td.action-enter {
        color: #7ee787;
      }

      table.strategy-table td.action-exit {
        color: #ffa94d;
      }

      table.strategy-table td.action-forced {
        color: #ff8787;
      }

      table.strategy-table td.action-other {
        color: #c7d2e8;
      }

      .spread-card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .spread-chart-wrapper {
        height: 280px;
        margin-bottom: 1.5rem;
      }

      .spread-chart-wrapper canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .spread-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin-bottom: 1rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .spread-table-wrapper {
        overflow-x: auto;
      }

      table.spread-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
      }

      table.spread-table thead {
        background: #222635;
      }

      table.spread-table th,
      table.spread-table td {
        padding: 0.65rem 0.75rem;
        text-align: right;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        white-space: nowrap;
      }

      table.spread-table th:first-child,
      table.spread-table td:first-child {
        text-align: left;
      }

      .spread-selector-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .spread-selector-label select {
        background: #1f2533;
        color: #f5f7fb;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 6px;
        padding: 0.35rem 0.65rem;
        font-size: 0.85rem;
      }

      .card h2 {
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        margin: 0 0 0.75rem;
        color: #7f8fa9;
      }

      .value {
        font-size: 2rem;
        font-weight: 600;
      }

      #runtime.runtime-multiple {
        font-size: 1.15rem;
        font-weight: 500;
        line-height: 1.4;
      }

      #runtime .runtime-row {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 0.75rem;
      }

      #runtime .runtime-row + .runtime-row {
        margin-top: 0.35rem;
      }

      #runtime .runtime-row-label {
        font-weight: 600;
        color: #c7d2e8;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        font-size: 0.9rem;
      }

      #runtime .runtime-row-value {
        font-variant-numeric: tabular-nums;
        color: #f2f4f8;
        font-size: 1rem;
      }

      .updated {
        margin-top: 2rem;
        color: #7f8fa9;
        font-size: 0.85rem;
      }

      .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem 1.25rem;
        margin-top: 2.5rem;
        margin-bottom: 1rem;
      }

      .section-header-info {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .section-header h2 {
        margin: 0;
        font-size: 1.25rem;
      }

      .section-header-controls {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        padding: 0.15rem 0.6rem;
        border-radius: 999px;
        font-size: 0.72rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        background: #273042;
        color: #c7d2e8;
      }

      .badge-group {
        display: inline-flex;
        gap: 0.35rem;
        align-items: center;
      }

      .badge-muted {
        background: #1f2533;
        color: #8a94a6;
      }

      .badge-warn {
        background: #4a1f1f;
        color: #ffc9c9;
      }

      .badge-info {
        background: #19314d;
        color: #a4d5ff;
      }

      .agent-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1.25rem;
      }

      .agent-card {
        transition: box-shadow 0.25s ease, transform 0.25s ease;
        border: 1px solid transparent;
      }

      .agent-card.recent {
        box-shadow: 0 0 0 2px rgba(76, 201, 240, 0.25);
      }

      .agent-card.stale {
        border-color: rgba(255, 171, 64, 0.45);
        opacity: 0.7;
      }

      .agent-card.paused {
        border-color: rgba(125, 140, 170, 0.35);
        background: #202431;
      }

      .agent-card header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.1rem;
      }

      .agent-name {
        font-weight: 600;
        font-size: 1.05rem;
        color: #f5f7fb;
      }

      .agent-metrics {
        display: grid;
        gap: 0.6rem;
        margin: 0;
      }

      .agent-metrics div {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
      }

      .agent-metrics dt {
        margin: 0;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .agent-metrics dd {
        margin: 0;
        font-weight: 600;
        font-size: 1.25rem;
      }

      .timestamp {
        margin-top: 1.25rem;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .control-actions {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.25rem;
        align-items: center;
      }

      .updated-note {
        color: #8a94a6;
        font-size: 0.75rem;
      }

      button {
        appearance: none;
        border: none;
        border-radius: 6px;
        padding: 0.55rem 1.1rem;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        background: linear-gradient(135deg, #2b63ff, #7a62ff);
        color: #f5f7fb;
        box-shadow: 0 10px 25px rgba(43, 99, 255, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 14px 28px rgba(43, 99, 255, 0.25);
      }

      button:disabled {
        cursor: wait;
        opacity: 0.65;
        box-shadow: none;
      }

      .button-danger {
        background: linear-gradient(135deg, #ef476f, #ff9a5a);
      }

      .button-success {
        background: linear-gradient(135deg, #2dce89, #28a745);
      }

      .button-ghost {
        background: rgba(39, 48, 66, 0.6);
        color: #dbe4ff;
      }

      .empty {
        margin: 1rem 0 0;
        color: #8a94a6;
        font-size: 0.9rem;
      }

      .hidden {
        display: none !important;
      }

      .dashboard-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1.5rem;
        flex-wrap: wrap;
      }

      .logout-button {
        min-width: 140px;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .logout-button:hover {
        background: rgba(255, 255, 255, 0.15);
      }
    </style>
  </head>
  <body>
    <div class="dashboard-top">
      <div>
        <h1>Hedging Cycle Overview</h1>
        <p class="subtitle">Live metrics reported by the Aster–Lighter hedging executor.</p>
      </div>
      <form id="logout-form" method="post" action="/logout">
        <button type="submit" class="logout-button">退出登录</button>
      </form>
    </div>

    <section class="grvt-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>GRVT Multi-Account Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="grvt-account-count">0 accounts</span>
          </div>
        </div>
        <div class="section-header-controls"></div>
      </div>
      <p class="empty" id="grvt-empty">Waiting for GRVT monitor…</p>
      <div class="grvt-card hidden" id="grvt-card">
        <div class="grvt-summary-grid">
          <article class="card grvt-summary-card">
            <h3>Total PnL</h3>
            <div class="value" id="grvt-total-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>ETH PnL</h3>
            <div class="value" id="grvt-eth-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>BTC PnL</h3>
            <div class="value" id="grvt-btc-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>Net Equity</h3>
            <div class="value" id="grvt-total-equity">--</div>
            <p class="summary-sub" id="grvt-wallet-balance">Wallet --</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Risk Level</h3>
            <div class="value risk-pill risk-pill-summary" id="grvt-risk-level">--</div>
            <p class="grvt-risk-detail" id="grvt-risk-detail">Awaiting data…</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Last Update</h3>
            <div class="value" id="grvt-summary-time">--</div>
            <p class="grvt-summary-updated" id="grvt-summary-updated">Updated —</p>
          </article>
        </div>
        <div class="grvt-adjust-panel" id="grvt-adjust-panel">
          <div class="grvt-adjust-header">
            <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">Global Position Adjustments</h3>
            <p class="summary-sub" style="margin: 0;">Broadcast add/reduce requests to every VPS</p>
          </div>
          <div class="grvt-adjust-controls">
            <label for="grvt-adjust-symbols" class="grvt-adjust-symbols">
              <div class="grvt-symbol-label">
                <span>目标币种</span>
                <small>选择需要调整的币种；未选中时广播所有</small>
              </div>
              <div class="grvt-symbol-input">
                <select id="grvt-adjust-symbols"></select>
                <button type="button" class="grvt-symbol-reset" id="grvt-reset-symbol">清空</button>
              </div>
            </label>
            <label for="grvt-adjust-size">
              Size
              <input type="number" id="grvt-adjust-size" min="0.01" step="0.01" value="1" />
            </label>
            <div class="grvt-adjust-buttons">
              <button type="button" id="grvt-adjust-add">加仓</button>
              <button type="button" class="button-danger" id="grvt-adjust-reduce">减仓</button>
            </div>
            <p class="grvt-adjust-status" id="grvt-adjust-status">等待指令…</p>
          </div>
          <div class="grvt-adjust-history">
            <table>
              <thead>
                <tr>
                  <th>时间</th>
                  <th>动作</th>
                  <th>数量</th>
                  <th>币种</th>
                  <th>状态</th>
                  <th>节点</th>
                </tr>
              </thead>
              <tbody id="grvt-adjust-history"></tbody>
            </table>
          </div>
        </div>
        <div class="grvt-transfer-panel hidden" id="grvt-transfer-panel">
          <div class="grvt-adjust-header">
            <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">账户间资金划转</h3>
            <p class="summary-sub" style="margin: 0;">默认方向：每台 VPS 子账户 → 主账户</p>
          </div>
          <div class="grvt-transfer-grid">
            <label>
              VPS 节点
              <select id="grvt-transfer-agent"></select>
            </label>
            <label>
              转账方向
              <select id="grvt-transfer-direction">
                <option value="sub_to_main">交易子账户 → 主账户</option>
                <option value="main_to_sub">主账户 → 交易子账户</option>
              </select>
            </label>
            <label>
              数量
              <input type="number" id="grvt-transfer-amount" min="0" step="0.01" value="0" />
            </label>
            <label>
              币种
              <input type="text" id="grvt-transfer-currency" value="USDT" />
            </label>
            <label>
              Transfer 类型
              <input type="text" id="grvt-transfer-type" value="spot" />
            </label>
            <label>
              备注（可选）
              <textarea id="grvt-transfer-reason" placeholder="记录用途或审批信息"></textarea>
            </label>
          </div>
          <div class="grvt-transfer-grid">
            <label>
              From Account ID
              <input type="text" id="grvt-transfer-from-account" />
            </label>
            <label>
              From Sub Account ID
              <input type="text" id="grvt-transfer-from-sub" />
            </label>
            <label>
              To Account ID
              <input type="text" id="grvt-transfer-to-account" />
            </label>
            <label>
              To Sub Account ID
              <input type="text" id="grvt-transfer-to-sub" />
            </label>
          </div>
          <div class="grvt-transfer-actions">
            <button type="button" id="grvt-transfer-submit">提交互转</button>
            <p class="grvt-transfer-status" id="grvt-transfer-status">等待指令…</p>
          </div>
          <div class="grvt-transfer-history">
            <table>
              <thead>
                <tr>
                  <th>时间</th>
                  <th>VPS</th>
                  <th>方向</th>
                  <th>金额</th>
                  <th>路径</th>
                  <th>状态 / 备注</th>
                </tr>
              </thead>
              <tbody id="grvt-transfer-history"></tbody>
            </table>
          </div>
        </div>
        <div>
          <h3 style="margin-bottom: 0.75rem; font-size: 1rem;">Per Account Net PnL</h3>
          <div class="grvt-account-grid" id="grvt-account-grid"></div>
          <p class="empty hidden" id="grvt-accounts-empty">No account data yet…</p>
        </div>
      </div>
    </section>

    <section class="grid">
      <article class="card">
        <h2>Current Position</h2>
        <div class="value" id="position">--</div>
      </article>
      <article class="card">
        <h2>Total Cycles</h2>
        <div class="value" id="cycles">--</div>
      </article>
      <article class="card">
        <h2>Cumulative PnL</h2>
        <div class="value" id="pnl">--</div>
      </article>
      <article class="card">
        <h2>Total Volume</h2>
        <div class="value" id="volume">--</div>
      </article>
      <article class="card">
        <h2>Available Balance</h2>
        <div class="value" id="available-balance">--</div>
      </article>
      <article class="card">
        <h2>Total Account Value</h2>
        <div class="value" id="account-value">--</div>
      </article>
      <article class="card">
        <h2>Runtime</h2>
        <div class="value" id="runtime">--</div>
      </article>
    </section>

    <section class="agent-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>Per-VPS Metrics</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="agent-count">0 active</span>
            <span class="badge badge-info hidden" id="default-pause-indicator">Paused by default</span>
          </div>
        </div>
        <div class="section-header-controls">
          <button type="button" class="button-danger" id="pause-all">Pause All</button>
          <button type="button" class="button-success" id="resume-all">Resume All</button>
        </div>
      </div>
      <p class="empty" id="agent-empty">Waiting for VPS metrics…</p>
      <div class="agent-grid hidden" id="agent-grid"></div>
    </section>


    <section class="strategy-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>Spread Strategy Profit Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="strategy-agent-count">0 strategies</span>
          </div>
        </div>
        <div class="section-header-controls">
          <label class="strategy-selector-label hidden" id="strategy-agent-label">
            Strategy
            <select id="strategy-agent-select"></select>
          </label>
        </div>
      </div>
      <p class="empty" id="strategy-empty">Waiting for strategy metrics…</p>
      <div class="strategy-card hidden" id="strategy-card">
        <div class="strategy-summary-grid">
          <article class="card">
            <h2>Net PnL</h2>
            <div class="value" id="strategy-net-pnl">--</div>
            <p class="summary-sub" id="strategy-trade-count">Trades —</p>
          </article>
          <article class="card">
            <h2>Total Volume</h2>
            <div class="value" id="strategy-total-volume">--</div>
            <p class="summary-sub">Entry + exit notional</p>
          </article>
          <article class="card">
            <h2>PnL / Volume</h2>
            <div class="value" id="strategy-pnl-ratio">--</div>
            <p class="summary-sub">Net profit versus traded value</p>
          </article>
          <article class="card">
            <h2>Open Position</h2>
            <div class="value" id="strategy-open-position">None</div>
            <p class="summary-sub" id="strategy-open-details">—</p>
          </article>
          <article class="card">
            <h2>Last Decision</h2>
            <div class="value" id="strategy-last-decision">—</div>
            <p class="summary-sub" id="strategy-last-decision-time">—</p>
          </article>
        </div>
        <div class="strategy-table-wrapper">
          <table class="spread-table strategy-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Action</th>
                <th>Direction</th>
                <th>Spread</th>
                <th>Z-Score</th>
                <th>Quantity</th>
                <th>PnL</th>
                <th>Reason</th>
              </tr>
            </thead>
            <tbody id="strategy-events-body"></tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="spread-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>Aster–Lighter Spread Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="spread-agent-count">0 monitors</span>
          </div>
        </div>
        <div class="section-header-controls">
          <label class="spread-selector-label hidden" id="spread-agent-label">
            Monitor
            <select id="spread-agent-select"></select>
          </label>
        </div>
      </div>
      <p class="empty" id="spread-empty">Waiting for spread data…</p>
      <div class="spread-card hidden" id="spread-card">
        <div class="spread-meta">
          <span id="spread-instrument">Instrument —</span>
          <span id="spread-updated">Updated —</span>
        </div>
        <div class="spread-chart-wrapper hidden" id="spread-chart-wrapper">
          <canvas id="spread-chart"></canvas>
        </div>
        <div class="spread-table-wrapper">
          <table class="spread-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Aster Bid</th>
                <th>Aster Ask</th>
                <th>Lighter Bid</th>
                <th>Lighter Ask</th>
                <th>AsterBid - LighterAsk</th>
                <th>LighterBid - AsterAsk</th>
                <th>Mid Δ</th>
              </tr>
            </thead>
            <tbody id="spread-table-body"></tbody>
          </table>
        </div>
      </div>
    </section>

    <p class="updated" id="updated">Awaiting data…</p>

    <script>
    const agentGrid = document.getElementById('agent-grid');
    const agentEmpty = document.getElementById('agent-empty');
    const agentCount = document.getElementById('agent-count');
    const updatedElement = document.getElementById('updated');
    const defaultPauseIndicator = document.getElementById('default-pause-indicator');
    const pauseAllButton = document.getElementById('pause-all');
    const resumeAllButton = document.getElementById('resume-all');
    const runtimeElement = document.getElementById('runtime');
  const grvtAccountCount = document.getElementById('grvt-account-count');
  const grvtEmpty = document.getElementById('grvt-empty');
  const grvtCard = document.getElementById('grvt-card');
  const grvtTotalPnl = document.getElementById('grvt-total-pnl');
  const grvtEthPnl = document.getElementById('grvt-eth-pnl');
  const grvtBtcPnl = document.getElementById('grvt-btc-pnl');
  const grvtTotalEquity = document.getElementById('grvt-total-equity');
  const grvtWalletBalance = document.getElementById('grvt-wallet-balance');
  const grvtRiskLevel = document.getElementById('grvt-risk-level');
  const grvtRiskDetail = document.getElementById('grvt-risk-detail');
  const grvtSummaryTime = document.getElementById('grvt-summary-time');
  const grvtSummaryUpdated = document.getElementById('grvt-summary-updated');
  const grvtAccountGrid = document.getElementById('grvt-account-grid');
  const grvtAccountsEmpty = document.getElementById('grvt-accounts-empty');
  const grvtAdjustPanel = document.getElementById('grvt-adjust-panel');
  const grvtAdjustSizeInput = document.getElementById('grvt-adjust-size');
  const grvtAdjustSymbolsSelect = document.getElementById('grvt-adjust-symbols');
  const grvtResetSymbolButton = document.getElementById('grvt-reset-symbol');
  const grvtAdjustAddButton = document.getElementById('grvt-adjust-add');
  const grvtAdjustReduceButton = document.getElementById('grvt-adjust-reduce');
  const grvtAdjustStatus = document.getElementById('grvt-adjust-status');
  const grvtAdjustHistoryBody = document.getElementById('grvt-adjust-history');
  const grvtTransferPanel = document.getElementById('grvt-transfer-panel');
  const grvtTransferAgentSelect = document.getElementById('grvt-transfer-agent');
  const grvtTransferDirectionSelect = document.getElementById('grvt-transfer-direction');
  const grvtTransferAmountInput = document.getElementById('grvt-transfer-amount');
  const grvtTransferCurrencyInput = document.getElementById('grvt-transfer-currency');
  const grvtTransferTypeInput = document.getElementById('grvt-transfer-type');
  const grvtTransferReasonInput = document.getElementById('grvt-transfer-reason');
  const grvtTransferFromAccountInput = document.getElementById('grvt-transfer-from-account');
  const grvtTransferFromSubInput = document.getElementById('grvt-transfer-from-sub');
  const grvtTransferToAccountInput = document.getElementById('grvt-transfer-to-account');
  const grvtTransferToSubInput = document.getElementById('grvt-transfer-to-sub');
  const grvtTransferSubmitButton = document.getElementById('grvt-transfer-submit');
  const grvtTransferStatus = document.getElementById('grvt-transfer-status');
  const grvtTransferHistoryBody = document.getElementById('grvt-transfer-history');
    const spreadAgentCount = document.getElementById('spread-agent-count');
    const spreadAgentLabel = document.getElementById('spread-agent-label');
    const spreadAgentSelect = document.getElementById('spread-agent-select');
    const spreadEmpty = document.getElementById('spread-empty');
    const spreadCard = document.getElementById('spread-card');
    const spreadTableBody = document.getElementById('spread-table-body');
    const spreadInstrument = document.getElementById('spread-instrument');
    const spreadUpdated = document.getElementById('spread-updated');
  const spreadChartWrapper = document.getElementById('spread-chart-wrapper');
  const spreadChartCanvas = document.getElementById('spread-chart');
    const strategyAgentCount = document.getElementById('strategy-agent-count');
    const strategyAgentLabel = document.getElementById('strategy-agent-label');
    const strategyAgentSelect = document.getElementById('strategy-agent-select');
    const strategyEmpty = document.getElementById('strategy-empty');
    const strategyCard = document.getElementById('strategy-card');
    const strategyNetPnl = document.getElementById('strategy-net-pnl');
    const strategyTradeCount = document.getElementById('strategy-trade-count');
  const strategyTotalVolume = document.getElementById('strategy-total-volume');
  const strategyPnlRatio = document.getElementById('strategy-pnl-ratio');
    const strategyOpenPosition = document.getElementById('strategy-open-position');
    const strategyOpenDetails = document.getElementById('strategy-open-details');
    const strategyLastDecision = document.getElementById('strategy-last-decision');
    const strategyLastDecisionTime = document.getElementById('strategy-last-decision-time');
    const strategyEventsBody = document.getElementById('strategy-events-body');
  const MAX_SPREAD_HISTORY_POINTS = 1800;
    const MAX_STRATEGY_EVENTS = 120;
  const MAX_GRVT_POSITIONS = 12;
  const RISK_GRADIENTS = [
    {
      max: 0.1,
      label: 'low',
      gradient: 'linear-gradient(135deg, #34e89e, #0f9d58)',
      color: '#041b11',
      shadow: '0 8px 18px rgba(15, 157, 88, 0.35)'
    },
    {
      max: 0.25,
      label: 'guarded',
      gradient: 'linear-gradient(135deg, #f9f871, #f7b267)',
      color: '#2b1d02',
      shadow: '0 8px 18px rgba(247, 178, 103, 0.35)'
    },
    {
      max: 0.5,
      label: 'elevated',
      gradient: 'linear-gradient(135deg, #f79d65, #f05a28)',
      color: '#2a0a02',
      shadow: '0 8px 18px rgba(240, 90, 40, 0.35)'
    },
    {
      max: Infinity,
      label: 'critical',
      gradient: 'linear-gradient(135deg, #ff4e50, #c81d25)',
      color: '#ffeef2',
      shadow: '0 8px 18px rgba(200, 29, 37, 0.4)'
    }
  ];
  const DEFAULT_MARGIN_SCHEDULE = [
    { maxNotional: 600000, initial: 0.02, maintenance: 0.01 },
    { maxNotional: 1600000, initial: 0.04, maintenance: 0.02 },
    { maxNotional: 4000000, initial: 0.05, maintenance: 0.025 },
    { maxNotional: 10000000, initial: 0.1, maintenance: 0.05 },
    { maxNotional: 20000000, initial: 0.2, maintenance: 0.1 },
    { maxNotional: 50000000, initial: 0.25, maintenance: 0.125 },
    { maxNotional: 80000000, initial: 0.3333, maintenance: 0.1667 },
    { maxNotional: 101000000, initial: 0.5, maintenance: 0.25 },
    { maxNotional: Infinity, initial: 1, maintenance: 0.5 }
  ];
  const MARGIN_SCHEDULES = {
    BTC: DEFAULT_MARGIN_SCHEDULE,
    ETH: DEFAULT_MARGIN_SCHEDULE,
  };
      let batchBusy = false;
      let lastDefaultPaused = false;
      let selectedSpreadAgent = null;
      let lastSpreadOptionsKey = '';
      let selectedStrategyAgent = null;
      let lastStrategyOptionsKey = '';
      let lastMetricsSnapshot = null;
  let grvtAdjustLocked = false;
  let grvtPendingRequestId = null;
  let grvtTransferLocked = false;
  let grvtTransferOptionsKey = '';
  const grvtTransferDefaults = new Map();

      const numberFormatter = new Intl.NumberFormat(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 6,
        notation: 'compact'
      });

      function toNumber(value) {
        if (value === null || value === undefined) {
          return 0;
        }
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : 0;
      }

      function parseDecimal(value) {
        if (value === null || value === undefined) {
          return null;
        }
        if (typeof value === 'number') {
          return Number.isFinite(value) ? value : null;
        }
        const normalized = String(value).replace(/,/g, '').trim();
        if (!normalized || normalized === '--') {
          return null;
        }
        const numeric = Number(normalized);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function computePercent(numerator, denominator) {
        if (!Number.isFinite(numerator) || !Number.isFinite(denominator) || Math.abs(denominator) < 1e-12) {
          return null;
        }
        return (numerator / denominator) * 100;
      }

      function formatPercent(value, digits = 2) {
        if (!Number.isFinite(value)) {
          return '—';
        }
        return `${value.toFixed(digits)}%`;
      }

      function getSeriesBounds(...seriesList) {
        let min = Infinity;
        let max = -Infinity;
        let hasValue = false;

        for (const series of seriesList) {
          for (const value of series) {
            if (!Number.isFinite(value)) {
              continue;
            }
            hasValue = true;
            if (value < min) {
              min = value;
            }
            if (value > max) {
              max = value;
            }
          }
        }

        if (!hasValue) {
          return { hasValue: false, min: 0, max: 0 };
        }

        if (min === max) {
          const epsilon = Math.abs(min) > 0 ? Math.abs(min) * 0.05 : 0.05;
          min -= epsilon;
          max += epsilon;
        }

        const padding = (max - min) * 0.08;
        return {
          hasValue: true,
          min: min - padding,
          max: max + padding,
        };
      }

      function prepareCanvas(canvas) {
        if (!canvas) {
          return null;
        }

        const rect = canvas.getBoundingClientRect();
        const width = rect.width || canvas.parentElement?.clientWidth || 600;
        const height = rect.height || 260;
        const dpr = window.devicePixelRatio || 1;

        canvas.width = width * dpr;
        canvas.height = height * dpr;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          return null;
        }

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        return { ctx, width, height };
      }

      function drawSeries(ctx, values, mapX, mapY, color) {
        ctx.beginPath();
        let started = false;
        for (let index = 0; index < values.length; index += 1) {
          const value = values[index];
          if (!Number.isFinite(value)) {
            started = false;
            continue;
          }

          const x = mapX(index);
          const y = mapY(value);
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        }

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function renderSpreadCanvas(labels, seriesA, seriesB) {
        if (!spreadChartCanvas || !spreadChartWrapper) {
          return;
        }

        const bounds = getSeriesBounds(seriesA, seriesB);
        if (!bounds.hasValue) {
          spreadChartWrapper.classList.add('hidden');
          return;
        }

        const layout = { top: 56, right: 28, bottom: 52, left: 88 };
        spreadChartCanvas.style.width = '100%';

        const setup = prepareCanvas(spreadChartCanvas);
        if (!setup) {
          spreadChartWrapper.classList.add('hidden');
          return;
        }

        const { ctx, width, height } = setup;
        const innerWidth = Math.max(10, width - layout.left - layout.right);
        const innerHeight = Math.max(10, height - layout.top - layout.bottom);
        const { min, max } = bounds;
        const range = max - min || 1;

        const mapX = (index) => {
          if (labels.length <= 1) {
            return layout.left + innerWidth / 2;
          }
          return layout.left + (index / (labels.length - 1)) * innerWidth;
        };

        const mapY = (value) => {
          const ratio = (value - min) / range;
          return layout.top + (1 - ratio) * innerHeight;
        };

        ctx.fillStyle = '#1b1d24';
        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
        ctx.lineWidth = 1;
        const horizontalLines = 5;
        for (let i = 0; i <= horizontalLines; i += 1) {
          const value = min + (range * i) / horizontalLines;
          const y = mapY(value);
          ctx.beginPath();
          ctx.moveTo(layout.left, y);
          ctx.lineTo(width - layout.right, y);
          ctx.stroke();
        }

        ctx.font = '12px "Segoe UI", system-ui';
        ctx.fillStyle = '#8a94a6';
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'right';
        const yTicks = 4;
        for (let i = 0; i <= yTicks; i += 1) {
          const value = min + (range * i) / yTicks;
          const y = mapY(value);
          ctx.fillText(formatPercent(value, 2), layout.left - 12, y);
        }

        if (min < 0 && max > 0) {
          const zeroY = mapY(0);
          ctx.strokeStyle = 'rgba(199, 210, 232, 0.4)';
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.moveTo(layout.left, zeroY);
          ctx.lineTo(width - layout.right, zeroY);
          ctx.stroke();
        }

        drawSeries(ctx, seriesA, mapX, mapY, 'rgba(99, 156, 255, 1)');
        drawSeries(ctx, seriesB, mapX, mapY, 'rgba(255, 160, 86, 1)');

        ctx.font = '13px "Segoe UI", system-ui';
        const legendEntries = [
          { label: 'Aster bid – Lighter ask', color: 'rgba(99, 156, 255, 1)' },
          { label: 'Lighter bid – Aster ask', color: 'rgba(255, 160, 86, 1)' }
        ];
        let legendTextWidth = 0;
        for (const entry of legendEntries) {
          legendTextWidth = Math.max(legendTextWidth, ctx.measureText(entry.label).width);
        }
        const legendPaddingX = 14;
        const legendPaddingY = 10;
        const legendItemHeight = 22;
        const legendHeight = legendEntries.length * legendItemHeight + legendPaddingY * 2;
        const legendWidth = legendTextWidth + legendPaddingX * 2 + 24;
        let legendX = width - layout.right - legendWidth;
        let legendY = layout.top - legendHeight - 12;
        if (legendY < 8) {
          legendY = layout.top + 8;
        }

        ctx.fillStyle = 'rgba(17, 19, 27, 0.9)';
        ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);

        let legendCursorY = legendY + legendPaddingY + legendItemHeight / 2;
        for (const entry of legendEntries) {
          ctx.fillStyle = entry.color;
          ctx.beginPath();
          ctx.arc(legendX + legendPaddingX, legendCursorY, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#c7d2e8';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText(entry.label, legendX + legendPaddingX + 14, legendCursorY);
          legendCursorY += legendItemHeight;
        }

        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillStyle = '#8a94a6';
        const minLabelGap = 96;
        const labelIndexes = [];
        let lastLabelX = -Infinity;
        for (let i = 0; i < labels.length; i += 1) {
          const x = mapX(i);
          if (!Number.isFinite(x)) {
            continue;
          }
          if (labelIndexes.length === 0 || x - lastLabelX >= minLabelGap || i === labels.length - 1) {
            labelIndexes.push(i);
            lastLabelX = x;
          }
        }

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        const bottomY = height - layout.bottom;
        for (const index of labelIndexes) {
          const x = mapX(index);
          ctx.beginPath();
          ctx.moveTo(x, layout.top);
          ctx.lineTo(x, bottomY);
          ctx.stroke();
          ctx.fillText(labels[index] ?? '', x, bottomY + 8);
        }
      }

      function escapeHtml(value) {
        return String(value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function formatDecimal(value, fractionDigits = 4) {
        if (value === null || value === undefined) {
          return '--';
        }
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed || trimmed === '--' || trimmed.toLowerCase() === 'none') {
            return '--';
          }
          value = trimmed.replace(/,/g, '');
        }
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return '--';
        }
        return numeric.toFixed(fractionDigits);
      }

      function formatDuration(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) {
          return '0s';
        }

        let remaining = Math.round(seconds);
        if (remaining <= 0) {
          remaining = 1;
        }

        const units = [
          { label: 'd', value: 86400 },
          { label: 'h', value: 3600 },
          { label: 'm', value: 60 },
          { label: 's', value: 1 }
        ];

        const parts = [];
        for (const unit of units) {
          if (remaining < unit.value && parts.length === 0 && unit.label !== 's') {
            continue;
          }

          const amount = Math.floor(remaining / unit.value);
          if (amount > 0 || (unit.label === 's' && parts.length === 0)) {
            parts.push(`${amount}${unit.label}`);
          }
          remaining %= unit.value;

          if (parts.length >= 3) {
            break;
          }
        }

        return parts.join(' ');
      }

      function formatTimestamp(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) {
          return null;
        }
        return new Date(seconds * 1000).toLocaleString();
      }

      function describeAdjustmentAction(action) {
        if (!action) {
          return '—';
        }
        const normalized = String(action).trim().toLowerCase();
        if (normalized === 'add') {
          return '加仓';
        }
        if (normalized === 'reduce') {
          return '减仓';
        }
        if (normalized === 'transfer') {
          return '转账';
        }
        return normalized;
      }

      function normalizeSymbolLabel(value) {
        if (value === null || value === undefined) {
          return '';
        }
        const text = String(value).trim();
        if (!text) {
          return '';
        }
        return text.toUpperCase();
      }

      function describeSymbolScope(symbols) {
        if (!Array.isArray(symbols)) {
          return '全部';
        }
        const normalized = symbols
          .map((symbol) => normalizeSymbolLabel(symbol))
          .filter(Boolean);
        if (!normalized.length) {
          return '全部';
        }
        return normalized.join(', ');
      }

      function describeTransferDirection(direction) {
        if (!direction) {
          return '—';
        }
        const normalized = String(direction).trim().toLowerCase();
        if (normalized === 'main_to_sub') {
          return '主账户 → 子账户';
        }
        if (normalized === 'sub_to_main') {
          return '子账户 → 主账户';
        }
        return normalized;
      }

      function formatTransferRoute(payload) {
        if (!payload) {
          return '—';
        }
        const fromAccount = payload.from_account_id || payload.from_account || payload.from || '';
        const fromSub = payload.from_sub_account_id ?? payload.from_sub_account ?? '';
        const toAccount = payload.to_account_id || payload.to_account || payload.to || '';
        const toSub = payload.to_sub_account_id ?? payload.to_sub_account ?? '';
        const formatSide = (account, sub) => {
          if (!account && !sub) {
            return '?';
          }
          if (!sub) {
            return account || '?';
          }
          return `${account || '?'} (#${sub})`;
        };
        return `${formatSide(fromAccount, fromSub)} → ${formatSide(toAccount, toSub)}`;
      }

      function getInputValue(element) {
        if (!element) {
          return '';
        }
        return String(element.value ?? '').trim();
      }

      function setInputValue(element, value, { force = false } = {}) {
        if (!element) {
          return;
        }
        if (!force && element.value) {
          return;
        }
        element.value = value ?? '';
      }

      function buildTransferRouteFromDefaults(defaults, direction) {
        if (!defaults) {
          return null;
        }
        const normalizedDirection = String(direction || defaults.direction || 'sub_to_main').toLowerCase();
        if (defaults.routes && typeof defaults.routes === 'object') {
          const fromRoutes = defaults.routes[normalizedDirection];
          if (fromRoutes && typeof fromRoutes === 'object') {
            return fromRoutes;
          }
        }
        const normalize = (value) => {
          if (value === null || value === undefined) {
            return '';
          }
          return String(value).trim();
        };
        const mainAccount = normalize(defaults.main_account_id || defaults.from_account_id);
        const tradingSub = normalize(defaults.sub_account_id || defaults.to_sub_account_id);
        const mainSub = normalize(defaults.main_sub_account_id || defaults.to_sub_account_id || '0') || '0';
        if (!mainAccount) {
          return null;
        }
        if (normalizedDirection === 'sub_to_main') {
          if (!tradingSub) {
            return null;
          }
          return {
            from_account_id: mainAccount,
            from_sub_account_id: tradingSub,
            to_account_id: mainAccount,
            to_sub_account_id: mainSub,
          };
        }
        if (normalizedDirection === 'main_to_sub') {
          if (!tradingSub) {
            return null;
          }
          return {
            from_account_id: mainAccount,
            from_sub_account_id: mainSub,
            to_account_id: mainAccount,
            to_sub_account_id: tradingSub,
          };
        }
        return null;
      }

      function setGrvtTransferStatus(message) {
        if (grvtTransferStatus) {
          grvtTransferStatus.textContent = message || '等待指令…';
        }
      }

      function updateGrvtTransferButtons() {
        if (!grvtTransferSubmitButton) {
          return;
        }
        const hasAgent = Boolean(grvtTransferAgentSelect?.value);
        grvtTransferSubmitButton.disabled = grvtTransferLocked || !hasAgent;
      }

      function updateGrvtTransferAgents(options) {
        if (!grvtTransferPanel || !grvtTransferAgentSelect) {
          return;
        }
        const normalized = Array.isArray(options)
          ? options
              .map((option) => {
                const agentId = option?.agentId || option?.agent || option?.id || '';
                if (!agentId) {
                  return null;
                }
                const label = option?.label || option?.name || agentId;
                const defaults = option?.defaults && typeof option.defaults === 'object' ? option.defaults : {};
                return { agentId, label, defaults };
              })
              .filter(Boolean)
          : [];

        if (!normalized.length) {
          grvtTransferPanel.classList.add('hidden');
          grvtTransferAgentSelect.innerHTML = '';
          grvtTransferDefaults.clear();
          grvtTransferLocked = false;
          grvtTransferOptionsKey = '';
          setGrvtTransferStatus('等待 VPS 提供转账参数…');
          updateGrvtTransferButtons();
          return;
        }

        const optionsKey = normalized
          .map((option) => `${option.agentId}:${JSON.stringify(option.defaults || {})}`)
          .join('|');
        const shouldRebuild = optionsKey !== grvtTransferOptionsKey || grvtTransferAgentSelect.options.length !== normalized.length;
        grvtTransferDefaults.clear();
        for (const option of normalized) {
          grvtTransferDefaults.set(option.agentId, option.defaults || {});
        }
        grvtTransferPanel.classList.remove('hidden');

        if (!shouldRebuild) {
          updateGrvtTransferButtons();
          return;
        }

        grvtTransferOptionsKey = optionsKey;
        const previousValue = grvtTransferAgentSelect.value;
        grvtTransferAgentSelect.innerHTML = '';
        for (const option of normalized) {
          const element = document.createElement('option');
          element.value = option.agentId;
          element.textContent = option.label;
          grvtTransferAgentSelect.appendChild(element);
        }
        if (previousValue && normalized.some((option) => option.agentId === previousValue)) {
          grvtTransferAgentSelect.value = previousValue;
        } else if (grvtTransferAgentSelect.options.length) {
          grvtTransferAgentSelect.selectedIndex = 0;
        }
        const selectedAgent = grvtTransferAgentSelect.value;
        if (selectedAgent) {
          applyGrvtTransferDefaults(selectedAgent, { forceAll: true });
        }
        updateGrvtTransferButtons();
      }

      function applyGrvtTransferDefaults(agentId, { forceAll = false } = {}) {
        if (!agentId) {
          updateGrvtTransferButtons();
          return;
        }
        const defaults = grvtTransferDefaults.get(agentId) || {};
        const directionValue = String(defaults.direction || 'sub_to_main').toLowerCase();
        if (grvtTransferDirectionSelect && (forceAll || !grvtTransferDirectionSelect.value)) {
          grvtTransferDirectionSelect.value = directionValue;
        }
        if (grvtTransferCurrencyInput && (forceAll || !grvtTransferCurrencyInput.value)) {
          grvtTransferCurrencyInput.value = (defaults.currency || 'USDT').toUpperCase();
        }
        if (grvtTransferTypeInput && (forceAll || !grvtTransferTypeInput.value)) {
          grvtTransferTypeInput.value = defaults.transfer_type || 'spot';
        }
        updateGrvtTransferRoute(agentId, { force: true });
        updateGrvtTransferButtons();
      }

      function updateGrvtTransferRoute(agentId, { force = false } = {}) {
        if (!agentId) {
          return;
        }
        const defaults = grvtTransferDefaults.get(agentId) || {};
        const direction = String(grvtTransferDirectionSelect?.value || defaults.direction || 'sub_to_main').toLowerCase();
        let route = null;
        if (defaults.routes && defaults.routes[direction]) {
          route = defaults.routes[direction];
        } else {
          route = buildTransferRouteFromDefaults(defaults, direction);
        }
        const fallbackFromAccount = route?.from_account_id || defaults.main_account_id || defaults.from_account_id || '';
        const fallbackFromSub = route?.from_sub_account_id || defaults.sub_account_id || defaults.from_sub_account_id || '';
        const fallbackToAccount = route?.to_account_id || defaults.main_account_id || defaults.to_account_id || '';
        const fallbackToSub = route?.to_sub_account_id || defaults.main_sub_account_id || defaults.to_sub_account_id || '';
        setInputValue(grvtTransferFromAccountInput, fallbackFromAccount, { force });
        setInputValue(grvtTransferFromSubInput, fallbackFromSub, { force });
        setInputValue(grvtTransferToAccountInput, fallbackToAccount, { force });
        setInputValue(grvtTransferToSubInput, fallbackToSub, { force });
      }

      async function sendGrvtTransfer() {
        if (grvtTransferLocked) {
          return;
        }
        const agentId = grvtTransferAgentSelect?.value;
        if (!agentId) {
          setGrvtTransferStatus('请选择 VPS 节点');
          return;
        }
        const amountValue = parseFloat(getInputValue(grvtTransferAmountInput) || '0');
        if (!Number.isFinite(amountValue) || amountValue <= 0) {
          setGrvtTransferStatus('请输入合法的数量');
          return;
        }
        const currencyValue = (getInputValue(grvtTransferCurrencyInput) || 'USDT').toUpperCase();
        const payload = {
          agent_ids: [agentId],
          num_tokens: amountValue,
          currency: currencyValue,
          direction: (grvtTransferDirectionSelect?.value || 'sub_to_main').toLowerCase(),
          from_account_id: getInputValue(grvtTransferFromAccountInput),
          from_sub_account_id: getInputValue(grvtTransferFromSubInput),
          to_account_id: getInputValue(grvtTransferToAccountInput),
          to_sub_account_id: getInputValue(grvtTransferToSubInput),
          transfer_type: getInputValue(grvtTransferTypeInput) || undefined,
        };

        const missing = Object.entries({
          from_account_id: payload.from_account_id,
          from_sub_account_id: payload.from_sub_account_id,
          to_account_id: payload.to_account_id,
          to_sub_account_id: payload.to_sub_account_id,
        })
          .filter(([, value]) => !value)
          .map(([key]) => key);
        if (missing.length) {
          setGrvtTransferStatus(`缺少字段：${missing.join(', ')}`);
          return;
        }

        if (!payload.transfer_type) {
          delete payload.transfer_type;
        }

        const reason = getInputValue(grvtTransferReasonInput);
        if (reason) {
          payload.reason = reason;
        }

        grvtTransferLocked = true;
        updateGrvtTransferButtons();
        setGrvtTransferStatus('提交转账请求…');
        try {
          const response = await fetch('/grvt/transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          setGrvtTransferStatus('等待 VPS ACK…');
          await refreshMetrics();
        } catch (error) {
          grvtTransferLocked = false;
          updateGrvtTransferButtons();
          setGrvtTransferStatus(`请求失败：${error}`);
        }
      }

      function renderGrvtTransferHistory(summary) {
        if (!grvtTransferHistoryBody) {
          return;
        }
        const requests = Array.isArray(summary?.requests)
          ? summary.requests.filter((request) => (request?.action || '').toLowerCase() === 'transfer')
          : [];
        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const pendingStatuses = ['pending', 'in_progress'];
        let locked = false;
        let statusMessage = '等待指令…';

        const active = summary?.active_request;
        const activeIsTransfer = (active?.action || '').toLowerCase() === 'transfer' && pendingStatuses.includes(normalizeStatus(active?.overall_status));
        const pendingCandidate = activeIsTransfer ? active : requests.find((request) => pendingStatuses.includes(normalizeStatus(request.overall_status)));
        if (pendingCandidate) {
          locked = true;
          const targetAgents = Array.isArray(pendingCandidate.target_agents) ? pendingCandidate.target_agents.join(', ') : 'VPS';
          statusMessage = `等待 ${targetAgents || 'VPS'} ACK…`;
        } else if (requests.length) {
          const latest = requests[0];
          const latestStatus = normalizeStatus(latest.overall_status);
          const payload = latest?.payload || {};
          const directionText = describeTransferDirection(payload.direction || latest?.direction);
          if (latestStatus === 'completed' || latestStatus === 'acknowledged') {
            statusMessage = `最近一次 ${directionText} 已完成`;
          } else if (latestStatus === 'failed') {
            statusMessage = `最近一次 ${directionText} 部分失败`;
          } else if (latestStatus) {
            statusMessage = `最近状态：${latestStatus}`;
          }
        }

        grvtTransferLocked = locked;
        setGrvtTransferStatus(statusMessage);
        updateGrvtTransferButtons();

        if (!requests.length) {
          grvtTransferHistoryBody.innerHTML = '<tr><td colspan="6">暂无转账记录</td></tr>';
          return;
        }

        const rows = [];
        for (const request of requests.slice(0, 6)) {
          const createdText = formatTimestamp(request.created_at) ?? '--';
          const payload = request.payload || {};
          const agents = Array.isArray(request.target_agents) ? request.target_agents.join(', ') : '—';
          const amountValue = `${numberFormatter.format(toNumber(payload.num_tokens ?? request.magnitude ?? 0))} ${(payload.currency || 'USDT').toUpperCase()}`;
          const routeText = formatTransferRoute(payload);
          const statusText = request.overall_status || 'pending';
          const reasonText = payload?.transfer_metadata?.reason || payload.reason || '';
          const directionText = describeTransferDirection(payload.direction || payload?.transfer_metadata?.direction || request.direction);
          const noteText = reasonText ? `${statusText} / ${reasonText}` : statusText;
          rows.push(`
            <tr>
              <td>${escapeHtml(createdText)}</td>
              <td>${escapeHtml(agents || '—')}</td>
              <td>${escapeHtml(directionText)}</td>
              <td>${escapeHtml(amountValue)}</td>
              <td>${escapeHtml(routeText)}</td>
              <td>${escapeHtml(noteText)}</td>
            </tr>
          `);
        }

        grvtTransferHistoryBody.innerHTML = rows.join('');
      }

      function extractBaseAsset(symbol) {
        if (!symbol) {
          return null;
        }
        let text = normalizeSymbolLabel(symbol);
        if (!text) {
          return null;
        }
        text = text.replace(/[:_\-\s]+/g, '/');
        const parts = text.split('/').filter(Boolean);
        let candidate = parts.length ? parts[0] : text;
        const suffixes = ['PERP', 'FUTURES', 'FUT', 'USD', 'USDT', 'USDC'];
        let stripped = true;
        while (stripped && candidate.length > 0) {
          stripped = false;
          for (const suffix of suffixes) {
            if (candidate.endsWith(suffix) && candidate.length > suffix.length) {
              candidate = candidate.slice(0, -suffix.length);
              stripped = true;
              break;
            }
          }
        }
        const match = candidate.match(/[A-Z]+/);
        return match ? match[0] : null;
      }

      function resolveMarginTier(baseAsset, notionalValue) {
        if (!baseAsset || !Number.isFinite(notionalValue) || notionalValue <= 0) {
          return null;
        }
        const schedule = MARGIN_SCHEDULES[baseAsset];
        if (!schedule || !schedule.length) {
          return null;
        }
        for (const tier of schedule) {
          if (notionalValue <= tier.maxNotional) {
            return tier;
          }
        }
        return schedule[schedule.length - 1] ?? null;
      }

      function computePositionMargin(position) {
        if (!position) {
          return null;
        }
        const size = parseDecimal(position.net_size);
        let price = parseDecimal(position.mark_price);
        if (!Number.isFinite(price)) {
          price = parseDecimal(position.entry_price);
        }
        if (!Number.isFinite(size) || !Number.isFinite(price)) {
          return null;
        }
        const notional = Math.abs(size * price);
        if (!Number.isFinite(notional) || notional <= 0) {
          return null;
        }
        const baseAsset = extractBaseAsset(position.symbol);
        const tier = resolveMarginTier(baseAsset, notional);
        if (!tier) {
          return { baseAsset, notional };
        }
        return {
          baseAsset,
          notional,
          initialMargin: notional * tier.initial,
          maintenanceMargin: notional * tier.maintenance,
          initialRate: tier.initial,
          maintenanceRate: tier.maintenance,
        };
      }

      function updateGrvtSymbolOptions(symbols) {
        if (!grvtAdjustSymbolsSelect) {
          return;
        }
        const normalized = Array.from(
          new Set((Array.isArray(symbols) ? symbols : []).map((symbol) => normalizeSymbolLabel(symbol)).filter(Boolean))
        ).sort();
        const previousValue = normalizeSymbolLabel(grvtAdjustSymbolsSelect.value);
        grvtAdjustSymbolsSelect.innerHTML = '';
        grvtAdjustSymbolsSelect.disabled = normalized.length === 0;
        if (grvtResetSymbolButton) {
          grvtResetSymbolButton.disabled = normalized.length === 0;
        }
        let matched = false;
        for (const symbol of normalized) {
          const option = document.createElement('option');
          option.value = symbol;
          option.textContent = symbol;
          if (previousValue === symbol) {
            option.selected = true;
            matched = true;
          }
          grvtAdjustSymbolsSelect.appendChild(option);
        }

        if (!matched) {
          grvtAdjustSymbolsSelect.selectedIndex = -1;
        }
      }

      function getSelectedGrvtSymbols() {
        if (!grvtAdjustSymbolsSelect) {
          return null;
        }
        const value = grvtAdjustSymbolsSelect.value;
        if (!value) {
          return null;
        }
        return [value];
      }

      function clearGrvtSymbolSelection() {
        if (!grvtAdjustSymbolsSelect) {
          return;
        }
        grvtAdjustSymbolsSelect.value = '';
        grvtAdjustSymbolsSelect.selectedIndex = -1;
      }

      function updateGrvtAdjustButtons() {
        const disabled = grvtAdjustLocked;
        [grvtAdjustAddButton, grvtAdjustReduceButton].forEach((button) => {
          if (button) {
            button.disabled = disabled;
          }
        });
      }

      async function sendGrvtAdjustment(action) {
        if (!action || grvtAdjustLocked) {
          return;
        }
        const rawMagnitude = parseFloat(grvtAdjustSizeInput?.value ?? '1');
        const magnitude = Number.isFinite(rawMagnitude) && rawMagnitude > 0 ? rawMagnitude : 1;
        grvtAdjustLocked = true;
        updateGrvtAdjustButtons();
        if (grvtAdjustStatus) {
          grvtAdjustStatus.textContent = `提交${describeAdjustmentAction(action)}请求…`;
        }

        const payload = { action, magnitude };
        const selectedSymbols = getSelectedGrvtSymbols();
        if (selectedSymbols) {
          payload.symbols = selectedSymbols;
        }

        try {
          const response = await fetch('/grvt/adjust', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const responsePayload = await response.json();
          grvtPendingRequestId = responsePayload?.request?.request_id ?? null;
          if (grvtAdjustStatus) {
            grvtAdjustStatus.textContent = '等待 VPS ACK…';
          }
          await refreshMetrics();
        } catch (error) {
          grvtAdjustLocked = false;
          updateGrvtAdjustButtons();
          if (grvtAdjustStatus) {
            grvtAdjustStatus.textContent = `请求失败：${error}`;
          }
        }
      }

      function renderGrvtAdjustments(summary) {
        if (!grvtAdjustPanel || !grvtAdjustHistoryBody) {
          return;
        }
        const allRequests = Array.isArray(summary?.requests) ? summary.requests : [];
        const adjustmentRequests = allRequests.filter((request) => (request?.action || '').toLowerCase() !== 'transfer');
        const active = summary?.active_request;
        const activeIsAdjustment = (active?.action || '').toLowerCase() !== 'transfer';
        const effectiveActive = activeIsAdjustment ? active : null;
        let locked = false;

        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const scopeFor = (request) => describeSymbolScope(request?.target_symbols ?? request?.symbols);

        if (effectiveActive && ['pending', 'in_progress'].includes(normalizeStatus(effectiveActive.overall_status))) {
            locked = true;
            grvtPendingRequestId = effectiveActive.request_id || null;
            const agents = Array.isArray(effectiveActive.agents) ? effectiveActive.agents : [];
            const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
            if (grvtAdjustStatus) {
              const total = agents.length || 0;
              const pendingCount = pendingAgents.length;
              const scopeText = scopeFor(effectiveActive);
              grvtAdjustStatus.textContent = `等待 ${pendingCount}/${total || '-'} 个 VPS ACK（${scopeText}）`;
            }
        } else if (adjustmentRequests.length) {
          const latest = adjustmentRequests[0];
          const statusText = normalizeStatus(latest.overall_status || 'pending');
          if (['pending', 'in_progress'].includes(statusText)) {
            locked = true;
            grvtPendingRequestId = latest.request_id || null;
            const agents = Array.isArray(latest.agents) ? latest.agents : [];
            const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
            if (grvtAdjustStatus) {
              const scopeText = scopeFor(latest);
              grvtAdjustStatus.textContent = `等待 ${pendingAgents.length}/${agents.length || '-'} 个 VPS ACK（${scopeText}）`;
            }
          } else if (grvtAdjustStatus) {
            const scopeText = scopeFor(latest);
            if (statusText === 'completed') {
              grvtAdjustStatus.textContent = `最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）已完成`;
            } else if (statusText === 'failed') {
              grvtAdjustStatus.textContent = `最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）部分失败`;
            } else {
              grvtAdjustStatus.textContent = `最近状态：${statusText}（${scopeText}）`;
            }
          }
        } else if (grvtAdjustStatus) {
          grvtAdjustStatus.textContent = '等待指令…（默认全部币种）';
        }

        grvtAdjustLocked = locked;
        if (!locked) {
          grvtPendingRequestId = null;
        }
        updateGrvtAdjustButtons();

        if (!adjustmentRequests.length) {
          grvtAdjustHistoryBody.innerHTML = '<tr><td colspan="6">暂无广播记录</td></tr>';
        } else {
          const historyRows = [];
          for (const request of adjustmentRequests.slice(0, 6)) {
            const statusText = request.overall_status || 'pending';
            const createdText = formatTimestamp(request.created_at) ?? '--';
            const agents = Array.isArray(request.agents) ? request.agents : [];
            const scopeText = scopeFor(request);
            const badges = agents
              .map((agent) => {
                const status = normalizeStatus(agent.status || 'pending');
                const label = escapeHtml(agent.agent_id || 'agent');
                let icon = '⏳';
                if (status === 'acknowledged') {
                  icon = '✅';
                } else if (status === 'failed') {
                  icon = '⚠️';
                } else if (status === 'expired') {
                  icon = '⌛';
                }
                const cls = `adjust-badge status-${status}`;
                return `<span class="${cls}">${icon} ${label}</span>`;
              })
              .join(' ');

            historyRows.push(`
            <tr>
              <td>${escapeHtml(createdText)}</td>
              <td>${escapeHtml(describeAdjustmentAction(request.action))}</td>
              <td>${escapeHtml(numberFormatter.format(toNumber(request.magnitude ?? 0)))}</td>
              <td>${escapeHtml(scopeText)}</td>
              <td>${escapeHtml(statusText)}</td>
              <td>${badges || '—'}</td>
            </tr>
          `);
          }

          grvtAdjustHistoryBody.innerHTML = historyRows.join('');
        }
        renderGrvtTransferHistory(summary);
      }

      function computeRiskRatio(totalValue, balanceValue) {
        if (!Number.isFinite(totalValue) || totalValue >= 0) {
          return null;
        }
        if (!Number.isFinite(balanceValue) || balanceValue <= 0) {
          return null;
        }
        return Math.abs(totalValue) / balanceValue;
      }

      function resolveRiskBand(ratio) {
        if (!Number.isFinite(ratio) || ratio < 0) {
          return null;
        }
        for (const band of RISK_GRADIENTS) {
          if (ratio <= band.max) {
            return band;
          }
        }
        return RISK_GRADIENTS[RISK_GRADIENTS.length - 1];
      }

      function applyRiskTone(element, ratio, variant = 'summary') {
        if (!element) {
          return;
        }
        element.classList.add('risk-pill');
        element.classList.toggle('risk-pill-inline', variant === 'inline');
        element.classList.toggle('risk-pill-summary', variant === 'summary');
        if (!Number.isFinite(ratio) || ratio < 0) {
          element.style.removeProperty('background');
          element.style.removeProperty('color');
          element.style.removeProperty('box-shadow');
          element.dataset.riskLevel = 'unknown';
          return;
        }
        const band = resolveRiskBand(ratio) ?? RISK_GRADIENTS[RISK_GRADIENTS.length - 1];
        element.style.background = band.gradient;
        element.style.color = band.color;
        element.style.boxShadow = band.shadow;
        element.dataset.riskLevel = band.label;
      }

      function buildAccountSortKey(agentId, account, summary) {
        const safeAgent = (agentId ?? '').toString().toLowerCase();
        const accountIdentifiers = [
          account?.account_id,
          account?.id,
          account?.address,
          account?.name,
          summary?.account_id,
          summary?.address,
        ];
        let identifier = accountIdentifiers.find((value) => {
          if (value === null || value === undefined) {
            return false;
          }
          const text = String(value).trim();
          return text.length > 0;
        });
        if (identifier === undefined) {
          identifier = account ? 'account' : 'summary';
        }
        return `${safeAgent}::${String(identifier).toLowerCase()}`;
      }

      function renderGrvt(data) {
        if (!grvtAccountCount || !grvtEmpty || !grvtCard) {
          return;
        }

        const grvtMap = data?.grvt_accounts ?? {};
        const entries = Object.entries(grvtMap);
        const symbolCandidates = new Set();
        const instrumentList = Array.isArray(data?.instruments) ? data.instruments : [];
        for (const instrument of instrumentList) {
          const symbolText = normalizeSymbolLabel(instrument);
          if (symbolText) {
            symbolCandidates.add(symbolText);
          }
        }

        if (!entries.length) {
          grvtCard.classList.add('hidden');
          grvtEmpty.classList.remove('hidden');
          grvtAccountCount.textContent = '0 accounts';
          if (grvtTotalEquity) {
            grvtTotalEquity.textContent = '--';
          }
          if (grvtWalletBalance) {
            grvtWalletBalance.textContent = 'Wallet --';
          }
          if (grvtRiskLevel) {
            grvtRiskLevel.textContent = '--';
            applyRiskTone(grvtRiskLevel, null, 'summary');
          }
          if (grvtRiskDetail) {
            grvtRiskDetail.textContent = 'Awaiting data…';
          }
          if (grvtAccountGrid) {
            grvtAccountGrid.innerHTML = '';
          }
          if (grvtAccountsEmpty) {
            grvtAccountsEmpty.classList.add('hidden');
          }
          updateGrvtTransferAgents([]);
          updateGrvtSymbolOptions(Array.from(symbolCandidates));
          return;
        }

        grvtEmpty.classList.add('hidden');
        grvtCard.classList.remove('hidden');

        let aggregateAccountCount = 0;
        let aggregateTotalPnl = 0;
        let aggregateEthPnl = 0;
        let aggregateBtcPnl = 0;
        let latestUpdate = 0;
        let hasTotal = false;
        let hasEth = false;
        let hasBtc = false;
        const flattenedAccounts = [];
        const transferOptions = [];

        for (const [agentId, snapshot] of entries) {
          if (!snapshot) {
            continue;
          }

          const summary = snapshot.summary ?? {};
          const transferDefaults = snapshot.transfer_defaults && typeof snapshot.transfer_defaults === 'object'
            ? snapshot.transfer_defaults
            : {};
          const agentLabel = summary?.label || summary?.account_label || summary?.name || agentId;
          transferOptions.push({ agentId, label: agentLabel, defaults: transferDefaults });
          const accounts = Array.isArray(snapshot.accounts) ? snapshot.accounts : [];
          const snapshotTs = Number(summary.updated_at ?? snapshot.updated_at);
          if (Number.isFinite(snapshotTs) && snapshotTs > latestUpdate) {
            latestUpdate = snapshotTs;
          }

          const accountCountFallback = Number(summary.account_count ?? 0);
          if (accounts.length) {
            aggregateAccountCount += accounts.length;
          } else if (Number.isFinite(accountCountFallback) && accountCountFallback > 0) {
            aggregateAccountCount += accountCountFallback;
          }

          let sourceHasTotal = false;
          let sourceHasEth = false;
          let sourceHasBtc = false;

          if (accounts.length) {
            for (const account of accounts) {
              const accountTotal = parseDecimal(account.total_pnl);
              if (Number.isFinite(accountTotal)) {
                aggregateTotalPnl += accountTotal;
                hasTotal = true;
                sourceHasTotal = true;
              }

              const accountEth = parseDecimal(account.eth_pnl);
              if (Number.isFinite(accountEth)) {
                aggregateEthPnl += accountEth;
                hasEth = true;
                sourceHasEth = true;
              }

              const accountBtc = parseDecimal(account.btc_pnl);
              if (Number.isFinite(accountBtc)) {
                aggregateBtcPnl += accountBtc;
                hasBtc = true;
                sourceHasBtc = true;
              }

              const walletValue = parseDecimal(
                account.balance ??
                account.available_balance ??
                summary.balance ??
                summary.available_balance ??
                snapshot.balance ??
                snapshot.available_balance
              );
              const equityValue = parseDecimal(
                account.equity ??
                account.available_equity ??
                summary.equity ??
                summary.available_equity ??
                snapshot.equity ??
                snapshot.available_equity
              );
              const riskBaseValue = Number.isFinite(equityValue) ? equityValue : walletValue;
              const accountTs = Number(account.updated_at ?? snapshotTs);
              flattenedAccounts.push({
                agentId,
                account,
                summary,
                updatedTs: accountTs,
                totalValue: accountTotal,
                ethValue: accountEth,
                btcValue: accountBtc,
                equityValue,
                walletValue,
                riskBaseValue,
                riskRatio: computeRiskRatio(accountTotal, riskBaseValue),
                sortKey: buildAccountSortKey(agentId, account, summary),
              });
            }
          }

          if (!sourceHasTotal) {
            const totalValue = parseDecimal(summary.total_pnl);
            if (Number.isFinite(totalValue)) {
              aggregateTotalPnl += totalValue;
              hasTotal = true;
            }
          }

          if (!sourceHasEth) {
            const ethValue = parseDecimal(summary.eth_pnl);
            if (Number.isFinite(ethValue)) {
              aggregateEthPnl += ethValue;
              hasEth = true;
            }
          }

          if (!sourceHasBtc) {
            const btcValue = parseDecimal(summary.btc_pnl);
            if (Number.isFinite(btcValue)) {
              aggregateBtcPnl += btcValue;
              hasBtc = true;
            }
          }

          if (!accounts.length) {
            const placeholderTotal = parseDecimal(summary.total_pnl);
            const placeholderEth = parseDecimal(summary.eth_pnl);
            const placeholderBtc = parseDecimal(summary.btc_pnl);
            const fallbackWallet = parseDecimal(
              summary.balance ??
              summary.available_balance ??
              snapshot.balance ??
              snapshot.available_balance
            );
            const fallbackEquity = parseDecimal(
              summary.equity ??
              summary.available_equity ??
              snapshot.equity ??
              snapshot.available_equity
            );
            const riskBaseValue = Number.isFinite(fallbackEquity) ? fallbackEquity : fallbackWallet;
            flattenedAccounts.push({
              agentId,
              account: null,
              summary,
              updatedTs: snapshotTs,
              totalValue: placeholderTotal,
              ethValue: placeholderEth,
              btcValue: placeholderBtc,
              equityValue: fallbackEquity,
              walletValue: fallbackWallet,
              riskBaseValue,
              riskRatio: computeRiskRatio(placeholderTotal, riskBaseValue),
              sortKey: buildAccountSortKey(agentId, null, summary),
            });
          }
        }

        let aggregateEquity = 0;
        let aggregateWallet = 0;
        let hasEquity = false;
        let hasWallet = false;
        let worstLoss = null;

        for (const entry of flattenedAccounts) {
          if (Number.isFinite(entry.equityValue)) {
            aggregateEquity += entry.equityValue;
            hasEquity = true;
          }
          if (Number.isFinite(entry.walletValue)) {
            aggregateWallet += entry.walletValue;
            hasWallet = true;
          }
          if (Number.isFinite(entry.riskRatio) && (!worstLoss || entry.riskRatio > worstLoss.ratio)) {
            worstLoss = {
              ratio: entry.riskRatio,
              lossValue: entry.totalValue != null ? Math.abs(entry.totalValue) : 0,
              baseValue: entry.riskBaseValue,
              usedEquity: Number.isFinite(entry.equityValue) && entry.equityValue === entry.riskBaseValue,
              accountName: entry.account?.name ? String(entry.account.name) : null,
              agentId: entry.agentId ?? 'Source',
            };
          }
        }

        const sourcesLabel = entries.length === 1 ? 'source' : 'sources';
        const accountLabel = aggregateAccountCount === 1 ? 'account' : 'accounts';
        grvtAccountCount.textContent = `${aggregateAccountCount} ${accountLabel} across ${entries.length} ${sourcesLabel}`;

        grvtTotalPnl.textContent = hasTotal ? numberFormatter.format(aggregateTotalPnl) : '--';
        grvtEthPnl.textContent = hasEth ? numberFormatter.format(aggregateEthPnl) : '--';
        grvtBtcPnl.textContent = hasBtc ? numberFormatter.format(aggregateBtcPnl) : '--';
        if (grvtTotalEquity) {
          grvtTotalEquity.textContent = hasEquity ? numberFormatter.format(aggregateEquity) : '--';
        }
        if (grvtWalletBalance) {
          grvtWalletBalance.textContent = hasWallet
            ? `Wallet ${numberFormatter.format(aggregateWallet)}`
            : 'Wallet --';
        }

        if (grvtRiskLevel && grvtRiskDetail) {
          const worstRatio = worstLoss && Number.isFinite(worstLoss.ratio) ? worstLoss.ratio : null;
          if (worstRatio !== null) {
            grvtRiskLevel.textContent = formatPercent(worstRatio * 100, 2);
            applyRiskTone(grvtRiskLevel, worstRatio, 'summary');
            const accountLabelText = worstLoss.accountName
              ? `${worstLoss.accountName} (${worstLoss.agentId})`
              : worstLoss.agentId;
            const lossText = numberFormatter.format(worstLoss.lossValue ?? 0);
            const balanceText = Number.isFinite(worstLoss.baseValue)
              ? numberFormatter.format(worstLoss.baseValue)
              : '--';
            const baseLabel = worstLoss.usedEquity ? 'equity' : 'wallet';
            grvtRiskDetail.textContent = `${accountLabelText} loss ${lossText} / ${baseLabel} ${balanceText}`;
          } else {
            grvtRiskLevel.textContent = '—';
            applyRiskTone(grvtRiskLevel, null, 'summary');
            grvtRiskDetail.textContent = 'No losses or missing balance data';
          }
        }

        const updatedText = formatTimestamp(latestUpdate);
        grvtSummaryTime.textContent = updatedText ?? '--';
        grvtSummaryUpdated.textContent = updatedText ? `Updated ${updatedText}` : 'Updated —';

        updateGrvtTransferAgents(transferOptions);

        if (!grvtAccountGrid) {
          return;
        }

        grvtAccountGrid.innerHTML = '';

        if (!flattenedAccounts.length) {
          if (grvtAccountsEmpty) {
            grvtAccountsEmpty.classList.remove('hidden');
            grvtAccountsEmpty.textContent = 'Waiting for account data…';
          }
          return;
        }

        if (grvtAccountsEmpty) {
          grvtAccountsEmpty.classList.add('hidden');
        }

        flattenedAccounts.sort((a, b) => {
          const aKey = a.sortKey ?? '';
          const bKey = b.sortKey ?? '';
          if (aKey !== bKey) {
            return aKey.localeCompare(bKey);
          }
          const aTs = Number(a.updatedTs) || 0;
          const bTs = Number(b.updatedTs) || 0;
          return bTs - aTs;
        });

        for (const entry of flattenedAccounts) {
          const agentId = entry.agentId ?? 'Source';
          const account = entry.account;
          const fallbackName = account && account.name ? String(account.name) : 'Account';
          const displayName = account && account.name ? String(account.name) : `${agentId} ${fallbackName}`;
          const accountUpdated = formatTimestamp(entry.updatedTs);
          const equityValue = entry.equityValue;
          const walletValue = entry.walletValue;
          const riskPercent = Number.isFinite(entry.riskRatio) ? entry.riskRatio * 100 : null;

          if (Array.isArray(account?.positions)) {
            for (const position of account.positions) {
              const symbolText = normalizeSymbolLabel(position?.symbol);
              if (symbolText) {
                symbolCandidates.add(symbolText);
              }
            }
          }

          const card = document.createElement('article');
          card.className = 'grvt-account-card';
          card.innerHTML = `
            <header>
              <div>
                <span class="grvt-account-name">${escapeHtml(displayName)}</span>
                <span class="badge badge-info grvt-source-badge">${escapeHtml(agentId)}</span>
              </div>
              <span class="grvt-account-updated">${escapeHtml(accountUpdated ?? '—')}</span>
            </header>
          `;

          const metrics = document.createElement('dl');
          metrics.className = 'grvt-account-metrics';
          metrics.innerHTML = `
            <div><dt>Equity</dt><dd>${escapeHtml(Number.isFinite(equityValue) ? numberFormatter.format(equityValue) : '--')}</dd></div>
            <div><dt>Wallet</dt><dd>${escapeHtml(Number.isFinite(walletValue) ? numberFormatter.format(walletValue) : '--')}</dd></div>
            <div><dt>Total</dt><dd>${escapeHtml(Number.isFinite(entry.totalValue) ? numberFormatter.format(entry.totalValue) : '--')}</dd></div>
            <div data-metric="maintenance"><dt>Maint.</dt><dd><span class="maintenance-ratio">—</span></dd></div>
            <div data-metric="risk"><dt>Risk</dt><dd><span class="risk-pill risk-pill-inline">—</span></dd></div>
          `;
          card.appendChild(metrics);

          const riskBadge = metrics.querySelector('[data-metric="risk"] .risk-pill');
          if (riskBadge) {
            if (Number.isFinite(riskPercent)) {
              riskBadge.textContent = formatPercent(riskPercent, 2);
            } else {
              riskBadge.textContent = '—';
            }
            const entryRiskRatio = Number.isFinite(entry.riskRatio) ? entry.riskRatio : null;
            applyRiskTone(riskBadge, entryRiskRatio, 'inline');
          }

          const maintenanceBadge = metrics.querySelector('[data-metric="maintenance"] .maintenance-ratio');
          let maintenanceRequirementTotal = 0;

          const positions = Array.isArray(account?.positions)
            ? account.positions
                .slice()
                .sort((a, b) => {
                  const aSymbol = normalizeSymbolLabel(a?.symbol);
                  const bSymbol = normalizeSymbolLabel(b?.symbol);
                  return aSymbol.localeCompare(bSymbol, undefined, { sensitivity: 'base' });
                })
                .slice(0, MAX_GRVT_POSITIONS)
            : [];
          if (positions.length) {
            const table = document.createElement('table');
            table.className = 'grvt-positions-table';
            table.innerHTML = `
              <thead>
                <tr>
                  <th>Symbol</th>
                  <th>Side</th>
                  <th>Size</th>
                  <th>Entry</th>
                  <th>Mark</th>
                  <th>PnL</th>
                  <th>Value</th>
                  <th>Init Margin</th>
                </tr>
              </thead>
              <tbody></tbody>
            `;
            const body = table.querySelector('tbody');
            for (const position of positions) {
              const side = position.side ? String(position.side).toUpperCase() : '—';
              const sizeText = formatDecimal(position.net_size, 4);
              const entryText = formatDecimal(position.entry_price, 4);
              const markText = formatDecimal(position.mark_price, 4);
              const pnlText = formatDecimal(position.pnl, 6);
              const marginInfo = computePositionMargin(position);
              if (marginInfo && Number.isFinite(marginInfo.maintenanceMargin)) {
                maintenanceRequirementTotal += marginInfo.maintenanceMargin;
              }
              const notionalText = marginInfo && Number.isFinite(marginInfo.notional)
                ? numberFormatter.format(marginInfo.notional)
                : '--';
              const initialMarginText = marginInfo && Number.isFinite(marginInfo.initialMargin)
                ? numberFormatter.format(marginInfo.initialMargin)
                : '--';
              const row = document.createElement('tr');
              row.innerHTML = `
                <td>${escapeHtml(position.symbol ?? '--')}</td>
                <td>${escapeHtml(side)}</td>
                <td>${escapeHtml(sizeText)}</td>
                <td>${escapeHtml(entryText)}</td>
                <td>${escapeHtml(markText)}</td>
                <td>${escapeHtml(pnlText)}</td>
                <td>${escapeHtml(notionalText)}</td>
                <td>${escapeHtml(initialMarginText)}</td>
              `;
              body.appendChild(row);
            }
            card.appendChild(table);
          } else {
            const empty = document.createElement('p');
            empty.className = 'grvt-positions-empty';
            empty.textContent = account ? 'No open positions' : 'Awaiting account snapshot';
            card.appendChild(empty);
          }

          if (maintenanceBadge) {
            const ratioBaseValue = Number.isFinite(equityValue) && equityValue > 0
              ? equityValue
              : Number.isFinite(walletValue) && walletValue > 0
                ? walletValue
                : null;
            if (ratioBaseValue && Number.isFinite(maintenanceRequirementTotal) && maintenanceRequirementTotal >= 0) {
              const ratio = maintenanceRequirementTotal / ratioBaseValue;
              maintenanceBadge.textContent = formatPercent(ratio * 100, 2);
            } else if (ratioBaseValue) {
              maintenanceBadge.textContent = formatPercent(0, 2);
            } else {
              maintenanceBadge.textContent = '—';
            }
          }

          grvtAccountGrid.appendChild(card);
        }

        updateGrvtSymbolOptions(Array.from(symbolCandidates));
      }

      function renderAggregate(data) {
        const position = toNumber(data.position ?? data?.aggregate?.position);
        const pnl = toNumber(data.cumulative_pnl ?? data?.aggregate?.cumulative_pnl);
        const volume = toNumber(data.cumulative_volume ?? data?.aggregate?.cumulative_volume);
        const cyclesRaw = Number(data.total_cycles ?? data?.aggregate?.total_cycles ?? 0);
        const available = toNumber(
          data.available_balance ??
          data.total_available_balance ??
          data?.aggregate?.available_balance
        );
        const accountValue = toNumber(
          data.total_account_value ??
          data.account_value ??
          data?.aggregate?.total_account_value ??
          data?.aggregate?.account_value
        );

        document.getElementById('position').textContent = numberFormatter.format(position);
        document.getElementById('pnl').textContent = numberFormatter.format(pnl);
        document.getElementById('volume').textContent = numberFormatter.format(volume);
        document.getElementById('cycles').textContent = Number.isFinite(cyclesRaw) ? cyclesRaw : '--';
        document.getElementById('available-balance').textContent = numberFormatter.format(available);
        document.getElementById('account-value').textContent = numberFormatter.format(accountValue);
        const runtimeSeconds = toNumber(data.runtime_seconds ?? data?.aggregate?.runtime_seconds);
        if (runtimeElement) {
          const agentEntries = Object.entries(data?.agents ?? {});
          if (!agentEntries.length) {
            runtimeElement.classList.remove('runtime-multiple');
            runtimeElement.textContent = formatDuration(runtimeSeconds);
          } else {
            runtimeElement.classList.add('runtime-multiple');
            runtimeElement.innerHTML = '';
            agentEntries
              .slice()
              .sort((a, b) => a[0].localeCompare(b[0], undefined, { sensitivity: 'base' }))
              .forEach(([agentId, agentMetrics]) => {
                const row = document.createElement('div');
                row.className = 'runtime-row';

                const label = document.createElement('span');
                label.className = 'runtime-row-label';
                label.textContent = agentId;

                const value = document.createElement('span');
                value.className = 'runtime-row-value';
                const agentSeconds = toNumber(agentMetrics?.runtime_seconds ?? agentMetrics?.runtime ?? 0);
                value.textContent = formatDuration(agentSeconds);

                row.append(label, value);
                runtimeElement.appendChild(row);
              });
          }
        }

        if (data.last_update_ts) {
          const updatedDate = new Date(Number(data.last_update_ts) * 1000);
          const latestAgent = data.last_agent_id ? ` (agent: ${data.last_agent_id})` : '';
          updatedElement.textContent = `Last update: ${updatedDate.toLocaleString()}${latestAgent}`;
        } else {
          updatedElement.textContent = 'Awaiting data…';
        }
      }

      function updateBatchButtons() {
        if (!pauseAllButton || !resumeAllButton) {
          return;
        }

        if (batchBusy) {
          pauseAllButton.disabled = true;
          resumeAllButton.disabled = true;
        } else {
          pauseAllButton.disabled = lastDefaultPaused;
          resumeAllButton.disabled = !lastDefaultPaused;
        }

        pauseAllButton.classList.toggle('button-ghost', lastDefaultPaused);
        resumeAllButton.classList.toggle('button-ghost', !lastDefaultPaused);
      }

      function redirectIfUnauthorized(response) {
        if (response && response.status === 401) {
          window.location.href = '/login';
        }
      }

      async function sendControl(agentId, action, button) {
        if (!agentId || !action) {
          return;
        }

        const previousText = button?.textContent ?? '';
        if (button) {
          button.disabled = true;
          button.textContent = action === 'pause' ? 'Pausing…' : 'Resuming…';
        }

        try {
          const response = await fetch('/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ agent_id: agentId, action })
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          await refreshMetrics();
        } catch (error) {
          updatedElement.textContent = `Control update failed: ${error}`;
        } finally {
          if (button) {
            button.disabled = false;
            button.textContent = previousText || (action === 'pause' ? 'Pause' : 'Resume');
          }
        }
      }

      async function sendBatchControl(action, button) {
        if (!action) {
          return;
        }

        const buttons = [pauseAllButton, resumeAllButton].filter(Boolean);
        const previousTexts = new Map();

        batchBusy = true;
        updateBatchButtons();

        if (button) {
          previousTexts.set(button, button.textContent);
          button.textContent = action === 'pause' ? 'Pausing…' : 'Resuming…';
        }

        try {
          const response = await fetch('/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ scope: 'all', action })
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          await refreshMetrics();
        } catch (error) {
          updatedElement.textContent = `Control update failed: ${error}`;
        } finally {
          batchBusy = false;
          buttons.forEach((btn) => {
            if (btn && previousTexts.has(btn)) {
              btn.textContent = previousTexts.get(btn);
            }
          });
          updateBatchButtons();
        }
      }

      function renderAgents(data) {
        const entries = Object.entries(data?.agents ?? {});
        const staleSet = new Set(data?.stale_agents ?? []);
        const lastAgentId = data?.last_agent_id ?? null;
        const controls = data?.controls ?? {};

        agentGrid.innerHTML = '';

        if (!entries.length) {
          agentGrid.classList.add('hidden');
          agentEmpty.classList.remove('hidden');
          agentEmpty.textContent = 'Waiting for VPS metrics…';
          agentCount.textContent = '0 active';
          return;
        }

        agentGrid.classList.remove('hidden');
        agentEmpty.classList.add('hidden');

        entries.sort((a, b) => a[0].localeCompare(b[0], undefined, { sensitivity: 'base' }));

        let activeCount = 0;
        let pausedCount = 0;

  for (const [agentId, metrics] of entries) {
          const safeId = escapeHtml(agentId);
          const position = numberFormatter.format(toNumber(metrics.position));
          const pnl = numberFormatter.format(toNumber(metrics.cumulative_pnl));
          const volume = numberFormatter.format(toNumber(metrics.cumulative_volume));
          const available = numberFormatter.format(
            toNumber(
              metrics.available_balance ??
              metrics.available ??
              metrics.total_available_balance
            )
          );
          const accountValue = numberFormatter.format(
            toNumber(
              metrics.total_account_value ??
              metrics.account_value ??
              metrics.total_asset_value
            )
          );
          const instrumentText = metrics.instrument ? escapeHtml(metrics.instrument) : '—';
          const runtimeSeconds = toNumber(metrics.runtime_seconds);
          const runtimeDisplay = escapeHtml(formatDuration(runtimeSeconds));
          let depthDisplay = '—';
          if (metrics.depths && typeof metrics.depths === 'object') {
            const depthEntries = Object.entries(metrics.depths)
              .map(([key, value]) => {
                const depthValue = Number(value);
                if (!Number.isFinite(depthValue)) {
                  return null;
                }
                return `${escapeHtml(String(key))} ${depthValue}`;
              })
              .filter(Boolean);
            if (depthEntries.length) {
              depthDisplay = depthEntries.join(' · ');
            }
          }
          const cyclesRaw = Number(metrics.total_cycles ?? 0);
          const cycles = Number.isFinite(cyclesRaw) ? cyclesRaw : '--';

          const updatedTs = Number(metrics.last_update_ts ?? 0) * 1000;
          const updatedText = Number.isFinite(updatedTs) && updatedTs > 0
            ? new Date(updatedTs).toLocaleString()
            : 'Awaiting data…';

          const control = controls[agentId] ?? {};
          const isPaused = Boolean(control.paused);
          const controlTs = Number(control.updated_at ?? 0) * 1000;
          const pausedSinceText = isPaused && Number.isFinite(controlTs) && controlTs > 0
            ? new Date(controlTs).toLocaleString()
            : null;

          const card = document.createElement('article');
          card.className = 'agent-card card';

          const isStale = staleSet.has(agentId);
          if (isStale) {
            card.classList.add('stale');
          }
          if (isPaused) {
            card.classList.add('paused');
            pausedCount += 1;
          }
          if (!isStale && !isPaused) {
            activeCount += 1;
          }
          if (lastAgentId && agentId === lastAgentId) {
            card.classList.add('recent');
          }

          const statusParts = [];
          statusParts.push(isPaused ? 'Paused' : 'Active');
          if (isStale) {
            statusParts.push('Stale');
          }
          if (pausedSinceText) {
            statusParts.push(`since ${pausedSinceText}`);
          }
          const statusText = statusParts.join(' · ');

          card.innerHTML = `
            <header>
              <span class="agent-name">${safeId}</span>
              <span class="badge-group">
                ${lastAgentId && agentId === lastAgentId ? '<span class="badge badge-info">Latest</span>' : ''}
                ${isPaused ? '<span class="badge badge-muted">Paused</span>' : ''}
                ${isStale ? '<span class="badge badge-warn">Stale</span>' : ''}
              </span>
            </header>
            <dl class="agent-metrics">
              <div><dt>Position</dt><dd>${position}</dd></div>
              <div><dt>Total Cycles</dt><dd>${cycles}</dd></div>
              <div><dt>Runtime</dt><dd>${runtimeDisplay}</dd></div>
              <div><dt>Cumulative PnL</dt><dd>${pnl}</dd></div>
              <div><dt>Total Volume</dt><dd>${volume}</dd></div>
              <div><dt>Available</dt><dd>${available}</dd></div>
              <div><dt>Account Value</dt><dd>${accountValue}</dd></div>
              <div><dt>Instrument</dt><dd>${instrumentText}</dd></div>
              <div><dt>Depth</dt><dd>${escapeHtml(depthDisplay)}</dd></div>
            </dl>
            <p class="timestamp">${escapeHtml(statusText || 'Status unknown')}</p>
            <div class="control-actions">
              <button type="button" data-agent="${safeId}">${isPaused ? 'Resume' : 'Pause'}</button>
              <span class="updated-note">Updated ${escapeHtml(updatedText)}</span>
            </div>
          `;

          const controlButton = card.querySelector('button');
          if (controlButton) {
            controlButton.addEventListener('click', () => {
              const action = isPaused ? 'resume' : 'pause';
              sendControl(agentId, action, controlButton);
            });
          }

          agentGrid.appendChild(card);
        }

        const summaryParts = [];
        summaryParts.push(`${activeCount} active`);
        summaryParts.push(`${pausedCount} paused`);
        summaryParts.push(`${entries.length} total`);
        agentCount.textContent = summaryParts.join(' · ');

          const defaultPaused = Boolean(data?.default_paused);
          if (defaultPauseIndicator) {
            defaultPauseIndicator.classList.toggle('hidden', !defaultPaused);
          }

          lastDefaultPaused = defaultPaused;
          updateBatchButtons();
      }

      function describeStrategyAction(action) {
        if (!action) {
          return '—';
        }
        let text = String(action).trim();
        if (text.includes('.')) {
          text = text.split('.').pop() || text;
        }
        text = text.replace(/_/g, ' ');
        return text.charAt(0).toUpperCase() + text.slice(1);
      }

      function describeStrategyDirection(direction) {
        if (!direction) {
          return '—';
        }
        let text = String(direction).trim();
        if (text.includes('.')) {
          text = text.split('.').pop() || text;
        }
        return text.replace(/_/g, ' ').toUpperCase();
      }

      function renderStrategy(data) {
        if (!strategyAgentCount || !strategyCard) {
          return;
        }

        const strategyMap = data?.strategy_metrics ?? {};
        const entries = Object.entries(strategyMap);
        const label = entries.length === 1 ? 'strategy' : 'strategies';
        strategyAgentCount.textContent = `${entries.length} ${label}`;

        if (!entries.length) {
          strategyCard.classList.add('hidden');
          strategyEmpty.classList.remove('hidden');
          strategyEmpty.textContent = 'Waiting for strategy metrics…';
          if (strategyAgentLabel) {
            strategyAgentLabel.classList.add('hidden');
          }
          if (strategyAgentSelect) {
            strategyAgentSelect.innerHTML = '';
          }
          selectedStrategyAgent = null;
          lastStrategyOptionsKey = '';
          return;
        }

        strategyEmpty.classList.add('hidden');
        strategyCard.classList.remove('hidden');

        if (!selectedStrategyAgent || !strategyMap[selectedStrategyAgent]) {
          selectedStrategyAgent = entries[0][0];
        }

        if (strategyAgentSelect) {
          const optionsKey = entries.map(([agent]) => agent).join('|');
          if (optionsKey !== lastStrategyOptionsKey) {
            strategyAgentSelect.innerHTML = '';
            for (const [agent] of entries) {
              const option = document.createElement('option');
              option.value = agent;
              option.textContent = agent;
              strategyAgentSelect.appendChild(option);
            }
            lastStrategyOptionsKey = optionsKey;
          }
          strategyAgentSelect.value = selectedStrategyAgent;
          if (strategyAgentLabel) {
            strategyAgentLabel.classList.toggle('hidden', entries.length <= 1);
          }
        }

        const metrics = strategyMap[selectedStrategyAgent] ?? {};
        const summary = metrics.summary ?? {};
        const totalPnl = parseDecimal(summary.total_pnl ?? metrics.total_pnl);
        strategyNetPnl.textContent = Number.isFinite(totalPnl)
          ? numberFormatter.format(totalPnl)
          : '--';

        const tradeCountRaw = Number(summary.trade_count ?? metrics.trade_count ?? 0);
        strategyTradeCount.textContent = `Trades ${Number.isFinite(tradeCountRaw) ? tradeCountRaw : '--'}`;

        if (strategyTotalVolume) {
          const totalVolume = parseDecimal(summary.total_volume ?? metrics.total_volume);
          strategyTotalVolume.textContent = Number.isFinite(totalVolume)
            ? numberFormatter.format(totalVolume)
            : '--';
        }

        if (strategyPnlRatio) {
          const ratioRaw = parseDecimal(summary.pnl_over_volume ?? metrics.pnl_over_volume);
          if (Number.isFinite(ratioRaw)) {
            strategyPnlRatio.textContent = `${(ratioRaw * 100).toFixed(2)}%`;
          } else {
            strategyPnlRatio.textContent = '--';
          }
        }

        const openPosition = metrics.open_position;
        if (openPosition && openPosition.direction) {
          const qtyValue = parseDecimal(openPosition.quantity);
          const positionParts = [describeStrategyDirection(openPosition.direction)];
          if (Number.isFinite(qtyValue)) {
            positionParts.push(qtyValue.toFixed(4));
          }
          strategyOpenPosition.textContent = positionParts.join(' ');

          const detailsParts = [];
          const entryTs = Number(openPosition.entry_timestamp);
          if (Number.isFinite(entryTs) && entryTs > 0) {
            detailsParts.push(new Date(entryTs * 1000).toLocaleString());
          }
          const entrySpread = parseDecimal(openPosition.entry_spread);
          if (Number.isFinite(entrySpread)) {
            detailsParts.push(`Spread ${entrySpread.toFixed(6)}`);
          }
          const ticksHeld = Number(openPosition.ticks_held);
          if (Number.isFinite(ticksHeld) && ticksHeld > 0) {
            detailsParts.push(`${ticksHeld} ticks elapsed`);
          }
          strategyOpenDetails.textContent = detailsParts.length ? detailsParts.join(' · ') : '—';
        } else {
          strategyOpenPosition.textContent = 'None';
          strategyOpenDetails.textContent = '—';
        }

        const eventsRaw = Array.isArray(metrics.recent_events) ? metrics.recent_events.slice(-MAX_STRATEGY_EVENTS) : [];
        const lastEvent = eventsRaw.length ? eventsRaw[eventsRaw.length - 1] : null;
        if (lastEvent) {
          const actionText = describeStrategyAction(lastEvent.action);
          const directionText = describeStrategyDirection(lastEvent.direction);
          const forced = Boolean(lastEvent.forced);
          const decisionParts = [actionText];
          if (directionText !== '—') {
            decisionParts.push(directionText);
          }
          if (forced) {
            decisionParts.push('(forced)');
          }
          strategyLastDecision.textContent = decisionParts.join(' ');

          const ts = Number(lastEvent.timestamp);
          if (Number.isFinite(ts) && ts > 0) {
            strategyLastDecisionTime.textContent = new Date(ts * 1000).toLocaleString();
          } else {
            strategyLastDecisionTime.textContent = '—';
          }
        } else {
          strategyLastDecision.textContent = '—';
          strategyLastDecisionTime.textContent = '—';
        }

        if (!strategyEventsBody) {
          return;
        }

        strategyEventsBody.innerHTML = '';
        if (!eventsRaw.length) {
          const emptyRow = document.createElement('tr');
          emptyRow.innerHTML = '<td colspan="8">Awaiting decision events…</td>';
          strategyEventsBody.appendChild(emptyRow);
          return;
        }

        for (let index = eventsRaw.length - 1; index >= 0; index -= 1) {
          const event = eventsRaw[index];
          const ts = Number(event.timestamp);
          const timeText = Number.isFinite(ts) && ts > 0
            ? new Date(ts * 1000).toLocaleTimeString()
            : '—';
          const actionText = describeStrategyAction(event.action);
          const directionText = describeStrategyDirection(event.direction);
          const spreadText = formatDecimal(event.spread, 6);
          const zScoreText = formatDecimal(event.z_score, 4);
          const quantityText = formatDecimal(event.quantity, 4);
          const pnlText = formatDecimal(event.pnl, 6);
          const reasonText = event.reason ? escapeHtml(event.reason) : (event.forced ? 'Forced exit' : '—');

          let actionClass = 'action-other';
          if (event.forced) {
            actionClass = 'action-forced';
          } else if (String(event.action).toLowerCase() === 'enter') {
            actionClass = 'action-enter';
          } else if (String(event.action).toLowerCase() === 'exit') {
            actionClass = 'action-exit';
          }

          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${escapeHtml(timeText)}</td>
            <td class="${actionClass}">${escapeHtml(actionText)}</td>
            <td>${escapeHtml(directionText)}</td>
            <td>${escapeHtml(spreadText)}</td>
            <td>${escapeHtml(zScoreText)}</td>
            <td>${escapeHtml(quantityText)}</td>
            <td>${escapeHtml(pnlText)}</td>
            <td>${reasonText}</td>
          `;
          strategyEventsBody.appendChild(row);
        }
      }

      function renderSpread(data) {
        if (!spreadAgentCount || !spreadEmpty || !spreadCard) {
          return;
        }

        const spreads = data?.spread_metrics ?? {};
        const entries = Object.entries(spreads);
        const monitorLabel = entries.length === 1 ? 'monitor' : 'monitors';
        spreadAgentCount.textContent = `${entries.length} ${monitorLabel}`;

        if (!entries.length) {
          spreadCard.classList.add('hidden');
          spreadEmpty.classList.remove('hidden');
          spreadEmpty.textContent = 'Waiting for spread data…';
          if (spreadAgentLabel) {
            spreadAgentLabel.classList.add('hidden');
          }
          if (spreadTableBody) {
            spreadTableBody.innerHTML = '';
          }
          return;
        }

        spreadEmpty.classList.add('hidden');
        spreadCard.classList.remove('hidden');

        if (!selectedSpreadAgent || !spreads[selectedSpreadAgent]) {
          selectedSpreadAgent = entries[0][0];
        }

        if (spreadAgentSelect) {
          const optionsKey = entries.map(([agent]) => agent).join('|');
          if (optionsKey !== lastSpreadOptionsKey) {
            spreadAgentSelect.innerHTML = '';
            for (const [agent] of entries) {
              const option = document.createElement('option');
              option.value = agent;
              option.textContent = agent;
              spreadAgentSelect.appendChild(option);
            }
            lastSpreadOptionsKey = optionsKey;
          }
          spreadAgentSelect.value = selectedSpreadAgent;
          if (spreadAgentLabel) {
            spreadAgentLabel.classList.toggle('hidden', entries.length <= 1);
          }
        }

  const metrics = spreads[selectedSpreadAgent] ?? {};
  const historyRaw = Array.isArray(metrics.history) ? metrics.history : [];
  const history = historyRaw.slice(-MAX_SPREAD_HISTORY_POINTS);

        if (spreadInstrument) {
          const ticker = metrics?.aster?.ticker ?? '';
          const symbol = metrics?.lighter?.symbol ?? '';
          const instrumentText = metrics.instrument || `${ticker}${ticker && symbol ? ' / ' : ''}${symbol}`;
          spreadInstrument.textContent = instrumentText ? `Instrument ${escapeHtml(instrumentText)}` : 'Instrument —';
        }

        if (spreadUpdated) {
          const tsSource = Number(metrics.updated_at ?? (historyRaw.length ? historyRaw[historyRaw.length - 1]?.timestamp : Date.now() / 1000));
          if (Number.isFinite(tsSource)) {
            spreadUpdated.textContent = `Updated ${new Date(tsSource * 1000).toLocaleString()}`;
          } else {
            spreadUpdated.textContent = 'Updated —';
          }
        }

        if (!spreadTableBody) {
          return;
        }

        spreadTableBody.innerHTML = '';
        if (!history.length) {
          const emptyRow = document.createElement('tr');
          emptyRow.innerHTML = '<td colspan="8">Awaiting history…</td>';
          spreadTableBody.appendChild(emptyRow);
          if (spreadChartWrapper) {
            spreadChartWrapper.classList.add('hidden');
          }
          return;
        }

        const chartLabels = [];
        const chartSellAster = [];
        const chartSellLighter = [];
        const tableRows = [];

        for (const row of history) {
          const timestamp = Number(row.timestamp);
          const timeLabel = row.iso_time
            ? new Date(row.iso_time).toLocaleTimeString()
            : (Number.isFinite(timestamp) ? new Date(timestamp * 1000).toLocaleTimeString() : '--');

          const asterBid = parseDecimal(row.aster_bid);
          const asterAsk = parseDecimal(row.aster_ask);
          const lighterBid = parseDecimal(row.lighter_bid);
          const lighterAsk = parseDecimal(row.lighter_ask);
          const spreadSellAsterRaw = Number.isFinite(asterBid) && Number.isFinite(lighterAsk)
            ? asterBid - lighterAsk
            : parseDecimal(row.spread_aster_bid_minus_lighter_ask);
          const spreadSellLighterRaw = Number.isFinite(lighterBid) && Number.isFinite(asterAsk)
            ? lighterBid - asterAsk
            : parseDecimal(row.spread_lighter_bid_minus_aster_ask);

          const basisAsterDenom = Number.isFinite(lighterAsk) ? Math.abs(lighterAsk) : Number.isFinite(asterBid) ? Math.abs(asterBid) : null;
          const basisLighterDenom = Number.isFinite(asterAsk) ? Math.abs(asterAsk) : Number.isFinite(lighterBid) ? Math.abs(lighterBid) : null;

          chartLabels.push(timeLabel);
          chartSellAster.push(computePercent(spreadSellAsterRaw ?? NaN, basisAsterDenom ?? NaN));
          chartSellLighter.push(computePercent(spreadSellLighterRaw ?? NaN, basisLighterDenom ?? NaN));

          tableRows.push([
            escapeHtml(timeLabel),
            escapeHtml(formatDecimal(row.aster_bid, 4)),
            escapeHtml(formatDecimal(row.aster_ask, 4)),
            escapeHtml(formatDecimal(row.lighter_bid, 4)),
            escapeHtml(formatDecimal(row.lighter_ask, 4)),
            escapeHtml(formatDecimal(row.spread_aster_bid_minus_lighter_ask, 6)),
            escapeHtml(formatDecimal(row.spread_lighter_bid_minus_aster_ask, 6)),
            escapeHtml(formatDecimal(row.mid_price_diff, 6))
          ]);
        }

        for (let index = tableRows.length - 1; index >= 0; index -= 1) {
          const tr = document.createElement('tr');
          tr.innerHTML = tableRows[index].map((value) => `<td>${value}</td>`).join('');
          spreadTableBody.appendChild(tr);
        }

        const hasChartPoints = chartSellAster.some((value) => Number.isFinite(value)) ||
          chartSellLighter.some((value) => Number.isFinite(value));

        if (spreadChartWrapper) {
          if (hasChartPoints) {
            spreadChartWrapper.classList.remove('hidden');
            renderSpreadCanvas(chartLabels, chartSellAster, chartSellLighter);
          } else {
            spreadChartWrapper.classList.add('hidden');
          }
        }
      }

      async function refreshMetrics() {
        try {
          const response = await fetch('/metrics', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();
          lastMetricsSnapshot = data;
          renderAggregate(data);
          renderAgents(data);
          renderGrvt(data);
          renderGrvtAdjustments(data?.grvt_adjustments);
          renderSpread(data);
          renderStrategy(data);
        } catch (error) {
          updatedElement.textContent = `Dashboard error: ${error}`;
          agentCount.textContent = '—';
          agentGrid.innerHTML = '';
          agentGrid.classList.add('hidden');
          agentEmpty.classList.remove('hidden');
          agentEmpty.textContent = 'Unable to load metrics at the moment.';
          if (spreadAgentCount) {
            spreadAgentCount.textContent = '0 monitors';
          }
          if (spreadCard) {
            spreadCard.classList.add('hidden');
          }
          if (spreadEmpty) {
            spreadEmpty.classList.remove('hidden');
            spreadEmpty.textContent = 'Unable to load spread data at the moment.';
          }
          if (strategyAgentCount) {
            strategyAgentCount.textContent = '0 strategies';
          }
          if (strategyCard) {
            strategyCard.classList.add('hidden');
          }
          if (strategyEmpty) {
            strategyEmpty.classList.remove('hidden');
            strategyEmpty.textContent = 'Unable to load strategy data at the moment.';
          }
        }
      }

      if (pauseAllButton) {
        pauseAllButton.addEventListener('click', () => sendBatchControl('pause', pauseAllButton));
      }
      if (resumeAllButton) {
        resumeAllButton.addEventListener('click', () => sendBatchControl('resume', resumeAllButton));
      }
      if (spreadAgentSelect) {
        spreadAgentSelect.addEventListener('change', (event) => {
          selectedSpreadAgent = event.target.value;
          if (lastMetricsSnapshot) {
            renderSpread(lastMetricsSnapshot);
          }
        });
      }
      if (strategyAgentSelect) {
        strategyAgentSelect.addEventListener('change', (event) => {
          selectedStrategyAgent = event.target.value;
          if (lastMetricsSnapshot) {
            renderStrategy(lastMetricsSnapshot);
          }
        });
      }
      if (grvtAdjustAddButton) {
        grvtAdjustAddButton.addEventListener('click', () => sendGrvtAdjustment('add'));
      }
      if (grvtAdjustReduceButton) {
        grvtAdjustReduceButton.addEventListener('click', () => sendGrvtAdjustment('reduce'));
      }
      if (grvtResetSymbolButton) {
        grvtResetSymbolButton.addEventListener('click', () => {
          clearGrvtSymbolSelection();
        });
      }
      if (grvtTransferSubmitButton) {
        grvtTransferSubmitButton.addEventListener('click', () => {
          sendGrvtTransfer();
        });
      }
      if (grvtTransferAgentSelect) {
        grvtTransferAgentSelect.addEventListener('change', (event) => {
          const agentId = event.target.value;
          if (agentId) {
            applyGrvtTransferDefaults(agentId, { forceAll: true });
            setGrvtTransferStatus('等待指令…');
          }
          updateGrvtTransferButtons();
        });
      }
      if (grvtTransferDirectionSelect) {
        grvtTransferDirectionSelect.addEventListener('change', () => {
          if (grvtTransferAgentSelect?.value) {
            updateGrvtTransferRoute(grvtTransferAgentSelect.value, { force: true });
          }
        });
      }
      updateGrvtSymbolOptions([]);
      updateGrvtTransferButtons();
      refreshMetrics();
      setInterval(refreshMetrics, 2000);
    </script>
  </body>
</html>
