<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hedge Metrics Dashboard</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
        background: #111;
        color: #f2f4f8;
      }

      body {
        margin: 0;
        padding: 2rem;
        max-width: 960px;
        margin-inline: auto;
      }

      .dashboard-layout {
        display: grid;
        grid-template-columns: 1fr;
        gap: 1.5rem;
        align-items: start;
      }

      /* Move exchange filter bar to the top (instead of left sidebar). */
      .dashboard-sidebar {
        display: none;
      }

      .dashboard-filterbar {
        position: sticky;
        top: 0;
        z-index: 20;
        display: flex;
        gap: 0.5rem;
        align-items: center;
        flex-wrap: wrap;
        padding: 0.75rem 0;
        margin: 0 0 1rem;
        background: rgba(17, 17, 17, 0.92);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }

      .dashboard-filterbar-title {
        margin: 0;
        font-size: 0.78rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
        padding-right: 0.25rem;
      }

      .dashboard-filterbar .sidebar-filter {
        width: auto;
        white-space: nowrap;
      }

      .dashboard-sidebar {
        position: sticky;
        top: 1.5rem;
        align-self: start;
        background: #141823;
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 14px;
        padding: 1rem;
        box-shadow: 0 18px 36px rgba(0, 0, 0, 0.28);
      }

      .sidebar-title {
        margin: 0 0 0.75rem;
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .sidebar-nav {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.35rem;
      }

      .sidebar-nav button {
        width: 100%;
        text-align: left;
        padding: 0.55rem 0.75rem;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.02);
        color: #f2f4f8;
        cursor: pointer;
        font-size: 0.9rem;
        transition: background 0.2s ease, border-color 0.2s ease;
      }

      .sidebar-nav button:hover {
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(255, 255, 255, 0.14);
      }

      .sidebar-nav button.active {
        background: rgba(124, 77, 255, 0.2);
        border-color: rgba(124, 77, 255, 0.55);
      }

      .sidebar-hint {
        margin: 0.85rem 0 0;
        font-size: 0.8rem;
        color: #8a94a6;
        line-height: 1.35;
      }

      @media (max-width: 920px) {
        body {
          padding: 1.25rem;
        }
        .dashboard-layout {
          grid-template-columns: 1fr;
        }
        .dashboard-sidebar { position: static; }
        .dashboard-filterbar { position: static; }
      }

      h1 {
        font-size: 1.75rem;
        margin-bottom: 0.5rem;
      }

      .subtitle {
        color: #8a94a6;
        margin-bottom: 2rem;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.25rem;
      }

      .card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .spread-section {
        margin-top: 2.5rem;
      }

      .strategy-section {
        margin-top: 2.5rem;
      }

      .strategy-card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
        margin-top: 1rem;
      }

      .grvt-section {
        margin-top: 2.5rem;
      }

      .grvt-card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .vol-section {
        margin-top: 2.5rem;
      }

      .sim-section {
        margin-top: 2.5rem;
      }

      .sim-card {
        background: #101522;
        border-radius: 16px;
        padding: 1.5rem;
        border: 1px solid rgba(255, 255, 255, 0.05);
        box-shadow: 0 22px 46px rgba(0, 0, 0, 0.4);
      }

      .sim-summary {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 1rem;
        margin-bottom: 1.25rem;
      }

      .sim-label {
        margin: 0;
        font-size: 0.78rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .sim-value {
        margin: 0.25rem 0 0;
        font-size: 1.8rem;
        font-weight: 600;
      }

      .sim-controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
        margin-bottom: 1.25rem;
      }

      .sim-controls label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.85rem;
        color: #c7d2e8;
      }

      .sim-controls input[type="number"],
      .sim-controls input[type="range"] {
        width: 100%;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: #0f131d;
        color: #f5f7fb;
        padding: 0.5rem 0.75rem;
        font-size: 0.95rem;
      }

      .sim-controls input[type="range"] {
        appearance: none;
        height: 4px;
        padding: 0;
        background: linear-gradient(120deg, #4f9cff, #7c4dff);
      }

      .sim-slider-note {
        font-size: 0.78rem;
        color: #8a94a6;
      }

      .sim-optimize-row {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin: -0.25rem 0 1rem;
      }

      .sim-optimize-row button {
        padding: 0.5rem 1.25rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: transparent;
        color: #f5f7fb;
        font-size: 0.9rem;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease;
      }

      .sim-optimize-row button:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.2);
      }

      .sim-optimize-row button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #sim-chart {
        width: 100%;
        height: 320px;
      }

      .sim-status {
        margin-top: 0.65rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .vol-card {
        background: #121621;
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: 0 22px 46px rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .vol-symbol-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1.25rem;
      }

      .vol-symbol-card {
        background: #171c2b;
        border-radius: 14px;
        padding: 1.1rem 1.25rem;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .vol-symbol-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
        margin-bottom: 0.85rem;
      }

      .vol-symbol-label {
        margin: 0;
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        color: #7f8fa9;
        text-transform: uppercase;
      }

      .vol-price {
        margin: 0.2rem 0 0;
        font-size: 1.4rem;
        font-weight: 600;
        color: #f5f7fb;
      }

      .vol-updated-note {
        margin: 0;
        font-size: 0.8rem;
        color: #8a94a6;
        text-align: right;
      }

      .vol-metric-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.82rem;
      }

      .vol-metric-table th,
      .vol-metric-table td {
        padding: 0.4rem 0.45rem;
        text-align: center;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        white-space: nowrap;
      }

      .vol-metric-table th:first-child,
      .vol-metric-table td:first-child {
        text-align: left;
      }

      .vol-positive {
        color: #7ee787;
      }

      .vol-negative {
        color: #ff8787;
      }

      .vol-neutral {
        color: #c7d2e8;
      }

      .vol-hedge-card {
        margin-top: 1.5rem;
        padding: 1.2rem 1.35rem;
        border-radius: 14px;
        background: #141a28;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .vol-hedge-card h3 {
        margin: 0 0 0.35rem;
        font-size: 1rem;
      }

      .vol-hedge-pair {
        margin: 0 0 0.75rem;
        font-size: 0.9rem;
        color: #8a94a6;
      }

      .vol-badge {
        background: #1e2535;
        padding: 0.2rem 0.55rem;
        border-radius: 999px;
        font-size: 0.72rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }

      .vol-alert {
        color: #ffb3c1;
      }

      .grvt-summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.25rem;
        margin-bottom: 1.75rem;
      }

      .grvt-chart-grid {
        margin-top: 1.5rem;
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 1.25rem;
      }

      .grvt-chart-card {
        padding: 1.25rem 1.5rem 1.1rem;
        border-radius: 16px;
        background: #101522;
        border: 1px solid rgba(255, 255, 255, 0.04);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
      }

      .grvt-chart-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 1rem;
        margin-bottom: 0.75rem;
      }

      .grvt-chart-header h3 {
        margin: 0;
        font-size: 1rem;
      }

      .grvt-chart-card canvas {
        width: 100%;
        height: 300px;
      }

      .chart-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 1.25rem;
        margin-top: 0.85rem;
        font-size: 0.82rem;
        color: #8a94a6;
      }

      .chart-legend span {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
      }

      .legend-dot {
        width: 0.65rem;
        height: 0.65rem;
        border-radius: 999px;
        display: inline-flex;
      }

      .legend-btc {
        background: linear-gradient(135deg, #f6c177, #f4b453);
      }

      .legend-eth {
        background: linear-gradient(135deg, #7fe9ff, #4cc9f0);
      }

      .legend-transfer {
        background: linear-gradient(135deg, #c084fc, #8b5cf6);
      }

      .legend-diff {
        background: linear-gradient(135deg, #7dd3fc, #38bdf8);
      }

      .grvt-summary-card h3 {
        margin: 0 0 0.35rem;
        font-size: 0.9rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .grvt-summary-card .value {
        font-size: 1.75rem;
        font-weight: 600;
      }

      #grvt-total-position-net {
        font-size: 1.1rem;
      }

      .grvt-summary-updated {
        margin-top: 0.4rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-risk-detail {
        margin-top: 0.35rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .risk-pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.35rem 0.85rem;
        border-radius: 999px;
        font-weight: 600;
        letter-spacing: 0.04em;
        background: rgba(255, 255, 255, 0.08);
        color: #f5f7fb;
        transition: background 0.25s ease, color 0.25s ease, box-shadow 0.25s ease;
        box-shadow: 0 0 0 rgba(0, 0, 0, 0);
      }

      .risk-pill-summary {
        font-size: 1.35rem;
        min-width: 6rem;
      }

      /* Backpack multi-run cards */
      .bp-run-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.75rem;
        margin-top: 1rem;
      }
      .bp-run-card {
        background: rgba(255,255,255,.03);
        border: 1px solid rgba(255,255,255,.06);
        border-radius: 12px;
        padding: 0.9rem 1rem;
      }
      .bp-run-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.6rem;
      }
      .bp-run-card-title {
        margin: 0;
        font-size: 0.9rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }
      .bp-run-meta {
        color: #8a94a6;
        font-size: 0.85rem;
        line-height: 1.35;
      }
      .bp-run-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.75rem;
        flex-wrap: wrap;
      }

      .bp-run-kv-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: .5rem .9rem;
        margin-top: .65rem;
        padding-top: .65rem;
        border-top: 1px solid rgba(255,255,255,.06);
      }

      .bp-run-kv {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: .75rem;
        font-size: .85rem;
      }

      .bp-run-k {
        color: #8a94a6;
        letter-spacing: 0.02em;
      }

      .bp-run-v {
        color: #f2f4f8;
        font-variant-numeric: tabular-nums;
      }
      .bp-run-actions button {
        padding: 0.35rem 0.6rem;
        border-radius: 10px;
        font-size: 0.82rem;
      }

      .risk-pill-inline {
        font-size: 0.85rem;
        padding: 0.15rem 0.6rem;
        min-width: 0;
      }

      .grvt-account-grid {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 1.1rem;
      }

      .grvt-adjust-panel {
        margin-top: 1.5rem;
        padding: 1rem 1.25rem;
        border-radius: 12px;
        background: #1b1f2a;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-transfer-panel {
        margin-top: 1.25rem;
        padding: 1rem 1.25rem 1.25rem;
        border-radius: 12px;
        background: #141823;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .grvt-auto-panel {
        margin-top: 1.25rem;
        padding: 1rem 1.25rem 1.25rem;
        border-radius: 12px;
        background: #151a26;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-auto-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.85rem;
        margin-top: 0.85rem;
      }

      .grvt-auto-grid label {
        display: flex;
        flex-direction: column;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .grvt-auto-grid label small {
        margin-top: 0.35rem;
        font-size: 0.75rem;
        color: #6d768f;
      }

      .grvt-auto-grid input,
      .grvt-auto-grid select {
        margin-top: 0.35rem;
        background: #0f131d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.45rem 0.65rem;
        color: #f5f7fb;
        font-size: 0.9rem;
      }

      .grvt-auto-toggle {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 0.6rem 0.75rem;
        background: rgba(255, 255, 255, 0.03);
      }

      .grvt-auto-toggle span {
        font-weight: 600;
        margin-bottom: 0.25rem;
      }

      .grvt-auto-toggle small {
        color: #6d768f;
        margin-bottom: 0.5rem;
      }

      .grvt-auto-toggle input {
        width: auto;
        margin: 0;
        align-self: flex-start;
        transform: scale(1.2);
      }

      .grvt-risk-panel {
        margin-top: 1.5rem;
        padding: 1rem 1.25rem 1.25rem;
        border-radius: 14px;
        background: #101522;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .risk-status-pill {
        padding: 0.35rem 0.8rem;
        border-radius: 999px;
        font-size: 0.8rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        background: rgba(123, 140, 255, 0.15);
        color: #bcd0ff;
      }

      .risk-settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1rem;
        margin-top: 1rem;
      }

      .risk-settings-card {
        background: #0d111a;
        border-radius: 12px;
        padding: 1rem 1.1rem 1.2rem;
        border: 1px solid rgba(255, 255, 255, 0.04);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
      }

      .risk-slider-label {
        font-size: 0.85rem;
        font-weight: 600;
        color: #cfd6ea;
        display: inline-flex;
        justify-content: space-between;
        width: 100%;
      }

      .risk-slider {
        margin-top: 0.75rem;
      }

      .risk-slider input[type="range"] {
        width: 100%;
        accent-color: #7a62ff;
      }

      .risk-slider-scale {
        display: flex;
        justify-content: space-between;
        font-size: 0.7rem;
        color: #6d768f;
        margin-top: 0.35rem;
      }

      .risk-inline-inputs {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.85rem;
        margin-top: 1rem;
      }

      .risk-inline-inputs label,
      .risk-bark-grid label {
        font-size: 0.78rem;
        color: #8a94a6;
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }

      .risk-inline-inputs input,
      .risk-bark-grid input,
      .risk-bark-grid textarea {
        background: #090d14;
        border: 1px solid rgba(255, 255, 255, 0.07);
        border-radius: 8px;
        padding: 0.45rem 0.6rem;
        color: #f5f7fb;
        font-size: 0.9rem;
      }

      .risk-bark-grid textarea {
        min-height: 68px;
        resize: vertical;
      }

      .risk-bark-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.85rem;
      }

      .risk-toggle {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
        color: #e2e6f3;
      }

      .risk-toggle input {
        width: 1rem;
        height: 1rem;
      }

      .risk-settings-actions {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 0.85rem;
      }

      .risk-actions-left {
        display: flex;
        gap: 0.65rem;
        flex-wrap: wrap;
      }

      .risk-settings-message {
        margin: 0;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .risk-history-card {
        margin-top: 1.25rem;
        padding: 1rem 1.1rem 1.2rem;
        border-radius: 12px;
        background: #0d111a;
        border: 1px solid rgba(255, 255, 255, 0.04);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.015);
      }

      .risk-history-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      .risk-history-header h3 {
        margin: 0;
        font-size: 1rem;
      }

      .risk-history-status {
        margin: 0 0 0.75rem;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .risk-history-table-wrapper {
        max-height: 280px;
        overflow-y: auto;
        border: 1px solid rgba(255, 255, 255, 0.04);
        border-radius: 10px;
      }

      .risk-history-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.78rem;
      }

      .risk-history-table th,
      .risk-history-table td {
        padding: 0.45rem 0.6rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        text-align: left;
      }

      .risk-history-table th {
        font-size: 0.75rem;
        color: #8a94a6;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .risk-history-table td:last-child,
      .risk-history-table th:last-child {
        text-align: right;
      }

      .risk-history-empty {
        margin: 0;
        padding: 0.75rem;
        text-align: center;
        color: #8a94a6;
      }

      .risk-meta {
        margin: 0.85rem 0 0;
        font-size: 0.82rem;
        color: #8a94a6;
      }

      .grvt-auto-checkbox {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: 0.35rem;
      }

      .grvt-auto-checkbox input {
        width: auto;
        margin: 0;
      }

      .grvt-auto-checkbox span {
        color: #c7d2e8;
        font-size: 0.85rem;
      }

      .grvt-auto-actions {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
        margin-top: 1rem;
      }

      .grvt-auto-actions p {
        flex: 1;
        min-width: 240px;
        margin: 0;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-auto-status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
        margin-top: 1rem;
      }

      .grvt-auto-status-grid h4 {
        margin: 0 0 0.35rem;
        font-size: 0.85rem;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .grvt-auto-list {
        margin: 0;
        padding-left: 1.1rem;
        font-size: 0.85rem;
        color: #c7d2e8;
      }

      .grvt-auto-list li {
        margin-bottom: 0.2rem;
      }

      .grvt-auto-pair {
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-transfer-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.85rem;
        margin-top: 1rem;
      }

      .grvt-transfer-grid label {
        display: flex;
        flex-direction: column;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .grvt-transfer-grid input,
      .grvt-transfer-grid select,
      .grvt-transfer-grid textarea {
        margin-top: 0.35rem;
        background: #11141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.45rem 0.65rem;
        color: #f5f7fb;
        font-size: 0.9rem;
      }

      .grvt-transfer-grid textarea {
        min-height: 46px;
        resize: vertical;
      }

      .grvt-transfer-actions {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-top: 1.1rem;
        flex-wrap: wrap;
      }

      .grvt-transfer-status {
        flex: 1;
        min-width: 240px;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-transfer-history table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.78rem;
        margin-top: 0.9rem;
      }

      .grvt-transfer-history thead {
        background: rgba(255, 255, 255, 0.03);
      }

      .grvt-transfer-history th,
      .grvt-transfer-history td {
        padding: 0.4rem 0.5rem;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-adjust-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: flex-end;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .grvt-adjust-controls label {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-adjust-controls input {
        margin-top: 0.35rem;
        background: #11141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.4rem 0.65rem;
        color: #f5f7fb;
        min-width: 120px;
        font-size: 0.95rem;
      }

      .grvt-adjust-controls select {
        margin-top: 0.35rem;
        background: #11141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.4rem 0.65rem;
        color: #f5f7fb;
        font-size: 0.85rem;
        min-width: 140px;
      }

      .grvt-symbol-input {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .grvt-symbol-label {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        margin-bottom: 0.35rem;
        color: #8a94a6;
      }

      .grvt-symbol-label small {
        font-size: 0.75rem;
        color: #6d768f;
      }

      .grvt-symbol-reset {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.08);
        color: #f5f7fb;
        padding: 0.35rem 0.8rem;
        font-size: 0.78rem;
        cursor: pointer;
        transition: opacity 0.2s ease;
      }

      .grvt-symbol-reset:hover {
        opacity: 0.8;
      }

      .grvt-adjust-controls label.grvt-adjust-symbols {
        flex: 1;
        min-width: 200px;
        max-width: 240px;
      }

      .grvt-adjust-buttons {
        display: flex;
        gap: 0.75rem;
      }

      .grvt-adjust-status {
        flex: 1;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      .grvt-adjust-history table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.78rem;
      }

      .grvt-adjust-history thead {
        background: rgba(255, 255, 255, 0.04);
      }

      .grvt-adjust-history th,
      .grvt-adjust-history td {
        padding: 0.4rem 0.5rem;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      /* PARA adjustment history: group two rows (summary + VPS detail) with a solid outline. */
      .adjust-group-top td {
        border-top: 1px solid rgba(255, 255, 255, 0.22);
      }

      .adjust-group-bottom td {
        border-bottom: 1px solid rgba(255, 255, 255, 0.22);
      }

      .adjust-group-top td:first-child,
      .adjust-group-bottom td:first-child {
        border-left: 1px solid rgba(255, 255, 255, 0.22);
      }

      .adjust-group-top td:last-child,
      .adjust-group-bottom td:last-child {
        border-right: 1px solid rgba(255, 255, 255, 0.22);
      }

      .adjust-group-top td:first-child {
        border-top-left-radius: 8px;
      }

      .adjust-group-top td:last-child {
        border-top-right-radius: 8px;
      }

      .adjust-group-bottom td:first-child {
        border-bottom-left-radius: 8px;
      }

      .adjust-group-bottom td:last-child {
        border-bottom-right-radius: 8px;
      }

      .adjust-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.15rem 0.5rem;
        border-radius: 999px;
        font-size: 0.7rem;
        margin: 0 0.25rem 0.25rem 0;
        background: rgba(255, 255, 255, 0.08);
      }

      .adjust-badge.status-pending {
        background: rgba(255, 255, 255, 0.08);
        color: #f5f7fb;
      }

      .adjust-badge.status-acknowledged {
        background: rgba(45, 206, 137, 0.15);
        color: #9ff3c9;
      }

      .adjust-badge.status-running {
        background: rgba(56, 189, 248, 0.18);
        color: #b7ebff;
      }

      .adjust-badge.status-in_progress {
        background: rgba(56, 189, 248, 0.14);
        color: #b7ebff;
      }

      .adjust-badge.status-completed,
      .adjust-badge.status-succeeded {
        background: rgba(45, 206, 137, 0.15);
        color: #9ff3c9;
      }

      .adjust-badge.status-cancelled,
      .adjust-badge.status-terminated,
      .adjust-badge.status-timedout {
        background: rgba(255, 193, 7, 0.18);
        color: #ffe8a3;
      }

      .adjust-badge.status-failed {
        background: rgba(239, 71, 111, 0.18);
        color: #ffb3c1;
      }

      .adjust-badge.status-expired {
        background: rgba(255, 193, 7, 0.18);
        color: #ffe8a3;
      }

      .grvt-account-card {
        background: #1f2533;
        border-radius: 12px;
        padding: 1.25rem;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .grvt-account-card header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        margin-bottom: 0.9rem;
      }

      .grvt-account-name {
        font-weight: 600;
        font-size: 1.05rem;
      }

      .grvt-account-updated {
        font-size: 0.75rem;
        color: #8a94a6;
      }

      .grvt-account-metrics {
        display: grid;
        gap: 0.45rem;
        margin: 0 0 0.75rem;
      }

      .grvt-account-metrics div {
        display: flex;
        justify-content: space-between;
        font-variant-numeric: tabular-nums;
        font-size: 0.9rem;
      }

      .grvt-account-metrics dt {
        margin: 0;
        text-transform: uppercase;
        font-size: 0.75rem;
        color: #7f8fa9;
        letter-spacing: 0.05em;
      }

      .grvt-account-metrics dd {
        margin: 0;
        font-weight: 600;
      }

      .grvt-positions-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.8rem;
      }

      .grvt-positions-table thead {
        background: rgba(255, 255, 255, 0.04);
      }

      .grvt-positions-table th,
      .grvt-positions-table td {
        padding: 0.4rem 0.45rem;
        text-align: right;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        white-space: nowrap;
      }

      .grvt-positions-table th:first-child,
      .grvt-positions-table td:first-child {
        text-align: left;
      }

      .grvt-positions-empty {
        margin: 0;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .grvt-source-badge {
        display: inline-flex;
        align-items: center;
        padding: 0.1rem 0.5rem;
        border-radius: 999px;
        font-size: 0.7rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        background: #1f2a38;
        color: #a4d5ff;
        margin-left: 0.5rem;
      }

      .strategy-summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1.25rem;
      }

      .summary-sub {
        margin-top: 0.5rem;
        font-size: 0.85rem;
        color: #8a94a6;
      }

      #para-source-updates {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem 0.5rem;
        align-items: flex-start;
      }

      #para-source-updates .badge {
        flex: 1 1 70%;
        max-width: 70%;
        white-space: normal;
        overflow-wrap: anywhere;
      }

      .strategy-table-wrapper {
        margin-top: 1.5rem;
        overflow-x: auto;
      }

      .strategy-selector-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .strategy-selector-label select {
        background: #1f2533;
        color: #f5f7fb;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 6px;
        padding: 0.35rem 0.65rem;
        font-size: 0.85rem;
      }

      table.strategy-table td.action-enter {
        color: #7ee787;
      }

      table.strategy-table td.action-exit {
        color: #ffa94d;
      }

      table.strategy-table td.action-forced {
        color: #ff8787;
      }

      table.strategy-table td.action-other {
        color: #c7d2e8;
      }

      .spread-card {
        background: #1b1d24;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      .spread-chart-wrapper {
        height: 280px;
        margin-bottom: 1.5rem;
      }

      .spread-chart-wrapper canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .spread-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin-bottom: 1rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .spread-table-wrapper {
        overflow-x: auto;
      }

      table.spread-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
      }

      table.spread-table thead {
        background: #222635;
      }

      table.spread-table th,
      table.spread-table td {
        padding: 0.65rem 0.75rem;
        text-align: right;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        white-space: nowrap;
      }

      table.spread-table th:first-child,
      table.spread-table td:first-child {
        text-align: left;
      }

      .spread-selector-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
        color: #7f8fa9;
      }

      .spread-selector-label select {
        background: #1f2533;
        color: #f5f7fb;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 6px;
        padding: 0.35rem 0.65rem;
        font-size: 0.85rem;
      }

      .card h2 {
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        margin: 0 0 0.75rem;
        color: #7f8fa9;
      }

      .value {
        font-size: 2rem;
        font-weight: 600;
      }

      #runtime.runtime-multiple {
        font-size: 1.15rem;
        font-weight: 500;
        line-height: 1.4;
      }

      #runtime .runtime-row {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 0.75rem;
      }

      #runtime .runtime-row + .runtime-row {
        margin-top: 0.35rem;
      }

      #runtime .runtime-row-label {
        font-weight: 600;
        color: #c7d2e8;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        font-size: 0.9rem;
      }

      #runtime .runtime-row-value {
        font-variant-numeric: tabular-nums;
        color: #f2f4f8;
        font-size: 1rem;
      }

      .updated {
        margin-top: 2rem;
        color: #7f8fa9;
        font-size: 0.85rem;
      }

      .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem 1.25rem;
        margin-top: 2.5rem;
        margin-bottom: 1rem;
      }

      .section-header-info {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .section-header h2 {
        margin: 0;
        font-size: 1.25rem;
      }

      .section-header-controls {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        padding: 0.15rem 0.6rem;
        border-radius: 999px;
        font-size: 0.72rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        background: #273042;
        color: #c7d2e8;
      }

      .badge-group {
        display: inline-flex;
        gap: 0.35rem;
        align-items: center;
      }

      .badge-muted {
        background: #1f2533;
        color: #8a94a6;
      }

      .badge-warn {
        background: #4a1f1f;
        color: #ffc9c9;
      }

      .badge-info {
        background: #19314d;
        color: #a4d5ff;
      }

      .agent-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1.25rem;
      }

      .agent-card {
        transition: box-shadow 0.25s ease, transform 0.25s ease;
        border: 1px solid transparent;
      }

      .agent-card.recent {
        box-shadow: 0 0 0 2px rgba(76, 201, 240, 0.25);
      }

      .agent-card.stale {
        border-color: rgba(255, 171, 64, 0.45);
        opacity: 0.7;
      }

      .agent-card.paused {
        border-color: rgba(125, 140, 170, 0.35);
        background: #202431;
      }

      .agent-card header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.1rem;
      }

      .agent-name {
        font-weight: 600;
        font-size: 1.05rem;
        color: #f5f7fb;
      }

      .agent-metrics {
        display: grid;
        gap: 0.6rem;
        margin: 0;
      }

      .agent-metrics div {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
      }

      .agent-metrics dt {
        margin: 0;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #7f8fa9;
      }

      .agent-metrics dd {
        margin: 0;
        font-weight: 600;
        font-size: 1.25rem;
      }

      .timestamp {
        margin-top: 1.25rem;
        font-size: 0.8rem;
        color: #8a94a6;
      }

      .control-actions {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.25rem;
        align-items: center;
      }

      .updated-note {
        color: #8a94a6;
        font-size: 0.75rem;
      }

      button {
        appearance: none;
        border: none;
        border-radius: 6px;
        padding: 0.55rem 1.1rem;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        background: linear-gradient(135deg, #2b63ff, #7a62ff);
        color: #f5f7fb;
        box-shadow: 0 10px 25px rgba(43, 99, 255, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 14px 28px rgba(43, 99, 255, 0.25);
      }

      button:disabled {
        cursor: wait;
        opacity: 0.65;
        box-shadow: none;
      }

      .button-danger {
        background: linear-gradient(135deg, #ef476f, #ff9a5a);
      }

      .button-success {
        background: linear-gradient(135deg, #2dce89, #28a745);
      }

      .button-ghost {
        background: rgba(39, 48, 66, 0.6);
        color: #dbe4ff;
      }

      .empty {
        margin: 1rem 0 0;
        color: #8a94a6;
        font-size: 0.9rem;
      }

      .hidden {
        display: none !important;
      }

      .dashboard-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1.5rem;
        flex-wrap: wrap;
      }

      .logout-button {
        min-width: 140px;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .logout-button:hover {
          background: rgba(255, 255, 255, 0.2);
          border: 1px solid rgba(255, 255, 255, 0.4);
        }


      /* Prevent long values from breaking layout */
      .value,
      .summary-sub,
      .grvt-risk-detail,
      .grvt-summary-updated,
      .risk-settings-message,
      .risk-meta,
      .grvt-adjust-status,
      .grvt-transfer-status,
      .grvt-auto-actions p,
      .grvt-auto-list li,
      .grvt-transfer-history td,
      .grvt-adjust-history td,
      .risk-history-table td,
      .agent-metrics dd,
      .timestamp {
        word-break: break-word;
        overflow-wrap: anywhere;
      }

      @media (max-width: 640px) {
        body {
          padding: 1.25rem;
        }

        h1 {
          font-size: 1.4rem;
        }

        .dashboard-top {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.75rem;
        }

        .section-header {
          flex-direction: column;
          align-items: flex-start;
          margin-top: 1.75rem;
        }

        .section-header-info,
        .section-header-controls {
          width: 100%;
          justify-content: space-between;
        }

        .badge-group {
          flex-wrap: wrap;
        }

        .card,
        .grvt-card,
        .sim-card,
        .vol-card,
        .sim-section .sim-card {
          padding: 1.1rem;
        }

        .value {
          font-size: 1.5rem;
        }

        .summary-sub {
          font-size: 0.85rem;
        }

        .grid,
        .grvt-summary-grid {
          grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        }

        .grvt-account-grid {
          grid-template-columns: 1fr;
        }

        .grvt-summary-grid,
        .grvt-adjust-controls,
        .grvt-transfer-grid,
        .grvt-auto-grid,
        .risk-settings-grid,
        .vol-symbol-grid,
        .sim-controls,
        .grvt-auto-status-grid {
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        .section-header h2 {
          font-size: 1.1rem;
        }

        .badge,
        .button,
        .logout-button {
          font-size: 0.85rem;
        }

        .grvt-adjust-buttons,
        .grvt-auto-actions,
        .risk-actions-left,
        .section-header-controls {
          gap: 0.5rem;
          flex-wrap: wrap;
        }

        /* Tables become horizontally scrollable on narrow screens */
        .grvt-adjust-history table,
        .grvt-transfer-history table,
        .risk-history-table,
        .vol-metric-table,
        .strategy-table,
        .spread-table,
        .grvt-auto-status-grid table {
          display: block;
          overflow-x: auto;
          white-space: nowrap;
        }
      }
    </style>
  </head>
  <body>
    <div class="dashboard-layout">
      <aside class="dashboard-sidebar" aria-label="Dashboard navigation">
        <!-- sidebar removed: filter bar moved to top -->
      </aside>

      <main class="dashboard-main">
        <div class="dashboard-top">
          <div>
            <h1>Hedging Cycle Overview</h1>
            <p class="subtitle">Live metrics reported by the Aster–Lighter hedging executor.</p>
          </div>
          <form id="logout-form" method="post" action="/logout">
            <button type="submit" class="logout-button">退出登录</button>
          </form>
        </div>

        <div class="dashboard-filterbar" aria-label="Dashboard filter bar">
          <p class="dashboard-filterbar-title">面板筛选</p>
          <button type="button" class="sidebar-filter active" data-filter="all">全部</button>
          <button type="button" class="sidebar-filter" data-filter="para">PARA</button>
          <button type="button" class="sidebar-filter" data-filter="grvt">GRVT</button>
          <button type="button" class="sidebar-filter" data-filter="bp">Backpack</button>
        </div>

    <section class="grvt-section" data-exchange="para">
      <div class="section-header">
        <div class="section-header-info">
          <h2>PARA Multi-Account Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="para-account-count">0 accounts</span>
          </div>
        </div>
        <div class="section-header-controls"></div>
      </div>
      <p class="empty" id="para-empty">Waiting for PARA monitor…</p>
      <div class="grvt-card hidden" id="para-card">
        <div class="grvt-summary-grid">
          <article class="card grvt-summary-card">
            <h3>Total PnL</h3>
            <div class="value" id="para-total-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>Max IM Req</h3>
            <div class="value" id="para-max-im-req">--</div>
            <p class="summary-sub">max(initial_margin_requirement)</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Net Equity</h3>
            <div class="value" id="para-total-equity">--</div>
            <p class="summary-sub" id="para-wallet-balance">Wallet --</p>
            <div class="value risk-pill risk-pill-summary" id="para-risk-level">--</div>
            <p class="grvt-risk-detail" id="para-risk-detail">Awaiting data…</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Avg Maint</h3>
            <div class="value" id="para-avg-maint">--</div>
            <p class="summary-sub">(Σ maint req / Σ equity)</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Last Update</h3>
            <div class="value" id="para-summary-time">--</div>
            <p class="grvt-summary-updated" id="para-summary-updated">Updated —</p>
            <div class="summary-sub" id="para-source-updates"></div>
          </article>
          <article class="card grvt-summary-card" id="para-reduce-suggestion-card">
            <h3>减仓建议</h3>
            <div class="value" id="para-reduce-suggestion-main">--</div>
            <p class="summary-sub" id="para-reduce-suggestion-detail">等待账户与持仓数据…</p>
          </article>
        </div>
        <div>
          <h3 style="margin-bottom: 0.75rem; font-size: 1rem;">Per Account Net PnL</h3>
          <div class="grvt-account-grid" id="para-account-grid"></div>
          <p class="empty hidden" id="para-accounts-empty">No account data yet…</p>
        </div>
          <div class="grvt-adjust-panel" id="para-adjust-panel">
            <div class="grvt-adjust-header">
              <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">PARA Position Adjustments</h3>
              <p class="summary-sub" style="margin: 0;">广播加/减仓指令到 PARA VPS</p>
            </div>
            <div class="grvt-adjust-controls">
              <label for="para-adjust-symbols" class="grvt-adjust-symbols">
                <div class="grvt-symbol-label">
                  <span>目标币种</span>
                  <small>选择需要调整的币种；未选中时广播所有</small>
                </div>
            <div class="summary-sub" id="grvt-adjust-scope">当前广播：GRVT 监控</div>
                  <select id="para-adjust-symbols"></select>
                  <button type="button" class="grvt-symbol-reset" id="para-reset-symbol">清空</button>
                </div>
              </label>
              <label>
                Size
                <input type="number" id="para-adjust-size" min="0.01" step="0.01" value="1" />
              </label>
              <label>
                下单方式
                <select id="para-order-mode">
                  <option value="market">市价</option>
                  <option value="twap" selected>TWAP</option>
                </select>
              </label>
              <label id="para-twap-duration-wrapper">
                TWAP 时长 (秒)
                <input type="number" id="para-twap-duration" min="30" max="86400" step="30" value="900" />
                <small style="color: #8a94a6;">30-86400，30 秒步进</small>
              </label>
              <div class="grvt-adjust-buttons">
                <button type="button" id="para-adjust-add">加仓</button>
                <button type="button" class="button-danger" id="para-adjust-reduce">减仓</button>
              </div>
              <p class="grvt-adjust-status" id="para-adjust-status">等待指令…</p>
            </div>

            <div class="grvt-adjust-controls" style="margin-top: 0.9rem; border-top: 1px solid rgba(255,255,255,0.08); padding-top: 0.9rem;">
              <div class="grvt-adjust-header" style="margin-bottom: 0.6rem; width: 100%; flex: 0 0 100%;">
                <h3 style="margin: 0 0 0.2rem; font-size: 0.95rem;">定时 TWAP 广播（PARA）</h3>
                <p class="summary-sub" style="margin: 0;">按固定间隔自动发起广播（TWAP）；币种在本模块单独选择</p>
              </div>
              <label for="para-twap-schedule-symbols" class="grvt-adjust-symbols">
                <div class="grvt-symbol-label">
                  <span>定时目标币种</span>
                  <small>必须选择一个币种（不支持全币种广播）</small>
                </div>
                <div class="grvt-symbol-input">
                  <select id="para-twap-schedule-symbols"></select>
                  <button type="button" class="grvt-symbol-reset" id="para-twap-schedule-reset-symbol">清空</button>
                </div>
              </label>
              <label>
                间隔 (秒)
                <input type="number" id="para-twap-schedule-interval" min="30" max="86400" step="30" value="900" />
              </label>
              <div class="summary-sub" id="para-twap-schedule-edit-hint">当前：新增任务</div>
              <label>
                动作
                <select id="para-twap-schedule-action">
                  <option value="add" selected>加仓</option>
                  <option value="reduce">减仓</option>
                </select>
              </label>
              <label>
                Size
                <input type="number" id="para-twap-schedule-size" min="0.01" step="0.01" value="1" />
              </label>
              <label>
                TWAP 时长 (秒)
                <input type="number" id="para-twap-schedule-duration" min="30" max="86400" step="30" value="900" />
                <small style="color: #8a94a6;">30-86400，30 秒步进</small>
              </label>
              <div class="grvt-adjust-buttons">
                <button type="button" id="para-twap-schedule-start">新增并保存</button>
                <button type="button" id="para-twap-schedule-save-edit" disabled>保存修改</button>
                <button type="button" class="button-danger" id="para-twap-schedule-stop">停用全部</button>
                <button type="button" id="para-twap-schedule-refresh">刷新</button>
              </div>
              <p class="grvt-adjust-status" id="para-twap-schedule-status">未启用</p>

              <div style="margin-top: 0.6rem; padding: 0.6rem; border: 1px solid rgba(255,255,255,0.08); border-radius: 10px;">
                <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;">
                  <div>
                    <strong>定时任务列表</strong>
                    <div class="summary-sub" style="margin-top: 0.15rem;">新增：填表后点“新增并保存”。编辑：点任务的“编辑”，改表单后点“保存修改”。</div>
                  </div>
                </div>
                <div id="paraTwapScheduleTasks" style="margin-top: 0.5rem;"></div>
              </div>
            </div>

            <div class="grvt-adjust-history" style="margin-top: 0.85rem;">
              <table>
                <thead>
                  <tr>
                    <th rowspan="2">时间</th>
                    <th rowspan="2">动作</th>
                    <th rowspan="2">数量</th>
                    <th rowspan="2">币种</th>
                    <th rowspan="2">状态</th>
                    <th colspan="4" style="text-align:center;">VPS 明细</th>
                  </tr>
                  <tr>
                    <th>节点</th><th>下单</th><th>均价</th><th>成交</th>
                  </tr>
                </thead>
                <tbody id="para-adjust-history"><tr><td colspan="9">暂无记录</td></tr></tbody>
              </table>
            </div>

            <div class="grvt-adjust-history" style="margin-top: 0.85rem;">
              <table>
                <thead>
                  <tr>
                    <th>创建时间</th>
                    <th>动作</th>
                    <th>数量</th>
                    <th>币种</th>
                    <th>完成次数</th>
                    <th>成交总数量</th>
                    <th>每万成交额磨损</th>
                    <th>累计磨损</th>
                  </tr>
                </thead>
                <tbody id="para-twap-schedule-history"><tr><td colspan="8">暂无定时记录</td></tr></tbody>
              </table>
            </div>
          </div>
          <div class="grvt-transfer-panel hidden" id="para-transfer-panel">
            <div class="grvt-adjust-header">
              <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">PARA 账户间资金划转</h3>
              <p class="summary-sub" style="margin: 0;">默认方向：来源账户 → 目标 L2 地址</p>
            </div>
            <div class="grvt-transfer-grid">
              <label>
                来源账户
                <select id="para-transfer-source"></select>
              </label>
              <label>
                目标账户
                <select id="para-transfer-target"></select>
              </label>
              <label>
                目标 L2 地址
                <input type="text" id="para-transfer-target-address" placeholder="0x..." />
              </label>
              <label>
                数量
                <input type="number" id="para-transfer-amount" min="0" step="0.01" value="0" />
              </label>
              <label>
                币种
                <input type="text" id="para-transfer-currency" value="USDC" />
              </label>
              <label>
                Transfer 类型
                <input type="text" id="para-transfer-type" value="spot" />
              </label>
              <label>
                备注（可选）
                <textarea id="para-transfer-reason" placeholder="记录用途或审批信息"></textarea>
              </label>
            </div>
            <div class="grvt-transfer-actions">
              <button type="button" id="para-transfer-submit">提交互转</button>
              <p class="grvt-transfer-status" id="para-transfer-status">等待指令…</p>
            </div>
            <div class="grvt-transfer-history">
              <table>
                <thead>
                  <tr>
                    <th>时间</th>
                    <th>来源 / 目标</th>
                    <th>方向</th>
                    <th>金额</th>
                    <th>路径</th>
                    <th>状态 / 备注</th>
                  </tr>
                </thead>
                <tbody id="para-transfer-history"></tbody>
              </table>
            </div>
          </div>
            <div class="grvt-risk-panel" id="para-risk-panel">
              <div class="grvt-adjust-header">
                <div>
                  <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">Bark 告警（PARA）</h3>
                  <p class="summary-sub" style="margin: 0;">针对 PARA 账户权益风险的 Bark 推送配置</p>
                </div>
                <div class="risk-status-pill" id="para-risk-settings-status">加载中…</div>
              </div>
              <div class="risk-settings-grid">
                <section class="risk-settings-card">
                  <div class="risk-toggle">
                    <input type="checkbox" id="para-risk-alert-enabled" />
                    <span>启用风险告警</span>
                  </div>
                  <div class="risk-slider">
                    <label class="risk-slider-label" for="para-risk-threshold-slider">
                      <span id="para-risk-threshold-label">阈值 --%</span>
                    </label>
                    <input type="range" id="para-risk-threshold-slider" min="5" max="90" step="0.5" value="30" />
                    <div class="risk-slider-scale">
                      <span>5%</span>
                      <span>25%</span>
                      <span>50%</span>
                      <span>90%</span>
                    </div>
                  </div>
                  <div class="risk-inline-inputs">
                    <label>
                      触发阈值 (%)
                      <input type="number" id="para-risk-threshold-input" min="1" max="90" step="0.5" />
                    </label>
                    <label>
                      重置阈值 (%)
                      <input type="number" id="para-risk-reset-input" min="1" max="90" step="0.5" />
                    </label>
                    <label>
                      冷却 (分钟)
                      <input type="number" id="para-risk-cooldown-input" min="0" max="360" step="1" />
                    </label>
                  </div>
                  <p class="risk-meta" id="para-risk-ratio-meta">等待风险数据…</p>
                </section>
                <section class="risk-settings-card">
                  <div class="risk-bark-grid">
                    <label>
                      Bark URL
                      <input type="text" id="para-risk-bark-url" placeholder="https://api.day.app/xxxxx/%7Btitle%7D/%7Bbody%7D" />
                    </label>
                    <label>
                      请求超时 (秒)
                      <input type="number" id="para-risk-bark-timeout" min="1" max="60" step="0.5" />
                    </label>
                  </div>
                </section>
              </div>
              <div class="risk-settings-actions">
                <div class="risk-actions-left">
                  <button type="button" id="para-risk-settings-save">保存配置</button>
                  <button type="button" class="button-success" id="para-risk-settings-test">测试 Bark</button>
                  <button type="button" class="button-ghost" id="para-risk-settings-refresh">重新读取</button>
                  <button type="button" class="button-danger" id="para-risk-settings-disable">关闭告警</button>
                </div>
                <p class="risk-settings-message" id="para-risk-settings-message">未加载</p>
                <p class="risk-settings-message" id="para-risk-test-message"></p>
              </div>
              <div class="risk-history-card">
                <div class="risk-history-header">
                  <h3>告警历史 (PARA)</h3>
                  <button type="button" class="button-ghost" id="para-risk-history-refresh">刷新</button>
                </div>
                <p class="risk-history-status" id="para-risk-history-status">等待告警数据…</p>
                <div class="risk-history-table-wrapper">
                  <table class="risk-history-table">
                    <thead>
                      <tr>
                        <th>时间</th>
                        <th>来源</th>
                        <th>账户</th>
                        <th>风险%</th>
                        <th>亏损 / 裕量</th>
                      </tr>
                    </thead>
                    <tbody id="para-risk-history-body"></tbody>
                  </table>
                  <p class="risk-history-empty hidden" id="para-risk-history-empty">暂无告警</p>
                </div>
              </div>
            </div>
          <div class="grvt-auto-panel" id="para-auto-panel">
            <div class="grvt-adjust-header">
              <div>
                <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">PARA 自动平衡</h3>
                <p class="summary-sub" style="margin: 0;">根据阈值在两个 PARA 账户间自动划转</p>
              </div>
              <span class="grvt-auto-pair" id="para-auto-pair">未配置</span>
            </div>
            <div class="grvt-auto-grid">
              <label class="grvt-auto-toggle">
                <span>启用自动平衡</span>
                <small>开启后根据阈值自动在两个账户之间划转</small>
                <input type="checkbox" id="para-auto-enabled" />
              </label>
              <label>
                账户 A
                <select id="para-auto-agent-a"></select>
              </label>
              <label>
                账户 B
                <select id="para-auto-agent-b"></select>
              </label>
              <label>
                阈值（%）
                <input type="number" id="para-auto-threshold" min="0" step="0.1" placeholder="15" />
              </label>
              <label>
                最小划转
                <input type="number" id="para-auto-min-transfer" min="0" step="0.01" placeholder="1000" />
              </label>
              <label>
                最大划转（可选）
                <input type="number" id="para-auto-max-transfer" min="0" step="0.01" placeholder="5000" />
              </label>
              <label>
                币种
                <input type="text" id="para-auto-currency" value="USDC" />
              </label>
              <label>
                冷却（秒）
                <input type="number" id="para-auto-cooldown" min="0" step="1" placeholder="900" />
              </label>
              <label>
                使用可划转余额
                <div class="grvt-auto-checkbox">
                  <input type="checkbox" id="para-auto-use-available" />
                  <span>prefer transferable balance</span>
                </div>
                <small>优先比较 available_equity，波动大时更稳健</small>
              </label>
            </div>
            <div class="grvt-auto-actions">
              <button type="button" id="para-auto-save">保存配置</button>
              <button type="button" class="button-danger" id="para-auto-disable">停用</button>
              <button type="button" class="button-ghost" id="para-auto-refresh">刷新状态</button>
              <p id="para-auto-status">等待配置…</p>
            </div>
            <div class="grvt-auto-status-grid">
              <div>
                <h4>实时测量</h4>
                <ul class="grvt-auto-list" id="para-auto-measurement">
                  <li>尚未收到差值数据</li>
                </ul>
              </div>
              <div>
                <h4>最近执行</h4>
                <ul class="grvt-auto-list" id="para-auto-last-action">
                  <li>无执行记录</li>
                </ul>
              </div>
            </div>
          </div>
          <div class="grvt-chart-card hidden" id="para-price-chart-wrapper">
            <div class="grvt-chart-header">
              <h3>BTC / ETH Δ%</h3>
              <span class="summary-sub" id="para-price-chart-note">等待数据…</span>
            </div>
            <canvas id="para-price-chart"></canvas>
            <div class="chart-legend" id="para-price-chart-legend">
              <span><span class="legend-dot legend-btc"></span>BTC (相对首笔)</span>
              <span><span class="legend-dot legend-eth"></span>ETH (相对首笔)</span>
            </div>
          </div>
      </div>
    </section>

    <!-- BTC/ETH Volatility Signals removed -->
    <!-- BTC/ETH Pair Simulation removed -->

    <section class="grvt-section" data-exchange="grvt">
      <div class="section-header">
        <div class="section-header-info">
          <h2>GRVT Multi-Account Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="grvt-account-count">0 accounts</span>
          </div>
        </div>
        <div class="section-header-controls"></div>
      </div>
      <p class="empty" id="grvt-empty">Waiting for GRVT monitor…</p>
      <div class="grvt-card hidden" id="grvt-card">
        <div class="grvt-summary-grid">
          <article class="card grvt-summary-card">
            <h3>Total PnL</h3>
            <div class="value" id="grvt-total-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>Net Equity</h3>
            <div class="value" id="grvt-total-equity">--</div>
            <p class="summary-sub" id="grvt-wallet-balance">Wallet --</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>持仓金额</h3>
            <div class="value" id="grvt-total-position">--</div>
            <p class="summary-sub">两个账号合计持仓名义金额</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>净持仓金额</h3>
            <div class="value" id="grvt-total-position-net">--</div>
            <p class="summary-sub">按账号统计净持仓名义金额</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>风险基数</h3>
            <div class="value" id="grvt-transfer-total">--</div>
            <p class="summary-sub" id="grvt-transfer-note">Σ Equity - Σ 初始保证金</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Risk Level</h3>
            <div class="value risk-pill risk-pill-summary" id="grvt-risk-level">--</div>
            <p class="grvt-risk-detail" id="grvt-risk-detail">Awaiting data…</p>
          </article>
          <article class="card grvt-summary-card" id="grvt-reduce-suggestion-card">
            <h3>减仓建议</h3>
            <div class="value" id="grvt-reduce-suggestion-main">--</div>
            <p class="summary-sub" id="grvt-reduce-suggestion-detail">等待账户与持仓数据…</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Last Update</h3>
            <div class="value" id="grvt-summary-time">--</div>
            <p class="grvt-summary-updated" id="grvt-summary-updated">Updated —</p>
            <div class="summary-sub" id="grvt-source-updates"></div>
          </article>
        </div>
        <div>
          <h3 style="margin-bottom: 0.75rem; font-size: 1rem;">Per Account Net PnL</h3>
          <div class="grvt-account-grid" id="grvt-account-grid"></div>
          <p class="empty hidden" id="grvt-accounts-empty">No account data yet…</p>
        </div>
        <div class="grvt-risk-panel" id="grvt-risk-panel">
          <div class="grvt-adjust-header">
            <div>
              <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">Bark 风险告警</h3>
              <p class="summary-sub" style="margin: 0;">将原 CLI 阈值迁移到面板，实时调节风险和推送模板</p>
            </div>
            <div class="risk-status-pill" id="risk-settings-status">加载中…</div>
          </div>
          <div class="risk-settings-grid">
            <section class="risk-settings-card">
              <div class="risk-toggle">
                <input type="checkbox" id="risk-alert-enabled" />
                <span>启用风险告警</span>
              </div>
              <div class="risk-slider">
                <label class="risk-slider-label" for="risk-threshold-slider">
                  <span id="risk-threshold-label">阈值 --%</span>
                </label>
                <input type="range" id="risk-threshold-slider" min="5" max="90" step="0.5" value="30" />
                <div class="risk-slider-scale">
                  <span>5%</span>
                  <span>25%</span>
                  <span>50%</span>
                  <span>90%</span>
                </div>
              </div>
              <div class="risk-inline-inputs">
                <label>
                  触发阈值 (%)
                  <input type="number" id="risk-threshold-input" min="1" max="90" step="0.5" />
                </label>
                <label>
                  冷却 (分钟)
                  <input type="number" id="risk-cooldown-input" min="0" max="360" step="1" />
                </label>
              </div>
              <p class="risk-meta" id="risk-ratio-meta">等待风险数据…</p>
            </section>
            <section class="risk-settings-card">
              <div class="risk-toggle">
                <input type="checkbox" id="risk-stale-enabled" />
                <span>启用数据不新鲜告警</span>
              </div>
              <div class="risk-inline-inputs">
                <label>
                  判定阈值 (秒)
                  <input type="number" id="risk-stale-critical-input" min="1" max="86400" step="1" />
                </label>
              </div>
              <p class="risk-meta">超过阈值将推送“数据不新鲜”告警（使用 Bark 风险告警的 URL）。</p>
            </section>
            <section class="risk-settings-card">
              <div class="risk-bark-grid">
                <label>
                  Bark URL
                  <input type="text" id="risk-bark-url" placeholder="https://api.day.app/xxxxx/%7Btitle%7D/%7Bbody%7D" />
                </label>
                <label class="risk-toggle">
                  <input type="checkbox" id="risk-bark-append" checked />
                  <span>缺少 {title}/{body} 时自动附加</span>
                </label>
                <label>
                  请求超时 (秒)
                  <input type="number" id="risk-bark-timeout" min="1" max="60" step="0.5" />
                </label>
                <label>
                  标题模板
                  <textarea id="risk-title-template" rows="2"></textarea>
                </label>
                <label>
                  正文模板
                  <textarea id="risk-body-template" rows="3"></textarea>
                </label>
              </div>
            </section>
          </div>
          <div class="risk-settings-actions">
            <div class="risk-actions-left">
              <button type="button" id="risk-settings-save">保存配置</button>
              <button type="button" class="button-success" id="risk-settings-test">测试 Bark</button>
              <button type="button" class="button-ghost" id="risk-settings-refresh">重新读取</button>
              <button type="button" class="button-danger" id="risk-settings-disable">关闭告警</button>
            </div>
            <p class="risk-settings-message" id="risk-settings-message">未加载</p>
            <p class="risk-settings-message" id="risk-test-message"></p>
          </div>
          <div class="risk-history-card">
            <div class="risk-history-header">
              <h3>告警历史</h3>
              <button type="button" class="button-ghost" id="risk-history-refresh">刷新</button>
            </div>
            <p class="risk-history-status" id="risk-history-status">等待告警数据…</p>
            <div class="risk-history-table-wrapper">
              <table class="risk-history-table">
                <thead>
                  <tr>
                    <th>时间</th>
                    <th>来源</th>
                    <th>账户</th>
                    <th>风险%</th>
                    <th>亏损 / 基数</th>
                  </tr>
                </thead>
                <tbody id="risk-history-body"></tbody>
              </table>
              <p class="risk-history-empty hidden" id="risk-history-empty">暂无告警</p>
            </div>
          </div>
        </div>
        <div class="grvt-chart-grid">
          <div class="grvt-chart-card hidden" id="grvt-price-chart-wrapper">
            <div class="grvt-chart-header">
              <h3>BTC / ETH Δ%</h3>
              <span class="summary-sub" id="grvt-price-chart-note">等待数据…</span>
            </div>
            <canvas id="grvt-price-chart"></canvas>
            <div class="chart-legend" id="grvt-price-chart-legend">
              <span><span class="legend-dot legend-btc"></span>BTC (相对首笔)</span>
              <span><span class="legend-dot legend-eth"></span>ETH (相对首笔)</span>
            </div>
          </div>
        </div>
        <div class="grvt-adjust-panel" id="grvt-adjust-panel">
          <div class="grvt-adjust-header">
            <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">GRVT Position Adjustments</h3>
            <p class="summary-sub" style="margin: 0;">广播加/减仓指令到 GRVT VPS</p>
          </div>
          <div class="grvt-adjust-controls">
            <label for="grvt-adjust-symbols" class="grvt-adjust-symbols">
              <div class="grvt-symbol-label">
                <span>目标币种</span>
                <small>选择需要调整的币种；未选中时广播所有</small>
              </div>
              <div class="grvt-symbol-input">
                <select id="grvt-adjust-symbols"></select>
                <button type="button" class="grvt-symbol-reset" id="grvt-reset-symbol">清空</button>
              </div>
            </label>
            <label for="grvt-adjust-size">
              Size
              <input type="number" id="grvt-adjust-size" min="0.01" step="0.01" value="1" />
            </label>
            <div class="grvt-adjust-buttons">
              <button type="button" id="grvt-adjust-add">加仓</button>
              <button type="button" class="button-danger" id="grvt-adjust-reduce">减仓</button>
            </div>
            <p class="grvt-adjust-status" id="grvt-adjust-status">等待指令…</p>
            <p class="summary-sub" id="grvt-adjust-scope">当前广播：GRVT 监控</p>
          </div>
          <div class="grvt-adjust-history">
            <table>
              <thead>
                <tr>
                  <th>时间</th>
                  <th>动作</th>
                  <th>数量</th>
                  <th>币种</th>
                  <th>状态</th>
                  <th>节点</th>
                </tr>
              </thead>
              <tbody id="grvt-adjust-history"></tbody>
            </table>
          </div>
        </div>
        <div class="grvt-transfer-panel hidden" id="grvt-transfer-panel">
          <div class="grvt-adjust-header">
            <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">账户间资金划转</h3>
            <p class="summary-sub" style="margin: 0;">默认方向：来源账户 → 目标账户</p>
          </div>
          <div class="grvt-transfer-grid">
            <label>
              来源账户
              <select id="grvt-transfer-source"></select>
            </label>
            <label>
              目标账户
              <select id="grvt-transfer-target"></select>
            </label>
            <label>
              数量
              <input type="number" id="grvt-transfer-amount" min="0" step="0.01" value="0" />
            </label>
            <label>
              币种
              <input type="text" id="grvt-transfer-currency" value="USDT" />
            </label>
            <label>
              Transfer 类型
              <input type="text" id="grvt-transfer-type" value="spot" />
            </label>
            <label>
              备注（可选）
              <textarea id="grvt-transfer-reason" placeholder="记录用途或审批信息"></textarea>
            </label>
          </div>
          <div class="grvt-transfer-grid">
            <label>
              From Account ID
              <input type="text" id="grvt-transfer-from-account" />
            </label>
            <label>
              From Sub Account ID
              <input type="text" id="grvt-transfer-from-sub" />
            </label>
            <label>
              To Account ID
              <input type="text" id="grvt-transfer-to-account" />
            </label>
            <label>
              To Sub Account ID
              <input type="text" id="grvt-transfer-to-sub" />
            </label>
          </div>
          <div class="grvt-transfer-actions">
            <button type="button" id="grvt-transfer-submit">提交互转</button>
            <p class="grvt-transfer-status" id="grvt-transfer-status">等待指令…</p>
          </div>
          <div class="grvt-transfer-history">
            <table>
              <thead>
                <tr>
                  <th>时间</th>
                  <th>来源 / 目标</th>
                  <th>方向</th>
                  <th>金额</th>
                  <th>路径</th>
                  <th>状态 / 备注</th>
                </tr>
              </thead>
              <tbody id="grvt-transfer-history"></tbody>
            </table>
          </div>
        </div>
        <div class="grvt-auto-panel" id="grvt-auto-panel">
          <div class="grvt-adjust-header">
            <div>
              <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">自动平衡配置</h3>
              <p class="summary-sub" style="margin: 0;">当两个账户权益差距超过阈值时自动触发互转</p>
            </div>
            <span class="grvt-auto-pair" id="grvt-auto-pair">未配置</span>
          </div>
          <div class="grvt-auto-grid">
            <label class="grvt-auto-toggle">
              <span>启用自动平衡</span>
              <small>开启后根据阈值自动在两个账户之间划转</small>
              <input type="checkbox" id="grvt-auto-enabled" />
            </label>
            <label>
              账户 A
              <select id="grvt-auto-agent-a"></select>
            </label>
            <label>
              账户 B
              <select id="grvt-auto-agent-b"></select>
            </label>
            <label>
              阈值（%）
              <input type="number" id="grvt-auto-threshold" min="0" step="0.1" placeholder="15" />
            </label>
            <label>
              最小划转
              <input type="number" id="grvt-auto-min-transfer" min="0" step="0.01" placeholder="1000" />
            </label>
            <label>
              最大划转（可选）
              <input type="number" id="grvt-auto-max-transfer" min="0" step="0.01" placeholder="5000" />
            </label>
            <label>
              币种
              <input type="text" id="grvt-auto-currency" value="USDT" />
            </label>
            <label>
              冷却（秒）
              <input type="number" id="grvt-auto-cooldown" min="0" step="1" placeholder="900" />
            </label>
            <label>
              使用可划转余额
              <div class="grvt-auto-checkbox">
                <input type="checkbox" id="grvt-auto-use-available" />
                <span>prefer transferable balance</span>
              </div>
              <small>优先比较 equity-初始保证金-正向未实现收益，波动大时更稳健</small>
            </label>
          </div>
          <div class="grvt-auto-actions">
            <button type="button" id="grvt-auto-save">保存配置</button>
            <button type="button" class="button-danger" id="grvt-auto-disable">停用</button>
            <button type="button" class="button-ghost" id="grvt-auto-refresh">刷新状态</button>
            <p id="grvt-auto-status">等待配置…</p>
          </div>
          <div class="grvt-auto-status-grid">
            <div>
              <h4>实时测量</h4>
              <ul class="grvt-auto-list" id="grvt-auto-measurement">
                <li>尚未收到差值数据</li>
              </ul>
            </div>
            <div>
              <h4>最近执行</h4>
              <ul class="grvt-auto-list" id="grvt-auto-last-action">
                <li>无执行记录</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="grvt-section" data-exchange="bp">
      <div class="section-header">
        <div class="section-header-info">
          <h2>Backpack Multi-Account Monitor</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="bp-account-count">0 accounts</span>
          </div>
        </div>
        <div class="section-header-controls"></div>
      </div>
      <p class="empty" id="bp-empty">Waiting for Backpack monitor…</p>

      <div class="grvt-card hidden" id="bp-card">
        <div class="grvt-summary-grid">
          <article class="card grvt-summary-card">
            <h3>Total PnL</h3>
            <div class="value" id="bp-total-pnl">--</div>
          </article>
          <article class="card grvt-summary-card">
            <h3>Max IM Req</h3>
            <div class="value" id="bp-max-im-req">--</div>
            <p class="summary-sub">max(init margin)</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Net Equity</h3>
            <div class="value" id="bp-total-equity">--</div>
            <p class="summary-sub" id="bp-wallet-balance">Wallet --</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>风险裕量</h3>
            <div class="value" id="bp-transfer-total">--</div>
            <p class="summary-sub" id="bp-transfer-note">Equity - 1.5×max(IM)</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Risk Level</h3>
            <div class="value risk-pill risk-pill-summary" id="bp-risk-level">--</div>
            <p class="grvt-risk-detail" id="bp-risk-detail">Awaiting data…</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Avg Maint</h3>
            <div class="value" id="bp-avg-maint">--</div>
            <p class="summary-sub">(Σ maint req / Σ equity)</p>
          </article>
          <article class="card grvt-summary-card" id="bp-reduce-suggestion-card">
            <h3>减仓建议</h3>
            <div class="value" id="bp-reduce-suggestion-main">--</div>
            <p class="summary-sub" id="bp-reduce-suggestion-detail">等待账户与持仓数据…</p>
          </article>
          <article class="card grvt-summary-card">
            <h3>Last Update</h3>
            <div class="value" id="bp-summary-time">--</div>
            <p class="grvt-summary-updated" id="bp-summary-updated">Updated —</p>
          </article>
        </div>
        <div>
          <h3 style="margin-bottom: 0.75rem; font-size: 1rem;">Per Account Snapshot</h3>
          <div class="grvt-account-grid" id="bp-account-grid"></div>
          <p class="empty hidden" id="bp-accounts-empty">No account data yet…</p>
        </div>
        <div class="grvt-adjust-panel" id="bp-adjust-panel">
          <div class="grvt-adjust-header">
            <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">Backpack Position Adjustments</h3>
            <p class="summary-sub" style="margin: 0;">广播加/减仓指令到 Backpack VPS</p>
            <div class="grvt-adjust-header-actions" style="margin-left:auto; display:flex; gap:0.5rem; align-items:center;">
              <button type="button" class="button-secondary" id="bp-adjust-clear-history">清除历史</button>
            </div>
          </div>
          <div class="grvt-adjust-controls">
            <label for="bp-adjust-symbols" class="grvt-adjust-symbols">
              <div class="grvt-symbol-label">
                <span>目标币种</span>
                <small>选择需要调整的币种；未选中时广播所有</small>
              </div>
              <div class="grvt-symbol-input">
                <select id="bp-adjust-symbols"></select>
                <button type="button" class="grvt-symbol-reset" id="bp-reset-symbol">清空</button>
              </div>
            </label>
            <label>
              Size
              <input type="number" id="bp-adjust-size" min="0.001" step="0.001" value="1" />
            </label>
            <label>
              下单方式
              <select id="bp-order-mode">
                <option value="market">市价</option>
                <option value="twap" selected>TWAP</option>
              </select>
            </label>
            <label id="bp-twap-duration-wrapper">
              TWAP 时长 (秒)
              <input type="number" id="bp-twap-duration" min="30" max="86400" step="30" value="900" />
              <small style="color: #8a94a6;">30-86400，30 秒步进</small>
            </label>
            <label id="bp-twap-step-wrapper">
              TWAP 步进 (秒)
              <input type="number" id="bp-twap-step" min="1" max="3600" step="1" value="5" />
              <small style="color: #8a94a6;">每隔多少秒下一跳；默认 5 秒</small>
            </label>
            <div class="grvt-adjust-buttons">
              <button type="button" id="bp-adjust-add">加仓</button>
              <button type="button" class="button-danger" id="bp-adjust-reduce">减仓</button>
            </div>
            <p class="grvt-adjust-status" id="bp-adjust-status">等待指令…</p>
          </div>
          <div class="grvt-adjust-history">
            <table>
              <thead>
                <tr>
                  <th>时间</th>
                  <th>动作</th>
                  <th>数量</th>
                  <th>币种</th>
                  <th>状态</th>
                  <th colspan="4" style="text-align:center;">VPS 明细</th>
                </tr>
              </thead>
              <tbody id="bp-adjust-history"><tr><td colspan="9">暂无记录</td></tr></tbody>
            </table>
          </div>
        </div>

        <div class="grvt-adjust-panel" id="bp-internal-transfer-panel" style="margin-top: 1rem;">
          <div class="grvt-adjust-header">
            <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">Backpack 内转</h3>
            <p class="summary-sub" style="margin: 0;">两个账号内部互转（监控端启动时上报自己的 internal 地址）</p>
          </div>
          <div class="grvt-adjust-controls">
            <label>
              From (源账号)
              <select id="bp-transfer-from"></select>
              <small style="color: #8a94a6;">选择要发起转账的 monitor（对应源账户）</small>
            </label>
            <label>
              To (目标账号)
              <select id="bp-transfer-to"></select>
              <small style="color: #8a94a6;">默认选择另一个账号</small>
            </label>
            <label>
              币种
              <select id="bp-transfer-symbol">
                <option value="USDC" selected>USDC</option>
              </select>
            </label>
            <label>
              数量
              <input type="number" id="bp-transfer-qty" min="0.000001" step="0.000001" value="1" />
            </label>
            <div class="grvt-adjust-buttons">
              <button type="button" id="bp-transfer-submit">发起内转</button>
            </div>
            <p class="grvt-adjust-status" id="bp-transfer-status">等待指令…</p>
          </div>

          <div class="grvt-adjust-history" style="margin-top: 0.5rem;">
            <h4 style="margin: 0 0 0.5rem; font-size: 0.95rem;">内转历史（最新 10 条）</h4>
            <table>
              <thead>
                <tr>
                  <th>时间</th>
                  <th>From</th>
                  <th>To</th>
                  <th>币种</th>
                  <th>数量</th>
                  <th>状态</th>
                  <th>备注</th>
                </tr>
              </thead>
              <tbody id="bp-transfer-history"><tr><td colspan="7">暂无记录</td></tr></tbody>
            </table>
          </div>
        </div>

        <div class="grvt-auto-panel" id="bp-auto-panel" style="margin-top: 1rem;">
          <div class="grvt-adjust-header">
            <div>
              <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">Backpack 自动平衡</h3>
              <p class="summary-sub" style="margin: 0;">根据阈值自动在两个 Backpack 账户间内转（USDC）</p>
            </div>
            <span class="grvt-auto-pair" id="bp-auto-pair">未配置</span>
          </div>
          <div class="grvt-auto-grid">
            <label class="grvt-auto-toggle">
              <span>启用自动平衡</span>
              <small>开启后根据阈值自动在两个账户之间划转</small>
              <input type="checkbox" id="bp-auto-enabled" />
            </label>
            <label>
              账户 A
              <select id="bp-auto-agent-a"></select>
            </label>
            <label>
              账户 B
              <select id="bp-auto-agent-b"></select>
            </label>
            <label>
              阈值（%）
              <input type="number" id="bp-auto-threshold" min="0" step="0.1" placeholder="15" />
            </label>
            <label>
              最小划转
              <input type="number" id="bp-auto-min-transfer" min="0" step="0.01" placeholder="1000" />
            </label>
            <label>
              最大划转（可选）
              <input type="number" id="bp-auto-max-transfer" min="0" step="0.01" placeholder="5000" />
            </label>
            <label>
              币种
              <input type="text" id="bp-auto-currency" value="USDC" readonly />
            </label>
            <label>
              冷却（秒）
              <input type="number" id="bp-auto-cooldown" min="0" step="1" placeholder="900" />
            </label>
            <label>
              使用可划转余额
              <div class="grvt-auto-checkbox">
                <input type="checkbox" id="bp-auto-use-available" />
                <span>prefer transferable balance</span>
              </div>
              <small>优先比较 available_equity，波动大时更稳健</small>
            </label>
          </div>
          <div class="grvt-auto-actions">
            <button type="button" id="bp-auto-save">保存配置</button>
            <button type="button" class="button-danger" id="bp-auto-disable">停用</button>
            <button type="button" class="button-ghost" id="bp-auto-refresh">刷新状态</button>
            <p id="bp-auto-status">等待配置…</p>
          </div>
          <div class="grvt-auto-status-grid">
            <div>
              <h4>实时测量</h4>
              <ul class="grvt-auto-list" id="bp-auto-measurement">
                <li>尚未收到差值数据</li>
              </ul>
            </div>
            <div>
              <h4>最近执行</h4>
              <ul class="grvt-auto-list" id="bp-auto-last-action">
                <li>无执行记录</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <div class="grvt-risk-panel" id="bp-risk-panel" style="margin-top: 1rem;">
        <div class="grvt-adjust-header">
          <div>
            <h3 style="margin: 0 0 0.35rem; font-size: 1rem;">Bark 告警（Backpack）</h3>
            <p class="summary-sub" style="margin: 0;">针对 Backpack 账户权益风险的 Bark 推送配置</p>
          </div>
          <div class="risk-status-pill" id="bp-risk-settings-status">加载中…</div>
        </div>
        <div class="risk-settings-grid">
          <section class="risk-settings-card">
            <div class="risk-toggle">
              <input type="checkbox" id="bp-risk-alert-enabled" />
              <span>启用风险告警</span>
            </div>
            <div class="risk-slider">
              <label class="risk-slider-label" for="bp-risk-threshold-slider">
                <span id="bp-risk-threshold-label">阈值 --%</span>
              </label>
              <input type="range" id="bp-risk-threshold-slider" min="5" max="90" step="0.5" value="30" />
              <div class="risk-slider-scale">
                <span>5%</span>
                <span>25%</span>
                <span>50%</span>
                <span>90%</span>
              </div>
            </div>
            <div class="risk-inline-inputs">
              <label>
                触发阈值 (%)
                <input type="number" id="bp-risk-threshold-input" min="1" max="90" step="0.5" />
              </label>
              <label>
                重置阈值 (%)
                <input type="number" id="bp-risk-reset-input" min="1" max="90" step="0.5" />
              </label>
              <label>
                冷却 (分钟)
                <input type="number" id="bp-risk-cooldown-input" min="0" max="360" step="1" />
              </label>
            </div>
            <p class="risk-meta" id="bp-risk-ratio-meta">等待风险数据…</p>
          </section>
          <section class="risk-settings-card">
            <div class="risk-bark-grid">
              <label>
                Bark URL
                <input type="text" id="bp-risk-bark-url" placeholder="https://api.day.app/xxxxx/%7Btitle%7D/%7Bbody%7D" />
              </label>
              <label>
                请求超时 (秒)
                <input type="number" id="bp-risk-bark-timeout" min="1" max="60" step="0.5" />
              </label>
            </div>
          </section>
        </div>
        <div class="risk-settings-actions">
          <div class="risk-actions-left">
            <button type="button" id="bp-risk-settings-save">保存配置</button>
            <button type="button" class="button-success" id="bp-risk-settings-test">测试 Bark</button>
            <button type="button" class="button-ghost" id="bp-risk-settings-refresh">重新读取</button>
            <button type="button" class="button-danger" id="bp-risk-settings-disable">关闭告警</button>
          </div>
          <p class="risk-settings-message" id="bp-risk-settings-message">未加载</p>
          <p class="risk-settings-message" id="bp-risk-test-message"></p>
        </div>
        <div class="risk-history-card">
          <div class="risk-history-header">
            <h3>告警历史 (Backpack)</h3>
            <button type="button" class="button-ghost" id="bp-risk-history-refresh">刷新</button>
          </div>
          <p class="risk-history-status" id="bp-risk-history-status">等待告警数据…</p>
          <div class="risk-history-table-wrapper">
            <table class="risk-history-table">
              <thead>
                <tr>
                  <th>时间</th>
                  <th>来源</th>
                  <th>账户</th>
                  <th>风险%</th>
                  <th>亏损 / 裕量</th>
                </tr>
              </thead>
              <tbody id="bp-risk-history-body"></tbody>
            </table>
            <p class="risk-history-empty hidden" id="bp-risk-history-empty">暂无告警</p>
          </div>
        </div>
      </div>

      <section class="grid" style="margin-top: 1rem;">
        <article class="card" style="grid-column: 1 / -1;">
          <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 1rem; flex-wrap: wrap;">
            <div>
              <h2 style="margin:0;">Backpack 刷量</h2>
              <p class="summary-sub" style="margin: .35rem 0 0;">市价买 → 市价卖（按差价阈值触发），统计成交量与磨损（含返佣后手续费）</p>
            </div>
            <span class="badge badge-muted" id="bp-volume-running">stopped</span>
          </div>

          <div class="bp-run-grid" id="bp-run-grid" style="display:none;"></div>

          <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: .75rem; margin-top: 1rem;">
            <label>
              交易对
              <select id="bp-volume-symbol"></select>
            </label>
            <label>
              单次刷量（base qty）
              <input type="number" id="bp-volume-qty" min="0" step="0.001" value="0.2" />
            </label>
            <label>
              次数（0=无限）
              <input type="number" id="bp-volume-cycles" min="0" step="1" value="0" />
            </label>
            <label>
              差价阈值（bps）
              <input type="number" id="bp-volume-max-spread-bps" min="0" step="0.1" value="2" />
            </label>
            <label>
              随机间隔最小值（ms）
              <input type="number" id="bp-volume-cooldown-min" min="0" step="1" value="0" />
            </label>
            <label>
              随机间隔最大值（ms）
              <input type="number" id="bp-volume-cooldown-max" min="0" step="1" value="0" />
            </label>
          </div>

          <div style="display:flex; gap:.75rem; align-items:center; margin-top: 1rem; flex-wrap: wrap;">
            <button type="button" class="button-success" id="bp-volume-start">启动</button>
            <button type="button" class="button-danger" id="bp-volume-stop">停止</button>
            <button type="button" class="button-secondary" id="bp-volume-clear-history">清除当前币种历史</button>
            <p class="summary-sub" id="bp-volume-status" style="margin:0;">等待配置…</p>
          </div>

          <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: .75rem; margin-top: 1rem;">
            <article class="card" style="background: rgba(79,156,255,.06); border: 1px solid rgba(79,156,255,.14);">
              <h2>买一 / 卖一</h2>
              <div class="value" id="bp-bbo-price">--</div>
              <p class="summary-sub" id="bp-bbo-meta" style="margin-top:.35rem;">--</p>
            </article>
            <article class="card" style="background: rgba(79,156,255,.06); border: 1px solid rgba(79,156,255,.14);">
              <h2>盘口容量（cap）</h2>
              <div class="value" id="bp-bbo-cap">--</div>
              <p class="summary-sub" id="bp-bbo-qty" style="margin-top:.35rem;">--</p>
            </article>
            <article class="card" style="background: rgba(79,156,255,.06); border: 1px solid rgba(79,156,255,.14);">
              <h2>预计磨损（按当前数量）</h2>
              <div class="value" id="bp-bbo-wear">--</div>
              <p class="summary-sub" id="bp-bbo-wear-meta" style="margin-top:.35rem;">--</p>
            </article>
          </div>

          <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: .75rem; margin-top: 1rem;">
            <article class="card" style="background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);">
              <h2>成交量（base）</h2>
              <div class="value" id="bp-volume-base">--</div>
            </article>
            <article class="card" style="background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);">
              <h2>成交额（quote）</h2>
              <div class="value" id="bp-volume-quote">--</div>
            </article>
            <article class="card" style="background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);">
              <h2>价差磨损</h2>
              <div class="value" id="bp-wear-spread">--</div>
            </article>
            <article class="card" style="background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);">
              <h2>手续费磨损（返佣后）</h2>
              <div class="value" id="bp-wear-fee-net">--</div>
              <p class="summary-sub" id="bp-fee-meta">taker 0.026% × 55%</p>
            </article>
            <article class="card" style="background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);">
              <h2>总磨损（返佣后）</h2>
              <div class="value" id="bp-wear-total-net">--</div>
            </article>
            <article class="card" style="background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);">
              <h2>每万磨损</h2>
              <div class="value" id="bp-wear-per10k">--</div>
              <p class="summary-sub" id="bp-wear-per10k-est">预估：--</p>
            </article>
          </div>

          <div class="spread-table-wrapper" style="margin-top: 1rem;">
            <table class="spread-table">
              <thead>
                <tr>
                  <th>时间</th>
                  <th>交易对</th>
                  <th>价差(bps)</th>
                  <th>数量</th>
                  <th>BuyAvg</th>
                  <th>SellAvg</th>
                  <th>Spread磨损</th>
                  <th>Fee(返佣后)</th>
                  <th>总磨损(返佣后)</th>
                </tr>
              </thead>
              <tbody id="bp-volume-recent"></tbody>
            </table>
          </div>
        </article>

        <article class="card" style="grid-column: 1 / -1;">
          <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 1rem; flex-wrap: wrap;">
            <div>
              <h2 style="margin:0;">Backpack 双号刷量</h2>
              <p class="summary-sub" style="margin: .35rem 0 0;">价差小于阈值时，A 做多 / B 做空，达到目标持仓后减仓到 0 再循环</p>
            </div>
            <span class="badge badge-muted" id="bp-dual-volume-running">stopped</span>
          </div>

          <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: .75rem; margin-top: 1rem;">
            <label>
              交易对
              <select id="bp-dual-volume-symbol"></select>
            </label>
            <label>
              单次开/减仓最小（base qty）
              <input type="number" id="bp-dual-volume-qty-min" min="0" step="0.001" value="0.2" />
            </label>
            <label>
              单次开/减仓最大（base qty）
              <input type="number" id="bp-dual-volume-qty-max" min="0" step="0.001" value="0.2" />
            </label>
            <label>
              目标持仓量（绝对值）
              <input type="number" id="bp-dual-volume-target" min="0" step="0.001" value="1" />
            </label>
            <label>
              差价阈值（bps）
              <input type="number" id="bp-dual-volume-max-spread-bps" min="0" step="0.1" value="2" />
            </label>
            <label>
              随机间隔最小值（ms）
              <input type="number" id="bp-dual-volume-cooldown-min" min="0" step="1" value="0" />
            </label>
            <label>
              随机间隔最大值（ms）
              <input type="number" id="bp-dual-volume-cooldown-max" min="0" step="1" value="0" />
            </label>
          </div>

          <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: .75rem; margin-top: 0.85rem;">
            <label>
              账号 A（做多）
              <select id="bp-dual-volume-agent-a"></select>
            </label>
            <label>
              账号 B（做空）
              <select id="bp-dual-volume-agent-b"></select>
            </label>
          </div>

          <div style="display:flex; gap:.75rem; align-items:center; margin-top: 1rem; flex-wrap: wrap;">
            <button type="button" class="button-success" id="bp-dual-volume-start">启动</button>
            <button type="button" class="button-danger" id="bp-dual-volume-stop">停止</button>
            <p class="summary-sub" id="bp-dual-volume-status" style="margin:0;">等待配置…</p>
          </div>

          <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: .75rem; margin-top: 1rem;">
            <article class="card" style="background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);">
              <h2>双号成交额（quote）</h2>
              <div class="value" id="bp-dual-volume-quote">--</div>
            </article>
            <article class="card" style="background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);">
              <h2>总磨损（返佣后）</h2>
              <div class="value" id="bp-dual-wear-total-net">--</div>
            </article>
            <article class="card" style="background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);">
              <h2>每万磨损</h2>
              <div class="value" id="bp-dual-wear-per10k">--</div>
            </article>
          </div>
        </article>
      </section>
    </section>

    <section class="agent-section">
      <div class="section-header">
        <div class="section-header-info">
          <h2>Per-VPS Metrics</h2>
          <div class="badge-group">
            <span class="badge badge-muted" id="agent-count">0 active</span>
            <span class="badge badge-info hidden" id="default-pause-indicator">Paused by default</span>
          </div>
        </div>
        <div class="section-header-controls">
          <button type="button" class="button-danger" id="pause-all">Pause All</button>
          <button type="button" class="button-success" id="resume-all">Resume All</button>
        </div>
      </div>
      <p class="empty" id="agent-empty">Waiting for VPS metrics…</p>
      <div class="agent-grid hidden" id="agent-grid"></div>
    </section>

    <p class="updated" id="updated">Awaiting data…</p>

  </main>
  </div>

  <script>
    const agentGrid = document.getElementById('agent-grid');
    const agentEmpty = document.getElementById('agent-empty');
    const agentCount = document.getElementById('agent-count');
    const updatedElement = document.getElementById('updated');
    const defaultPauseIndicator = document.getElementById('default-pause-indicator');

    // Backpack volume booster controls
    const bpSymbolSelect = document.getElementById('bp-volume-symbol');
    const bpQtyInput = document.getElementById('bp-volume-qty');
    const bpCyclesInput = document.getElementById('bp-volume-cycles');
    const bpSpreadInput = document.getElementById('bp-volume-max-spread-bps');
  const bpCooldownMinInput = document.getElementById('bp-volume-cooldown-min');
  const bpCooldownMaxInput = document.getElementById('bp-volume-cooldown-max');
    const bpStartBtn = document.getElementById('bp-volume-start');
    const bpStopBtn = document.getElementById('bp-volume-stop');
  const bpClearHistoryBtn = document.getElementById('bp-volume-clear-history');
    const bpStatus = document.getElementById('bp-volume-status');
    const bpRunning = document.getElementById('bp-volume-running');
  const bpRunGrid = document.getElementById('bp-run-grid');
    const bpVolumeBase = document.getElementById('bp-volume-base');
    const bpVolumeQuote = document.getElementById('bp-volume-quote');
    const bpWearSpread = document.getElementById('bp-wear-spread');
    const bpWearFeeNet = document.getElementById('bp-wear-fee-net');
  const bpWearTotalNet = document.getElementById('bp-wear-total-net');
    const bpWearPer10k = document.getElementById('bp-wear-per10k');
    const bpWearPer10kEst = document.getElementById('bp-wear-per10k-est');
    const bpFeeMeta = document.getElementById('bp-fee-meta');
    const bpRecentBody = document.getElementById('bp-volume-recent');

  // Backpack BBO preview
  const bpBboPrice = document.getElementById('bp-bbo-price');
  const bpBboMeta = document.getElementById('bp-bbo-meta');
  const bpBboCap = document.getElementById('bp-bbo-cap');
  const bpBboQty = document.getElementById('bp-bbo-qty');
  const bpBboWear = document.getElementById('bp-bbo-wear');
  const bpBboWearMeta = document.getElementById('bp-bbo-wear-meta');

  // Backpack dual-volume controls
  const bpDualSymbolSelect = document.getElementById('bp-dual-volume-symbol');
  const bpDualQtyMinInput = document.getElementById('bp-dual-volume-qty-min');
  const bpDualQtyMaxInput = document.getElementById('bp-dual-volume-qty-max');
  const bpDualTargetInput = document.getElementById('bp-dual-volume-target');
  const bpDualSpreadInput = document.getElementById('bp-dual-volume-max-spread-bps');
  const bpDualCooldownMinInput = document.getElementById('bp-dual-volume-cooldown-min');
  const bpDualCooldownMaxInput = document.getElementById('bp-dual-volume-cooldown-max');
  const bpDualAgentASelect = document.getElementById('bp-dual-volume-agent-a');
  const bpDualAgentBSelect = document.getElementById('bp-dual-volume-agent-b');
  const bpDualStartBtn = document.getElementById('bp-dual-volume-start');
  const bpDualStopBtn = document.getElementById('bp-dual-volume-stop');
  const bpDualStatus = document.getElementById('bp-dual-volume-status');
  const bpDualRunning = document.getElementById('bp-dual-volume-running');
  const bpDualVolumeQuote = document.getElementById('bp-dual-volume-quote');
  const bpDualWearTotalNet = document.getElementById('bp-dual-wear-total-net');
  const bpDualWearPer10k = document.getElementById('bp-dual-wear-per10k');

    function bpFormatNumber(value, decimals = 2) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '--';
      return num.toFixed(decimals);
    }

    // For numeric strings coming from backend, keep at most 4 decimals for readability.
    function bpFormatAtMost4(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '--';
      // Strip trailing zeros so we keep "at most" 4 decimals.
      return num.toFixed(4).replace(/\.?(0+)$/, (m) => (m.startsWith('.') ? '' : m));
    }

    function bpFormatMaybe(value, decimals = 6) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '--';
      return num.toFixed(decimals);
    }

    function bpNormalizeSymbol(sym) {
      return String(sym || '').trim().toUpperCase();
    }

    // ---- Reduce suggestion (PARA/BP) ----
    // The PARA panel historically shows a minimal paired-reduce hint.
    // We reuse the same math for Backpack to keep the UX consistent.
    //
    // Contract (matches tests/test_para_reduce_suggestion_algorithm.py):
    // - Exactly 2 accounts
    // - worst account by nonFF total (total - ff_pnl)
    // - L = abs(nonFFTotalWorst) if worst is losing else 0
    // - allocate L across allowed symbols by negative pnl abs
  // - reduceSize = absPosSize * (allocation / abs(symbolNegPnl))
  // - headline: choose the symbol with highest loss-reduction efficiency (negAbs / cap)
    function computeReduceSuggestionFromAccounts(accounts, {
      allowedSymbols = ['BTC', 'ETH'],
      ffSymbol = 'FF-USD',
      messagePrefix = '',
      topN = 1,
      allocationMode = 'proportional',
      requireFullCoverage = false,
    } = {}) {
      const baseRes = { ok: false, message: '' };
      if (!Array.isArray(accounts) || accounts.length !== 2) {
        return { ...baseRes, message: '需要恰好 2 个账户' };
      }

      const coerceNumber = (v) => {
        if (v === null || v === undefined) return 0;
        const n = Number(String(v).replace(/,/g, '').trim());
        return Number.isFinite(n) ? n : 0;
      };

      const pack = (acct) => {
        const totalRaw = coerceNumber(acct?.total);
        const ffPnl = coerceNumber(acct?.ff_pnl);
        const nonFfTotal = totalRaw - ffPnl;
        // These maps are optional; Backpack snapshots typically don't provide them.
        const symbolPnl = (acct?.symbol_pnl && typeof acct.symbol_pnl === 'object') ? acct.symbol_pnl : {};
        const symbolCap = (acct?.symbol_cap && typeof acct.symbol_cap === 'object') ? acct.symbol_cap : {};

        // Also accept per-position inputs and derive symbolCap from current exposure.
        const positions = Array.isArray(acct?.positions) ? acct.positions : [];

        const normalizeBaseAsset = (rawSymbol) => {
          // Convert exchange-specific instrument to a base asset label.
          // Examples:
          // - "BTC-PERP" / "BTC-USDC" / "BTC_USDC" / "BTCUSDC" -> BTC
          // - "XBT" -> BTC
          // - "ETH-PERP" -> ETH
          const text = normalizeSymbolLabel(rawSymbol);
          if (!text) return '';
          const upper = text.toUpperCase();
          if (upper === 'XBT') return 'BTC';
          // Split by common separators and take the first token.
          const token = upper.split(/[-:\/]/)[0] || '';
          // Handle concatenated forms like BTCUSDC / ETHUSDT.
          if (token.length > 3) {
            if (token.startsWith('BTC')) return 'BTC';
            if (token.startsWith('ETH')) return 'ETH';
          }
          return token;
        };

        const derivedSymbolCap = {};
        const derivedSymbolPnl = {};
        for (const pos of positions) {
          const base = normalizeBaseAsset(pos?.symbol ?? pos?.s ?? pos?.instrument ?? pos?.market);
          if (!base) continue;
          const qtyRaw = pos?.net_size ?? pos?.netQuantity ?? pos?.netExposureQuantity ?? pos?.positionSize ?? pos?.size ?? pos?.qty ?? pos?.quantity ?? pos?.q;
          const qty = coerceNumber(qtyRaw);
          if (!Number.isFinite(qty) || qty === 0) continue;
          const absQty = Math.abs(qty);
          // If multiple instruments map to same base, sum abs to get a conservative cap.
          derivedSymbolCap[base] = (derivedSymbolCap[base] || 0) + absQty;

          // PnL: best-effort derive from position fields.
          // Backpack provides pnlUnrealized; also sometimes we can compute size*(mark-entry).
          const pnlFallback = coerceNumber(
            pos?.pnlUnrealized ??
            pos?.pnl_unrealized ??
            pos?.unrealized_pnl ??
            pos?.unrealizedPnl ??
            pos?.pnl ??
            pos?.P,
          );
          const entry = coerceNumber(
            pos?.entry_price ??
            pos?.entryPrice ??
            pos?.avgEntryPrice ??
            pos?.avgEntry ??
            pos?.entry ??
            pos?.B,
          );
          const mark = coerceNumber(
            pos?.mark_price ??
            pos?.markPrice ??
            pos?.mark ??
            pos?.indexPrice ??
            pos?.lastPrice ??
            pos?.price ??
            pos?.M,
          );
          const computedPnl = (Number.isFinite(entry) && Number.isFinite(mark)) ? (qty * (mark - entry)) : null;
          const pnl = (computedPnl !== null && Number.isFinite(computedPnl)) ? computedPnl : pnlFallback;
          if (Number.isFinite(pnl) && pnl !== 0) {
            derivedSymbolPnl[base] = (derivedSymbolPnl[base] || 0) + pnl;
          }
        }

        return {
          name: acct?.name || acct?.label || 'Account',
          totalRaw,
          ffPnl,
          nonFfTotal,
          // Prefer explicit maps if provided; otherwise fall back to positions aggregation.
          symbolPnl: { ...derivedSymbolPnl, ...symbolPnl },
          symbolCap: { ...derivedSymbolCap, ...symbolCap },
        };
      };

      const a = pack(accounts[0]);
      const b = pack(accounts[1]);
      const worst = a.nonFfTotal <= b.nonFfTotal ? a : b;
      if (worst.nonFfTotal >= 0) {
        return { ok: true, message: '无需减仓' };
      }

      const L = Math.abs(worst.nonFfTotal);
      const allowed = new Set((allowedSymbols || []).map((s) => String(s || '').trim().toUpperCase()).filter(Boolean));

      const normalizeCandidateSymbol = (raw) => {
        const base = (() => {
          const text = normalizeSymbolLabel(raw);
          if (!text) return '';
          const upper = text.toUpperCase();
          if (upper === 'XBT') return 'BTC';
          const token = upper.split(/[-:\/]/)[0] || '';
          if (token.length > 3) {
            if (token.startsWith('BTC')) return 'BTC';
            if (token.startsWith('ETH')) return 'ETH';
          }
          return token;
        })();
        return base;
      };

      const resolveCapForSymbol = (capMap, baseSym, rawSym) => {
        if (!capMap || typeof capMap !== 'object') return 0;
        let cap = coerceNumber(capMap?.[baseSym]);
        if (cap > 0) return cap;
        if (rawSym && rawSym !== baseSym) {
          cap = coerceNumber(capMap?.[rawSym]);
          if (cap > 0) return cap;
        }
        let total = 0;
        for (const [key, value] of Object.entries(capMap)) {
          if (normalizeCandidateSymbol(key) === baseSym) {
            total += coerceNumber(value);
          }
        }
        return total;
      };

      const rows = [];
      for (const [symRaw, pnlRaw] of Object.entries(worst.symbolPnl || {})) {
        const sym = normalizeCandidateSymbol(symRaw);
        if (!sym) continue;
        if (sym === String(ffSymbol || '').trim().toUpperCase()) continue;
        if (allowed.size && !allowed.has(sym)) continue;

        const pnl = coerceNumber(pnlRaw);
        if (pnl >= 0) continue;
        const cap = resolveCapForSymbol(worst.symbolCap, sym, symRaw);
        if (cap <= 0) continue;
        rows.push({ symbol: sym, negAbs: Math.abs(pnl), cap });
      }

      if (!rows.length) {
        const hasRestriction = Array.isArray(allowedSymbols) && allowedSymbols.length;
        const restrictionText = hasRestriction ? `（仅 ${allowedSymbols.join('/')}）` : '';
        return { ...baseRes, message: `缺少可计算的减仓候选${restrictionText}` };
      }

      let totalNegAbs = 0;
      if (allocationMode === 'proportional') {
        totalNegAbs = rows.reduce((acc, r) => acc + r.negAbs, 0);
        if (!(totalNegAbs > 0)) {
          return { ...baseRes, message: '减仓候选数据异常' };
        }
      }

      const computed = rows.map((r) => {
        const allocation = (allocationMode === 'proportional')
          ? (L * r.negAbs / totalNegAbs)
          : Math.min(L, r.negAbs);
        const ratio = r.negAbs > 0
          ? ((allocationMode === 'proportional') ? (allocation / r.negAbs) : (L / r.negAbs))
          : 0;
        const size = Math.min(Math.max(r.cap * ratio, 0), r.cap);
        const efficiency = r.cap > 0 ? (r.negAbs / r.cap) : 0;
        const coversLoss = r.negAbs >= L;
        return { ...r, allocation, size, efficiency, coversLoss };
      });

      const coverageCandidates = requireFullCoverage
        ? computed.filter((row) => row.coversLoss)
        : computed;
      if (!coverageCandidates.length) {
        return { ...baseRes, message: '缺少可完全覆盖风险的减仓候选' };
      }

      // Prefer the symbol that yields larger loss reduction per unit size.
      // Tie-break only by symbol name to avoid size/allocation influence.
      coverageCandidates.sort((x, y) => {
        if (x.coversLoss !== y.coversLoss) {
          return x.coversLoss ? -1 : 1;
        }
        return (y.efficiency - x.efficiency) || x.symbol.localeCompare(y.symbol);
      });
      const limit = Math.max(1, Math.min(Number(topN) || 1, coverageCandidates.length));
      const picks = coverageCandidates.slice(0, limit).map((row) => {
        const sizeText = bpFormatAtMost4(row.size);
        return {
          symbol: row.symbol,
          size: row.size,
          message: `${row.symbol} 双边减仓 ${sizeText}${row.symbol}`,
          efficiency: row.efficiency,
        };
      });
      const best = picks[0];
      const prefix = messagePrefix ? `${messagePrefix} ` : '';
      return {
        ok: true,
        symbol: best.symbol,
        size: best.size,
        message: `${prefix}${best.message}`,
        top: picks,
      };
    }

    // Backward-compatible wrapper referenced by older dashboard code.
    function computeParaReduceSuggestion(accounts) {
      return computeReduceSuggestionFromAccounts(accounts, { allowedSymbols: ['BTC', 'ETH'], ffSymbol: 'FF-USD' });
    }

    function computeGrvtReduceSuggestion(accounts) {
      return computeReduceSuggestionFromAccounts(accounts, {
        allowedSymbols: [],
        ffSymbol: 'FF-USD',
        topN: 3,
        allocationMode: 'single',
        requireFullCoverage: true,
      });
    }

    function computeBpReduceSuggestion(accounts) {
      // Backpack follows PARA UX: only propose BTC/ETH paired reduce.
      return computeReduceSuggestionFromAccounts(accounts, {
        allowedSymbols: ['BTC', 'ETH'],
        ffSymbol: 'FF-USD',
      });
    }
    function bpResetMetricsUI() {
      bpVolumeBase.textContent = '--';
      bpVolumeQuote.textContent = '--';
      bpWearSpread.textContent = '--';
      bpWearFeeNet.textContent = '--';
      if (typeof bpWearTotalNet !== 'undefined' && bpWearTotalNet) bpWearTotalNet.textContent = '--';
      bpWearPer10k.textContent = '--';
      if (bpWearPer10kEst) bpWearPer10kEst.textContent = '预估：--';
      bpRecentBody.innerHTML = '';
    }

    function bpEstimatePer10kFromBbo({ bid1, ask1, feeRate, rebateRate }) {
      const bid = Number(bid1);
      const ask = Number(ask1);
      if (!Number.isFinite(bid) || !Number.isFinite(ask) || bid <= 0 || ask <= 0 || ask < bid) return null;
      const mid = (bid + ask) / 2;
      if (!(mid > 0)) return null;
      const spreadW = (ask - bid) / 2; // price-space wear per side; round-trip wear is half-spread

      const fr = Number(feeRate);
      const rr = Number(rebateRate);
      const feeNetRate = (Number.isFinite(fr) ? fr : 0) * (1 - (Number.isFinite(rr) ? rr : 0));

      // Per 10k notional: per10k = ( (spreadW/mid) + feeNetRate ) * 10000
      return (spreadW / mid + feeNetRate) * 10000;
    }

    function bpUpdatePer10kEstimateFromBbo(bbo) {
      if (!bpWearPer10kEst) return;
      if (!bbo) {
        bpWearPer10kEst.textContent = '预估：--';
        return;
      }
      const est = bpEstimatePer10kFromBbo({
        bid1: bbo.bid1,
        ask1: bbo.ask1,
        feeRate: (bbo.fee_rate != null) ? bbo.fee_rate : 0.00026,
        rebateRate: (bbo.rebate_rate != null) ? bbo.rebate_rate : 0.45,
      });
      bpWearPer10kEst.textContent = (est == null || !Number.isFinite(est))
        ? '预估：--'
        : `预估：${bpFormatAtMost4(est)}/万`;
    }
    function bpShowNoCache(sym) {
      bpResetMetricsUI();
      return false;
    }

    function bpPickLiveSymbol(statusPayload, metricsPayload) {
      // New backend returns an array of runs.
      const runs = statusPayload && Array.isArray(statusPayload.runs) ? statusPayload.runs : null;
      if (runs && runs.length) {
        const firstRunning = runs.find(r => r && r.running);
        const sym = bpNormalizeSymbol((firstRunning && firstRunning.symbol) || runs[0].symbol);
        if (sym) return sym;
      }
      const recent = metricsPayload && Array.isArray(metricsPayload.recent) ? metricsPayload.recent : null;
      const recSym = recent && recent.length && recent[0] && recent[0].symbol ? bpNormalizeSymbol(recent[0].symbol) : '';
      return recSym;
    }

    function bpStopSymbol(sym) {
      const symbol = bpNormalizeSymbol(sym);
      if (!symbol) return Promise.resolve();
      return bpFetchJson('/api/backpack/volume/stop', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ symbol })
      });
    }

    function bpRenderRuns(statusPayload, viewingSymbol) {
      const grid = bpRunGrid;
      if (!grid) return;
      const runs = statusPayload && Array.isArray(statusPayload.runs) ? statusPayload.runs : [];
      if (!runs.length) {
        grid.style.display = 'none';
        grid.innerHTML = '';
        return;
      }
      grid.style.display = 'grid';
      grid.innerHTML = '';

      for (const run of runs) {
        const sym = bpNormalizeSymbol(run && run.symbol);
        const running = !!(run && run.running);
        const cyclesDone = run && (run.cycles_done != null) ? run.cycles_done : '--';
        const cyclesTarget = run && (run.cycles_target != null) ? run.cycles_target : 0;
        const err = run && run.last_error ? String(run.last_error) : '';
        const note = run && run.last_note ? String(run.last_note) : '';
        const startedAt = run && run.started_at ? Number(run.started_at) : null;
        const startedText = (startedAt && Number.isFinite(startedAt)) ? new Date(startedAt * 1000).toLocaleTimeString() : '--';

        const volQuote = run && (run.volume_quote != null) ? run.volume_quote : null;
        const wearTotalNet = run && (run.wear_total_net != null) ? run.wear_total_net : null;
        const wearPer10k = run && (run.wear_total_net_per_10k != null) ? run.wear_total_net_per_10k : null;

        const card = document.createElement('div');
        card.className = 'bp-run-card';
        const badgeClass = running ? 'badge badge-info' : 'badge badge-muted';
        const badgeText = running ? 'running' : 'stopped';
        const selected = viewingSymbol && sym && viewingSymbol === sym;

        const metaLine = err
          ? `错误：${err}`
          : (note ? `提示：${note}` : `cycles ${cyclesDone}/${cyclesTarget || 0}`);

        const fmtMaybe = (val, digits = 4) => {
          if (val == null || val === '') return '--';
          const n = Number(val);
          if (!Number.isFinite(n)) return String(val);
          return bpFormatNumber(n, digits);
        };

        const moneyLine = (label, val, digits = 4) => {
          const text = fmtMaybe(val, digits);
          return `<div class="bp-run-kv"><span class="bp-run-k">${label}</span><span class="bp-run-v">${text}</span></div>`;
        };

        card.innerHTML = `
          <div class="bp-run-card-header">
            <h3 class="bp-run-card-title">${sym || '--'}</h3>
            <span class="${badgeClass}">${badgeText}</span>
          </div>
          <div class="bp-run-meta">${metaLine}</div>
          <div class="bp-run-meta">started ${startedText} · view ${selected ? 'yes' : 'no'}</div>
          <div class="bp-run-kv-grid">
            ${moneyLine('成交额(quote)', volQuote, 4)}
            ${moneyLine('总磨损(返佣后)', wearTotalNet, 6)}
            ${moneyLine('每万磨损', wearPer10k, 2)}
          </div>
          <div class="bp-run-actions">
            <button type="button" class="button-secondary" data-action="view" data-symbol="${sym}">查看</button>
            <button type="button" class="button-danger" data-action="stop" data-symbol="${sym}" ${running ? '' : 'disabled'}>停止</button>
          </div>
        `;
        grid.appendChild(card);
      }

      // Delegate button events.
      grid.querySelectorAll('button[data-action="view"]').forEach(btn => {
        btn.addEventListener('click', () => {
          const sym = bpNormalizeSymbol(btn.getAttribute('data-symbol'));
          if (!sym) return;
          if (bpSymbolSelect) bpSymbolSelect.value = sym;
          bpRefresh();
        });
      });
      grid.querySelectorAll('button[data-action="stop"]').forEach(btn => {
        btn.addEventListener('click', async () => {
          const sym = bpNormalizeSymbol(btn.getAttribute('data-symbol'));
          if (!sym) return;
          bpStatus.textContent = `停止中：${sym}`;
          try {
            await bpStopSymbol(sym);
            bpStatus.textContent = `已停止：${sym}`;
            await bpRefresh();
          } catch (e) {
            bpStatus.textContent = `停止失败：${e.message}`;
          }
        });
      });
    }

    function bpSetStatusLine({ baseText, liveSym, viewingSym, cacheHint }) {
      const parts = [baseText];
      parts.push(`live ${liveSym || '-'}`);
      parts.push(`view ${viewingSym || '-'}`);
      if (cacheHint) parts.push(cacheHint);
      bpStatus.textContent = parts.join(' · ');
    }

    async function bpFetchJson(url, options) {
      const resp = await fetch(url, options);
      const text = await resp.text();
      const data = (() => {
        try { return JSON.parse(text || '{}'); } catch { return {}; }
      })();
      if (!resp.ok || !data || data.ok === false) {
        const bodyPreview = (text || '').slice(0, 200).replace(/\s+/g, ' ').trim();
        const err = (data && data.error)
          ? String(data.error)
          : `HTTP ${resp.status}`;

        // Help debug common issues: auth redirect/html error pages, proxy blocks, etc.
        throw new Error(`${err}${bodyPreview ? ` | body: ${bodyPreview}` : ''}`);
      }
      return data;
    }

    async function bpLoadMarkets() {
      try {
        const data = await bpFetchJson('/api/backpack/volume/markets');
        const markets = Array.isArray(data.markets) ? data.markets : [];
        const selects = [bpSymbolSelect, bpDualSymbolSelect].filter(Boolean);
        for (const select of selects) {
          select.innerHTML = '';
          for (const sym of markets) {
            const opt = document.createElement('option');
            opt.value = sym;
            opt.textContent = sym;
            select.appendChild(opt);
          }
          if (markets.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'No PERP markets';
            select.appendChild(opt);
          }
        }
      } catch (e) {
        bpStatus.textContent = `市场加载失败：${e.message}`;
        const selects = [bpSymbolSelect, bpDualSymbolSelect].filter(Boolean);
        for (const select of selects) {
          select.innerHTML = '';
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'Markets load failed (check server logs)';
          select.appendChild(opt);
        }
      }
    }

    function bpRenderBboPreview(bbo) {
      if (!bbo) return;
      const bid1 = bbo.bid1;
      const ask1 = bbo.ask1;
      const bidQty = bbo.bid1_qty;
      const askQty = bbo.ask1_qty;
      const spreadBps = bbo.spread_bps;

      const source = (bbo.source || '').toString();
      const ageMs = (bbo.age_ms == null) ? null : Number(bbo.age_ms);
      const sourceText = source ? source.toUpperCase() : '--';
      const ageText = (ageMs == null || !Number.isFinite(ageMs)) ? '--' : `${bpFormatNumber(ageMs, 0)}ms`;

      if (bpBboPrice) {
        bpBboPrice.textContent = `bid ${bid1 || '--'} / ask ${ask1 || '--'}`;
      }
      if (bpBboMeta) {
        bpBboMeta.textContent = `spread ${bpFormatNumber(spreadBps, 2)} bps；bidQty ${bidQty || '--'} / askQty ${askQty || '--'}；source ${sourceText}；age ${ageText}`;
      }
      if (bpBboCap) {
        bpBboCap.textContent = `${bbo.cap_qty || '--'} (safe ${bbo.safe_cap_qty || '--'})`;
      }
      if (bpBboQty) {
        bpBboQty.textContent = `qty 输入 ${bbo.qty_input || '--'} → 执行估算 ${bbo.qty_exec || '--'}；safety ${bpFormatNumber(bbo.depth_safety_factor, 2)}`;
      }

      const wear = bbo.wear_est || {};
      if (bpBboWear) {
        bpBboWear.textContent = (wear.wear_total_net_est == null) ? '--' : bpFormatAtMost4(wear.wear_total_net_est);
      }
      if (bpBboWearMeta) {
        const per10k = (wear.wear_per_10k_est == null) ? '--' : bpFormatAtMost4(wear.wear_per_10k_est);
        const qtyExec = bbo.qty_exec || wear.qty || '--';
        const notional = wear.volume_quote_est || '--';
        const wearSpread = (wear.wear_spread_est == null) ? '--' : bpFormatAtMost4(wear.wear_spread_est);
        const feeNet = (wear.fee_net_est == null) ? '--' : bpFormatAtMost4(wear.fee_net_est);
        const wearTotal = (wear.wear_total_net_est == null) ? '--' : bpFormatAtMost4(wear.wear_total_net_est);
        bpBboWearMeta.textContent = `spread磨损 ${wearSpread} + fee磨损(返佣后) ${feeNet} = 合计磨损 ${wearTotal}；每万 ${per10k}；qty ${qtyExec}；notional ${notional}`;
      }

      // Update per-10k estimate card from current L1 BBO + fees.
      bpUpdatePer10kEstimateFromBbo(bbo);
    }

    async function bpRefreshBboPreview() {
      const symbol = (bpSymbolSelect && bpSymbolSelect.value) ? bpSymbolSelect.value : '';
      if (!symbol) return;
      const qty = String(bpQtyInput && bpQtyInput.value ? bpQtyInput.value : '0');

      // Keep these defaults consistent with start payload.
      const params = new URLSearchParams({
        symbol,
        qty,
        depth_safety_factor: '0.7',
        fee_rate: '0.00026',
        rebate_rate: '0.45'
      });

      try {
        const data = await bpFetchJson(`/api/backpack/bbo?${params.toString()}`);
        bpRenderBboPreview(data);
      } catch (e) {
        if (bpBboMeta) bpBboMeta.textContent = `BBO 获取失败：${e.message}`;
      }
    }

    function bpRenderMetrics(summary, recent) {
      if (!summary) return;
      bpVolumeBase.textContent = summary.volume_base_total || '--';
      bpVolumeQuote.textContent = summary.volume_quote_total || '--';
      bpWearSpread.textContent = summary.wear_spread_total || '--';
      bpWearFeeNet.textContent = summary.fee_total_net || '--';
      if (bpWearTotalNet) bpWearTotalNet.textContent = summary.wear_total_net || '--';
      bpWearPer10k.textContent = (summary.wear_per10k_net == null) ? '--' : bpFormatNumber(summary.wear_per10k_net, 2);
      // Keep estimate visible even when summary exists; it is updated via BBO refresh.
      const feeRate = summary.fee_rate;
      const rebateRate = summary.rebate_rate;
      if (typeof feeRate === 'number' && typeof rebateRate === 'number') {
        const netPct = feeRate * (1 - rebateRate) * 100;
        bpFeeMeta.textContent = `taker ${(feeRate * 100).toFixed(3)}% × ${(1 - rebateRate) * 100}% = ${netPct.toFixed(4)}%`;
      }

      const rows = Array.isArray(recent) ? recent : [];
      bpRecentBody.innerHTML = '';
      for (const r of rows.slice(0, 50)) {
        const tr = document.createElement('tr');
        const ts = r.ts ? new Date(r.ts * 1000) : null;
        const timeText = ts ? ts.toLocaleTimeString() : '--';
        tr.innerHTML = `
          <td>${timeText}</td>
          <td>${r.symbol || '--'}</td>
          <td>${bpFormatNumber(r.spread_bps, 2)}</td>
          <td>${r.qty_exec || '--'}</td>
          <td>${r.buy_avg || '--'}</td>
          <td>${r.sell_avg || '--'}</td>
          <td>${r.wear_spread || '--'}</td>
          <td>${r.fee_net || '--'}</td>
          <td>${r.wear_total_net || '--'}</td>
        `;
        bpRecentBody.appendChild(tr);
      }
    }

    async function bpRefresh() {
      const viewingSymbol = bpSymbolSelect && bpSymbolSelect.value ? bpNormalizeSymbol(bpSymbolSelect.value) : '';
      let statusPayload = null;
      try {
        statusPayload = await bpFetchJson('/api/backpack/volume/status');
        const runs = statusPayload && Array.isArray(statusPayload.runs) ? statusPayload.runs : [];
        const anyRunning = runs.some(r => r && r.running);
        const runCountText = runs.length ? `${runs.length} run${runs.length > 1 ? 's' : ''}` : 'stopped';
        bpRunning.textContent = anyRunning ? `running · ${runCountText}` : runCountText;
        bpRunning.className = anyRunning ? 'badge badge-info' : 'badge badge-muted';

        // Render per-symbol run cards.
        bpRenderRuns(statusPayload, viewingSymbol);

        const liveSym = bpPickLiveSymbol(statusPayload, null);
        const runningRun = runs.find(r => r && r.running && bpNormalizeSymbol(r.symbol) === liveSym) || runs.find(r => r && r.running) || null;
        const noteText = (runningRun && runningRun.last_note) ? String(runningRun.last_note) : '';
        const errText = (runningRun && runningRun.last_error) ? String(runningRun.last_error) : '';
        const baseText = errText
          ? `错误：${errText}`
          : (noteText
              ? `提示：${noteText}`
              : (runningRun ? `已执行 ${runningRun.cycles_done}/${runningRun.cycles_target || 0}` : '未运行'));
        bpSetStatusLine({ baseText, liveSym, viewingSym: viewingSymbol, cacheHint: '' });
      } catch (e) {
        // Backend unavailable: show explicit empty state.
        bpShowNoCache(viewingSymbol);
        const baseText = `状态获取失败：${e.message}`;
        bpSetStatusLine({ baseText, liveSym: '', viewingSym: viewingSymbol, cacheHint: '' });
      }

    // Always refresh BBO preview (shows when switching symbol even if not running).
    await bpRefreshBboPreview();

      try {
    const metrics = await bpFetchJson(`/api/backpack/volume/metrics?symbol=${encodeURIComponent(viewingSymbol || '')}`);
        const liveSym = bpPickLiveSymbol(statusPayload, metrics);

    // Backend now persists per-symbol history to disk; avoid localStorage writes to prevent
    // "clear then refresh" from immediately repopulating client cache.

        // Only update the visible cards/table if the user is viewing the same symbol as live.
        if (!viewingSymbol || (liveSym && liveSym === viewingSymbol)) {
          bpRenderMetrics(metrics.summary, metrics.recent);
        } else {
          // User is viewing another symbol: always show the selected symbol's history (disk).
          bpRenderMetrics(metrics.summary, metrics.recent);
        }
      } catch (e) {
        bpShowNoCache(viewingSymbol);
        bpStatus.textContent = `指标获取失败：${e.message}`;
      }

      // Dual-volume status refresh (separate card).
      await bpRefreshDualVolumeStatus();
    }

    function bpApplyDualVolumeConfig(config, { markClean = false } = {}) {
      if (!config) return;
      const setValue = (element, value, fallback = '') => {
        if (!element) return;
        if (value === null || value === undefined || value === '') {
          element.value = fallback;
        } else {
          element.value = value;
        }
      };
      setValue(bpDualSymbolSelect, config.symbol, bpDualSymbolSelect?.value || '');
  const qtyMin = config.qty_per_cycle_min ?? config.qty_per_cycle ?? config.qty;
  const qtyMax = config.qty_per_cycle_max ?? config.qty_per_cycle ?? config.qty;
  setValue(bpDualQtyMinInput, qtyMin, bpDualQtyMinInput?.value || '');
  setValue(bpDualQtyMaxInput, qtyMax, bpDualQtyMaxInput?.value || '');
      setValue(bpDualTargetInput, config.target_position ?? config.target, bpDualTargetInput?.value || '');
      setValue(bpDualSpreadInput, config.max_spread_bps ?? config.spread_bps, bpDualSpreadInput?.value || '');
      setValue(bpDualCooldownMinInput, config.cooldown_ms_min ?? config.cooldown_min_ms, bpDualCooldownMinInput?.value || '0');
      setValue(bpDualCooldownMaxInput, config.cooldown_ms_max ?? config.cooldown_max_ms, bpDualCooldownMaxInput?.value || '0');
      if (bpDualAgentASelect && config.agent_a) {
        bpDualAgentASelect.value = config.agent_a;
      }
      if (bpDualAgentBSelect && config.agent_b) {
        bpDualAgentBSelect.value = config.agent_b;
      }
      if (markClean) {
        bpDualVolumeDirty = false;
      }
    }

    function bpRenderDualVolumeStatus(status) {
      if (!status) return;
      const running = !!status.running;
      if (bpDualRunning) {
        bpDualRunning.textContent = running ? 'running' : 'stopped';
        bpDualRunning.className = running ? 'badge badge-info' : 'badge badge-muted';
      }
      const err = status.last_error ? String(status.last_error) : '';
      const note = status.last_note ? String(status.last_note) : '';
      const phase = status.phase ? String(status.phase) : '';
      const gate = status.last_gate ? String(status.last_gate) : '';
      const spreadBps = Number(status.last_spread_bps);
      const baseText = err
        ? `错误：${err}`
        : (note ? `提示：${note}` : (running ? '运行中' : '未运行'));
      const meta = [];
      if (phase) meta.push(`phase ${phase}`);
      if (Number.isFinite(spreadBps)) meta.push(`spread ${bpFormatNumber(spreadBps, 2)}bps`);
      if (gate) meta.push(`gate ${gate}`);
      bpDualStatus.textContent = meta.length ? `${baseText} · ${meta.join(' · ')}` : baseText;
      if (bpDualVolumeQuote) {
        bpDualVolumeQuote.textContent = status.volume_quote ?? '--';
      }
      if (bpDualWearTotalNet) {
        bpDualWearTotalNet.textContent = status.wear_total_net ?? '--';
      }
      if (bpDualWearPer10k) {
        const val = status.wear_total_net_per_10k;
        bpDualWearPer10k.textContent = (val == null || val === '') ? '--' : bpFormatNumber(Number(val), 2);
      }
    }

    async function bpRefreshDualVolumeStatus({ force = false } = {}) {
      try {
        const data = await bpFetchJson('/api/backpack/dual_volume/status');
        bpDualVolumeLastStatus = data;
        bpRenderDualVolumeStatus(data);
        if (data?.config && (force || !bpDualVolumeDirty)) {
          bpApplyDualVolumeConfig(data.config, { markClean: true });
        }
      } catch (e) {
        if (bpDualStatus) {
          bpDualStatus.textContent = `双号刷量状态获取失败：${e.message}`;
        }
        if (bpDualRunning) {
          bpDualRunning.textContent = 'unknown';
          bpDualRunning.className = 'badge badge-muted';
        }
      }
    }

    bpStartBtn && bpStartBtn.addEventListener('click', async () => {
      bpStatus.textContent = '启动中…';
      try {
        const body = {
          symbol: bpSymbolSelect.value,
          qty_per_cycle: String(bpQtyInput.value || '0'),
          cycles: Number(bpCyclesInput.value || '0'),
          max_spread_bps: Number(bpSpreadInput.value || '0'),
          cooldown_ms: 1500,
          cooldown_ms_min: Number((bpCooldownMinInput && bpCooldownMinInput.value) ? bpCooldownMinInput.value : '0'),
          cooldown_ms_max: Number((bpCooldownMaxInput && bpCooldownMaxInput.value) ? bpCooldownMaxInput.value : '0'),
          depth_safety_factor: 0.7,
          min_cap_qty: String(bpQtyInput.value || '0'),
          fee_rate: 0.00026,
          rebate_rate: 0.45
        };
        await bpFetchJson('/api/backpack/volume/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        bpStatus.textContent = '已启动';
        await bpRefresh();
      } catch (e) {
        bpStatus.textContent = `启动失败：${e.message}`;
      }
    });

    bpSymbolSelect && bpSymbolSelect.addEventListener('change', () => {
      const sym = bpSymbolSelect.value;
      if (sym) bpShowNoCache(sym);
      // Always refresh BBO preview for the new symbol.
      bpRefreshBboPreview();
      // Also refresh volume metrics from backend for the selected symbol.
      bpRefresh();
    });

    bpClearHistoryBtn && bpClearHistoryBtn.addEventListener('click', async () => {
      const sym = bpSymbolSelect && bpSymbolSelect.value ? bpNormalizeSymbol(bpSymbolSelect.value) : '';
      bpShowNoCache(sym);
      bpStatus.textContent = `清除中：${sym || '-'}`;
      try {
        await bpFetchJson('/api/backpack/volume/history/clear', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol: sym })
        });
        bpStatus.textContent = `已清除 ${sym || '-'} 历史数据`;
      } catch (e) {
        bpStatus.textContent = `清除失败：${e.message}`;
      }
      // Refresh soon to pick up the cleared persisted state.
      setTimeout(() => { bpRefresh(); }, 0);
    });
    bpQtyInput && bpQtyInput.addEventListener('change', () => {
      bpRefreshBboPreview();
    });
    bpQtyInput && bpQtyInput.addEventListener('input', () => {
      // Debounce-ish via timer tick; cheap enough to just rely on the 1s poll.
    });

    bpStopBtn && bpStopBtn.addEventListener('click', async () => {
      bpStatus.textContent = '停止中…';
      try {
        const sym = bpSymbolSelect && bpSymbolSelect.value ? bpNormalizeSymbol(bpSymbolSelect.value) : '';
        if (sym) {
          await bpStopSymbol(sym);
          bpStatus.textContent = `已停止：${sym}`;
        } else {
          // Back-compat: stop all
          await bpFetchJson('/api/backpack/volume/stop', { method: 'POST' });
          bpStatus.textContent = '已停止（全部）';
        }
        await bpRefresh();
      } catch (e) {
        bpStatus.textContent = `停止失败：${e.message}`;
      }
    });

    const bpDualInputs = [
      bpDualSymbolSelect,
      bpDualQtyMinInput,
      bpDualQtyMaxInput,
      bpDualTargetInput,
      bpDualSpreadInput,
      bpDualCooldownMinInput,
      bpDualCooldownMaxInput,
      bpDualAgentASelect,
      bpDualAgentBSelect,
    ];
    bpDualInputs.forEach((element) => {
      if (!element) return;
      element.addEventListener('change', () => markBpDualVolumeDirty());
      element.addEventListener('input', () => markBpDualVolumeDirty());
    });

    bpDualStartBtn && bpDualStartBtn.addEventListener('click', async () => {
      if (bpDualVolumeBusy) return;
      bpDualVolumeBusy = true;
      bpDualStatus.textContent = '启动中…';
      try {
        const body = {
          symbol: bpDualSymbolSelect?.value || '',
          qty_per_cycle_min: String(bpDualQtyMinInput?.value || '0'),
          qty_per_cycle_max: String(bpDualQtyMaxInput?.value || '0'),
          target_position: String(bpDualTargetInput?.value || '0'),
          max_spread_bps: Number(bpDualSpreadInput?.value || '0'),
          cooldown_ms: 1500,
          cooldown_ms_min: Number(bpDualCooldownMinInput?.value || '0'),
          cooldown_ms_max: Number(bpDualCooldownMaxInput?.value || '0'),
          depth_safety_factor: 0.7,
          agent_a: bpDualAgentASelect?.value || '',
          agent_b: bpDualAgentBSelect?.value || '',
        };
        await bpFetchJson('/api/backpack/dual_volume/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        bpDualVolumeDirty = false;
        await bpRefreshDualVolumeStatus({ force: true });
      } catch (e) {
        bpDualStatus.textContent = `启动失败：${e.message}`;
      } finally {
        bpDualVolumeBusy = false;
      }
    });

    bpDualStopBtn && bpDualStopBtn.addEventListener('click', async () => {
      if (bpDualVolumeBusy) return;
      bpDualVolumeBusy = true;
      bpDualStatus.textContent = '停止中…';
      try {
        await bpFetchJson('/api/backpack/dual_volume/stop', { method: 'POST' });
        bpDualVolumeDirty = false;
        await bpRefreshDualVolumeStatus({ force: true });
      } catch (e) {
        bpDualStatus.textContent = `停止失败：${e.message}`;
      } finally {
        bpDualVolumeBusy = false;
      }
    });

    // Bootstrap
  bpLoadMarkets().then(() => {
    return bpRefresh();
  });
    setInterval(bpRefresh, 1000);
  const pauseAllButton = document.getElementById('pause-all');
  const resumeAllButton = document.getElementById('resume-all');
  const grvtAccountCount = document.getElementById('grvt-account-count');
  const grvtEmpty = document.getElementById('grvt-empty');
  const grvtCard = document.getElementById('grvt-card');
  const grvtTotalPnl = document.getElementById('grvt-total-pnl');
  const grvtTotalEquity = document.getElementById('grvt-total-equity');
  const grvtTotalPosition = document.getElementById('grvt-total-position');
  const grvtTotalPositionNet = document.getElementById('grvt-total-position-net');
  const grvtWalletBalance = document.getElementById('grvt-wallet-balance');
  const grvtTransferableTotal = document.getElementById('grvt-transfer-total');
  const grvtTransferableNote = document.getElementById('grvt-transfer-note');
  const grvtPriceChartWrapper = document.getElementById('grvt-price-chart-wrapper');
  const grvtPriceChartCanvas = document.getElementById('grvt-price-chart');
  const grvtPriceChartNote = document.getElementById('grvt-price-chart-note');
  const grvtPriceChartLegend = document.getElementById('grvt-price-chart-legend');
  const grvtRiskLevel = document.getElementById('grvt-risk-level');
  const grvtRiskDetail = document.getElementById('grvt-risk-detail');
  const grvtAvgMaint = document.getElementById('grvt-avg-maint');
  const grvtSourceUpdates = document.getElementById('grvt-source-updates');
  const grvtSummaryTime = document.getElementById('grvt-summary-time');
  const grvtSummaryUpdated = document.getElementById('grvt-summary-updated');
  const grvtReduceSuggestionCard = document.getElementById('grvt-reduce-suggestion-card');
  const grvtReduceSuggestionMain = document.getElementById('grvt-reduce-suggestion-main');
  const grvtReduceSuggestionDetail = document.getElementById('grvt-reduce-suggestion-detail');
  const grvtAccountGrid = document.getElementById('grvt-account-grid');
  const grvtAccountsEmpty = document.getElementById('grvt-accounts-empty');

  const bpAdjustPanel = document.getElementById('bp-adjust-panel');
  const bpAdjustSizeInput = document.getElementById('bp-adjust-size');
  const bpAdjustSymbolsSelect = document.getElementById('bp-adjust-symbols');
  const bpOrderModeSelect = document.getElementById('bp-order-mode');
  const bpTwapDurationInput = document.getElementById('bp-twap-duration');
  const bpTwapDurationWrapper = document.getElementById('bp-twap-duration-wrapper');
  const bpTwapStepInput = document.getElementById('bp-twap-step');
  const bpTwapStepWrapper = document.getElementById('bp-twap-step-wrapper');
  const bpResetSymbolButton = document.getElementById('bp-reset-symbol');
  const bpAdjustAddButton = document.getElementById('bp-adjust-add');
  const bpAdjustReduceButton = document.getElementById('bp-adjust-reduce');
  const bpAdjustStatus = document.getElementById('bp-adjust-status');
  const bpAdjustHistoryBody = document.getElementById('bp-adjust-history');
  const bpTransferHistoryBody = document.getElementById('bp-transfer-history');
  const bpAdjustClearHistoryButton = document.getElementById('bp-adjust-clear-history');

  const bpRiskPanel = document.getElementById('bp-risk-panel');
  const bpRiskSettingsStatus = document.getElementById('bp-risk-settings-status');
  const bpRiskSettingsMessage = document.getElementById('bp-risk-settings-message');
  const bpRiskTestMessage = document.getElementById('bp-risk-test-message');
  const bpRiskAlertEnabledInput = document.getElementById('bp-risk-alert-enabled');
  const bpRiskThresholdSlider = document.getElementById('bp-risk-threshold-slider');
  const bpRiskThresholdInput = document.getElementById('bp-risk-threshold-input');
  const bpRiskResetInput = document.getElementById('bp-risk-reset-input');
  const bpRiskCooldownInput = document.getElementById('bp-risk-cooldown-input');
  const bpRiskThresholdLabel = document.getElementById('bp-risk-threshold-label');
  const bpRiskMeta = document.getElementById('bp-risk-ratio-meta');
  const bpRiskBarkUrlInput = document.getElementById('bp-risk-bark-url');
  const bpRiskBarkAppendInput = null;
  const bpRiskBarkTimeoutInput = document.getElementById('bp-risk-bark-timeout');
  const bpRiskTitleTemplateInput = document.getElementById('bp-risk-title-template');
  const bpRiskBodyTemplateInput = document.getElementById('bp-risk-body-template');
  const bpRiskSaveButton = document.getElementById('bp-risk-settings-save');
  const bpRiskDisableButton = document.getElementById('bp-risk-settings-disable');
  const bpRiskRefreshButton = document.getElementById('bp-risk-settings-refresh');
  const bpRiskTestButton = document.getElementById('bp-risk-settings-test');
  const bpRiskHistoryBody = document.getElementById('bp-risk-history-body');
  const bpRiskHistoryEmpty = document.getElementById('bp-risk-history-empty');
  const bpRiskHistoryStatus = document.getElementById('bp-risk-history-status');
  const bpRiskHistoryRefreshButton = document.getElementById('bp-risk-history-refresh');

  const paraAccountCount = document.getElementById('para-account-count');
  const paraEmpty = document.getElementById('para-empty');
  const paraCard = document.getElementById('para-card');
  const paraTotalPnl = document.getElementById('para-total-pnl');
  const paraMaxImReq = document.getElementById('para-max-im-req');
  // ETH/BTC PnL summary cards were removed from the PARA Multi-Account Monitor.
  const paraTotalEquity = document.getElementById('para-total-equity');
  const paraWalletBalance = document.getElementById('para-wallet-balance');
  const paraTransferableTotal = document.getElementById('para-transfer-total');
  const paraTransferableNote = document.getElementById('para-transfer-note');
  const paraRiskLevel = document.getElementById('para-risk-level');
  const paraRiskDetail = document.getElementById('para-risk-detail');
  const paraAvgMaint = document.getElementById('para-avg-maint');
  const paraSourceUpdates = document.getElementById('para-source-updates');
  const paraSummaryTime = document.getElementById('para-summary-time');
  const paraSummaryUpdated = document.getElementById('para-summary-updated');
  const paraReduceSuggestionCard = document.getElementById('para-reduce-suggestion-card');
  const paraReduceSuggestionMain = document.getElementById('para-reduce-suggestion-main');
  const paraReduceSuggestionDetail = document.getElementById('para-reduce-suggestion-detail');
  const paraPriceChartWrapper = document.getElementById('para-price-chart-wrapper');
  const paraPriceChartCanvas = document.getElementById('para-price-chart');
  const paraPriceChartNote = document.getElementById('para-price-chart-note');
  const paraPriceChartLegend = document.getElementById('para-price-chart-legend');
  const paraAccountGrid = document.getElementById('para-account-grid');
  const paraAccountsEmpty = document.getElementById('para-accounts-empty');
  const paraAdjustPanel = document.getElementById('para-adjust-panel');
  const paraAdjustSizeInput = document.getElementById('para-adjust-size');
  const paraAdjustSymbolsSelect = document.getElementById('para-adjust-symbols');
  const paraOrderModeSelect = document.getElementById('para-order-mode');
  const paraTwapDurationInput = document.getElementById('para-twap-duration');
  const paraTwapDurationWrapper = document.getElementById('para-twap-duration-wrapper');

  // PARA scheduled TWAP
  const paraTwapScheduleSymbolsSelect = document.getElementById('para-twap-schedule-symbols');
  const paraTwapScheduleResetSymbolButton = document.getElementById('para-twap-schedule-reset-symbol');
  const paraTwapScheduleIntervalInput = document.getElementById('para-twap-schedule-interval');
  const paraTwapScheduleEditHint = document.getElementById('para-twap-schedule-edit-hint');
  const paraTwapScheduleActionSelect = document.getElementById('para-twap-schedule-action');
  const paraTwapScheduleSizeInput = document.getElementById('para-twap-schedule-size');
  const paraTwapScheduleDurationInput = document.getElementById('para-twap-schedule-duration');
  const paraTwapScheduleStartButton = document.getElementById('para-twap-schedule-start');
  const paraTwapScheduleSaveEditButton = document.getElementById('para-twap-schedule-save-edit');
  const paraTwapScheduleStopButton = document.getElementById('para-twap-schedule-stop');
  const paraTwapScheduleRefreshButton = document.getElementById('para-twap-schedule-refresh');
  const paraTwapScheduleStatus = document.getElementById('para-twap-schedule-status');
  const paraTwapScheduleHistoryBody = document.getElementById('para-twap-schedule-history');
  const paraResetSymbolButton = document.getElementById('para-reset-symbol');
  const paraAdjustAddButton = document.getElementById('para-adjust-add');
  const paraAdjustReduceButton = document.getElementById('para-adjust-reduce');
  const paraAdjustStatus = document.getElementById('para-adjust-status');
  const paraAdjustHistoryBody = document.getElementById('para-adjust-history');
  const paraRiskPanel = document.getElementById('para-risk-panel');
  const paraRiskSettingsStatus = document.getElementById('para-risk-settings-status');
  const paraRiskSettingsMessage = document.getElementById('para-risk-settings-message');
  const paraRiskTestMessage = document.getElementById('para-risk-test-message');
  const paraRiskAlertEnabledInput = document.getElementById('para-risk-alert-enabled');
  const paraRiskThresholdSlider = document.getElementById('para-risk-threshold-slider');
  const paraRiskThresholdInput = document.getElementById('para-risk-threshold-input');
  const paraRiskResetInput = document.getElementById('para-risk-reset-input');
  const paraRiskCooldownInput = document.getElementById('para-risk-cooldown-input');
  const paraRiskThresholdLabel = document.getElementById('para-risk-threshold-label');
  const paraRiskMeta = document.getElementById('para-risk-ratio-meta');
  const paraRiskBarkUrlInput = document.getElementById('para-risk-bark-url');
  const paraRiskBarkAppendInput = null;
  const paraRiskBarkTimeoutInput = document.getElementById('para-risk-bark-timeout');
  const paraRiskTitleTemplateInput = document.getElementById('para-risk-title-template');
  const paraRiskBodyTemplateInput = document.getElementById('para-risk-body-template');
  const paraRiskSaveButton = document.getElementById('para-risk-settings-save');
  const paraRiskDisableButton = document.getElementById('para-risk-settings-disable');
  const paraRiskRefreshButton = document.getElementById('para-risk-settings-refresh');
  const paraRiskTestButton = document.getElementById('para-risk-settings-test');
  const paraRiskHistoryBody = document.getElementById('para-risk-history-body');
  const paraRiskHistoryEmpty = document.getElementById('para-risk-history-empty');
  const paraRiskHistoryStatus = document.getElementById('para-risk-history-status');
  const paraRiskHistoryRefreshButton = document.getElementById('para-risk-history-refresh');
  const grvtRiskPanel = document.getElementById('grvt-risk-panel');
  const riskSettingsStatus = document.getElementById('risk-settings-status');
  const riskSettingsMessage = document.getElementById('risk-settings-message');
  const riskAlertEnabledInput = document.getElementById('risk-alert-enabled');
  const riskStaleEnabledInput = document.getElementById('risk-stale-enabled');
  const riskThresholdSlider = document.getElementById('risk-threshold-slider');
  const riskThresholdInput = document.getElementById('risk-threshold-input');
  const riskResetInput = document.getElementById('risk-reset-input');
  const riskCooldownInput = document.getElementById('risk-cooldown-input');
  const riskStaleCriticalInput = document.getElementById('risk-stale-critical-input');
  const riskThresholdLabel = document.getElementById('risk-threshold-label');
  const riskMeta = document.getElementById('risk-ratio-meta');
  const riskBarkUrlInput = document.getElementById('risk-bark-url');
  const riskBarkAppendInput = document.getElementById('risk-bark-append');
  const riskBarkTimeoutInput = document.getElementById('risk-bark-timeout');
  const riskTitleTemplateInput = document.getElementById('risk-title-template');
  const riskBodyTemplateInput = document.getElementById('risk-body-template');
  const riskSaveButton = document.getElementById('risk-settings-save');
  const riskTestButton = document.getElementById('risk-settings-test');
  const riskDisableButton = document.getElementById('risk-settings-disable');
  const riskRefreshButton = document.getElementById('risk-settings-refresh');
  const riskHistoryBody = document.getElementById('risk-history-body');
  const riskHistoryEmpty = document.getElementById('risk-history-empty');
  const riskHistoryStatus = document.getElementById('risk-history-status');
  const riskHistoryRefreshButton = document.getElementById('risk-history-refresh');
  const grvtAdjustPanel = document.getElementById('grvt-adjust-panel');
  const grvtAdjustSizeInput = document.getElementById('grvt-adjust-size');
  const grvtAdjustSymbolsSelect = document.getElementById('grvt-adjust-symbols');
  const grvtResetSymbolButton = document.getElementById('grvt-reset-symbol');
  const grvtAdjustAddButton = document.getElementById('grvt-adjust-add');
  const grvtAdjustReduceButton = document.getElementById('grvt-adjust-reduce');
  const grvtAdjustStatus = document.getElementById('grvt-adjust-status');
  const grvtAdjustScope = document.getElementById('grvt-adjust-scope');
  const grvtAdjustHistoryBody = document.getElementById('grvt-adjust-history');
  const grvtTransferPanel = document.getElementById('grvt-transfer-panel');
  const grvtTransferSourceSelect = document.getElementById('grvt-transfer-source');
  const grvtTransferTargetSelect = document.getElementById('grvt-transfer-target');
  const grvtTransferAmountInput = document.getElementById('grvt-transfer-amount');
  const grvtTransferCurrencyInput = document.getElementById('grvt-transfer-currency');
  const grvtTransferTypeInput = document.getElementById('grvt-transfer-type');
  const grvtTransferReasonInput = document.getElementById('grvt-transfer-reason');
  const grvtTransferFromAccountInput = document.getElementById('grvt-transfer-from-account');
  const grvtTransferFromSubInput = document.getElementById('grvt-transfer-from-sub');
  const grvtTransferToAccountInput = document.getElementById('grvt-transfer-to-account');
  const grvtTransferToSubInput = document.getElementById('grvt-transfer-to-sub');
  const grvtTransferSubmitButton = document.getElementById('grvt-transfer-submit');
  const grvtTransferStatus = document.getElementById('grvt-transfer-status');
  const grvtTransferHistoryBody = document.getElementById('grvt-transfer-history');
  const paraTransferPanel = document.getElementById('para-transfer-panel');
  const paraTransferSourceSelect = document.getElementById('para-transfer-source');
  const paraTransferTargetSelect = document.getElementById('para-transfer-target');
  const paraTransferTargetAddressInput = document.getElementById('para-transfer-target-address');
  const paraTransferAmountInput = document.getElementById('para-transfer-amount');
  const paraTransferCurrencyInput = document.getElementById('para-transfer-currency');
  const paraTransferTypeInput = document.getElementById('para-transfer-type');
  const paraTransferReasonInput = document.getElementById('para-transfer-reason');
  const paraTransferSubmitButton = document.getElementById('para-transfer-submit');
  const paraTransferStatus = document.getElementById('para-transfer-status');
  const paraTransferHistoryBody = document.getElementById('para-transfer-history');
  const paraAutoPanel = document.getElementById('para-auto-panel');
  const paraAutoEnabledInput = document.getElementById('para-auto-enabled');
  const paraAutoAgentASelect = document.getElementById('para-auto-agent-a');
  const paraAutoAgentBSelect = document.getElementById('para-auto-agent-b');
  const paraAutoThresholdInput = document.getElementById('para-auto-threshold');
  const paraAutoMinTransferInput = document.getElementById('para-auto-min-transfer');
  const paraAutoMaxTransferInput = document.getElementById('para-auto-max-transfer');
  const paraAutoCurrencyInput = document.getElementById('para-auto-currency');
  const paraAutoCooldownInput = document.getElementById('para-auto-cooldown');
  const paraAutoUseAvailableInput = document.getElementById('para-auto-use-available');
  const paraAutoSaveButton = document.getElementById('para-auto-save');
  const paraAutoDisableButton = document.getElementById('para-auto-disable');
  const paraAutoRefreshButton = document.getElementById('para-auto-refresh');
  const paraAutoStatus = document.getElementById('para-auto-status');
  const paraAutoMeasurement = document.getElementById('para-auto-measurement');
  const paraAutoLastAction = document.getElementById('para-auto-last-action');
  const paraAutoPairLabel = document.getElementById('para-auto-pair');
  const bpAutoPanel = document.getElementById('bp-auto-panel');
  const bpAutoEnabledInput = document.getElementById('bp-auto-enabled');
  const bpAutoAgentASelect = document.getElementById('bp-auto-agent-a');
  const bpAutoAgentBSelect = document.getElementById('bp-auto-agent-b');
  const bpAutoThresholdInput = document.getElementById('bp-auto-threshold');
  const bpAutoMinTransferInput = document.getElementById('bp-auto-min-transfer');
  const bpAutoMaxTransferInput = document.getElementById('bp-auto-max-transfer');
  const bpAutoCurrencyInput = document.getElementById('bp-auto-currency');
  const bpAutoCooldownInput = document.getElementById('bp-auto-cooldown');
  const bpAutoUseAvailableInput = document.getElementById('bp-auto-use-available');
  const bpAutoSaveButton = document.getElementById('bp-auto-save');
  const bpAutoDisableButton = document.getElementById('bp-auto-disable');
  const bpAutoRefreshButton = document.getElementById('bp-auto-refresh');
  const bpAutoStatus = document.getElementById('bp-auto-status');
  const bpAutoMeasurement = document.getElementById('bp-auto-measurement');
  const bpAutoLastAction = document.getElementById('bp-auto-last-action');
  const bpAutoPairLabel = document.getElementById('bp-auto-pair');
  const grvtAutoPanel = document.getElementById('grvt-auto-panel');
  const grvtAutoEnabledInput = document.getElementById('grvt-auto-enabled');
  const grvtAutoAgentASelect = document.getElementById('grvt-auto-agent-a');
  const grvtAutoAgentBSelect = document.getElementById('grvt-auto-agent-b');
  const grvtAutoThresholdInput = document.getElementById('grvt-auto-threshold');
  const grvtAutoMinTransferInput = document.getElementById('grvt-auto-min-transfer');
  const grvtAutoMaxTransferInput = document.getElementById('grvt-auto-max-transfer');
  const grvtAutoCurrencyInput = document.getElementById('grvt-auto-currency');
  const grvtAutoCooldownInput = document.getElementById('grvt-auto-cooldown');
  const grvtAutoUseAvailableInput = document.getElementById('grvt-auto-use-available');
  const grvtAutoSaveButton = document.getElementById('grvt-auto-save');
  const grvtAutoDisableButton = document.getElementById('grvt-auto-disable');
  const grvtAutoRefreshButton = document.getElementById('grvt-auto-refresh');
  const grvtAutoStatus = document.getElementById('grvt-auto-status');
  const grvtAutoMeasurement = document.getElementById('grvt-auto-measurement');
  const grvtAutoLastAction = document.getElementById('grvt-auto-last-action');
  const grvtAutoPairLabel = document.getElementById('grvt-auto-pair');
    // Spread monitor + strategy profit monitor modules were removed from the UI.
    // BTC/ETH volatility + simulation panels removed.
  const MAX_SPREAD_HISTORY_POINTS = 1800;
    const MAX_STRATEGY_EVENTS = 120;
  // GRVT/PARA 每个账户持仓展示上限；设为 Infinity 表示展示全部。
  const MAX_GRVT_POSITIONS = Infinity;
  const MAX_PARA_POSITIONS = Infinity;
  const RISK_GRADIENTS = [
    {
      max: 0.1,
      label: 'low',
      gradient: 'linear-gradient(135deg, #34e89e, #0f9d58)',
      color: '#041b11',
      shadow: '0 8px 18px rgba(15, 157, 88, 0.35)'
    },
    {
      max: 0.25,
      label: 'guarded',
      gradient: 'linear-gradient(135deg, #f9f871, #f7b267)',
      color: '#2b1d02',
      shadow: '0 8px 18px rgba(247, 178, 103, 0.35)'
    },
    {
      max: 0.5,
      label: 'elevated',
      gradient: 'linear-gradient(135deg, #f79d65, #f05a28)',
      color: '#2a0a02',
      shadow: '0 8px 18px rgba(240, 90, 40, 0.35)'
    },
    {
      max: Infinity,
      label: 'critical',
      gradient: 'linear-gradient(135deg, #ff4e50, #c81d25)',
      color: '#ffeef2',
      shadow: '0 8px 18px rgba(200, 29, 37, 0.4)'
    }
  ];
  const GLOBAL_RISK_GRADIENTS = [
    {
      max: 0.2,
      label: 'low',
      gradient: 'linear-gradient(135deg, #34e89e, #0f9d58)',
      color: '#041b11',
      shadow: '0 8px 18px rgba(15, 157, 88, 0.35)'
    },
    {
      max: 0.4,
      label: 'guarded',
      gradient: 'linear-gradient(135deg, #f9f871, #f7b267)',
      color: '#2b1d02',
      shadow: '0 8px 18px rgba(247, 178, 103, 0.35)'
    },
    {
      max: 0.7,
      label: 'elevated',
      gradient: 'linear-gradient(135deg, #f79d65, #f05a28)',
      color: '#2a0a02',
      shadow: '0 8px 18px rgba(240, 90, 40, 0.35)'
    },
    {
      max: Infinity,
      label: 'critical',
      gradient: 'linear-gradient(135deg, #ff4e50, #c81d25)',
      color: '#ffeef2',
      shadow: '0 8px 18px rgba(200, 29, 37, 0.4)'
    }
  ];
  const GLOBAL_RISK_THRESHOLD_TEXT = '阈值 20% / 40% / 70%';
  const BTC_LINE_COLOR = '#f6c177';
  const ETH_LINE_COLOR = '#4cc9f0';
  const RISK_CAPACITY_LINE_COLOR = '#c084fc';
  const PRICE_DIFF_LINE_COLOR = '#7dd3fc';
  const DEFAULT_MARGIN_SCHEDULE = [
    { maxNotional: 600000, initial: 0.02, maintenance: 0.01 },
    { maxNotional: 1600000, initial: 0.04, maintenance: 0.02 },
    { maxNotional: 4000000, initial: 0.05, maintenance: 0.025 },
    { maxNotional: 10000000, initial: 0.1, maintenance: 0.05 },
    { maxNotional: 20000000, initial: 0.2, maintenance: 0.1 },
    { maxNotional: 50000000, initial: 0.25, maintenance: 0.125 },
    { maxNotional: 80000000, initial: 0.3333, maintenance: 0.1667 },
    { maxNotional: 101000000, initial: 0.5, maintenance: 0.25 },
    { maxNotional: Infinity, initial: 1, maintenance: 0.5 }
  ];
  const MARGIN_SCHEDULES = {
    BTC: DEFAULT_MARGIN_SCHEDULE,
    ETH: DEFAULT_MARGIN_SCHEDULE,
  };
  const RISK_CAPACITY_CONFIRMATION_CYCLES = 3;
  const RISK_CAPACITY_DEVIATION_THRESHOLD = 0.1;
  const RISK_CAPACITY_MIN_ABS_DELTA = 500;
  const RISK_CAPACITY_PENDING_TOLERANCE = 0.001;
      let batchBusy = false;
      let lastDefaultPaused = false;
      let selectedSpreadAgent = null;
      let lastSpreadOptionsKey = '';
      let selectedStrategyAgent = null;
      let lastStrategyOptionsKey = '';
      let lastMetricsSnapshot = null;
  let grvtAdjustLocked = false;
  let grvtPendingRequestId = null;
  let paraAdjustLocked = false;
  let paraPendingRequestId = null;
  let bpAdjustLocked = false;
  let bpPendingRequestId = null;
  let bpAdjustStatusStickyUntil = 0;

  // Allow concurrent TWAPs on the same agent as long as they are for different symbols.
  // We track which symbols are currently active (pending/running/in_progress) for the
  // current agent, based on /backpack/adjustments history.
  const bpActiveSymbolsForAgent = new Set();

  // If an ACK is lost (e.g. monitor crash/restart) the UI might stay locked.
  // Keep a conservative timeout to auto-unlock so operators can re-issue orders.
  let bpAdjustLockedSince = 0;
  const BP_ADJUST_LOCK_TIMEOUT_MS = 10 * 60 * 1000;

  const DEBUG_UI = new URLSearchParams(window.location.search).get('debug') === '1';

  function setBpAdjustStatus(text, { stickyMs = 0 } = {}) {
    if (!bpAdjustStatus) {
      return;
    }
    bpAdjustStatus.textContent = String(text ?? '');
    if (stickyMs && Number.isFinite(stickyMs) && stickyMs > 0) {
      bpAdjustStatusStickyUntil = Date.now() + stickyMs;
    }
  }

  function shouldRespectBpAdjustSticky() {
    return Date.now() < (bpAdjustStatusStickyUntil || 0);
  }

  function validateBpAdjustDom() {
    const missing = [];
    if (!bpAdjustAddButton) missing.push('#bp-adjust-add');
    if (!bpAdjustReduceButton) missing.push('#bp-adjust-reduce');
    if (!bpAdjustSizeInput) missing.push('#bp-adjust-size');
    if (!bpOrderModeSelect) missing.push('#bp-order-mode');
    // symbols dropdown can be empty, but it must exist
    if (!bpAdjustSymbolsSelect) missing.push('#bp-adjust-symbols');
    if (missing.length) {
      setBpAdjustStatus(`Backpack 调仓 UI 缺少元素：${missing.join(', ')}`, { stickyMs: 60_000 });
      bpAdjustLocked = true;
      updateBpAdjustButtons();
      return false;
    }
    return true;
  }

  async function clearBpAdjustHistory() {
    if (!bpAdjustClearHistoryButton) return;
    const ok = confirm('确认清除 Backpack 加/减仓历史？这会删除本地持久化记录（不可恢复）。');
    if (!ok) return;
    bpAdjustClearHistoryButton.disabled = true;
    setBpAdjustStatus('正在清除历史…', { stickyMs: 2000 });
    try {
      await fetch('/backpack/adjustments/clear', {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
      });
      // Force-refresh history tables.
      try {
        await refreshMetrics();
      } catch (_) {
        // ignore
      }
      setBpAdjustStatus('历史已清除', { stickyMs: 2500 });
    } catch (e) {
      console.warn('clearBpAdjustHistory failed', e);
      setBpAdjustStatus('清除失败（见 console）', { stickyMs: 4000 });
    } finally {
      bpAdjustClearHistoryButton.disabled = false;
    }
  }

  bpAdjustClearHistoryButton && bpAdjustClearHistoryButton.addEventListener('click', () => {
    clearBpAdjustHistory();
  });

  // NOTE: We intentionally removed the old Backpack adjust debug hooks.
  // They used capture-phase listeners and also called sendBpAdjustment(),
  // which caused duplicate submissions (one click => two POSTs) once we
  // switched to "submit success unlock" semantics.
  let grvtTransferLocked = false;
  let grvtTransferOptionsKey = '';
  const grvtTransferDefaults = new Map();
  let paraTransferLocked = false;
  let paraTransferOptionsKey = '';
  const paraTransferDefaults = new Map();
  let autoBalanceAgentsKey = '';
  let autoBalanceConfigKey = '';
  let autoBalanceBusy = false;
  let autoBalanceDirty = false;
  let autoBalanceLastConfig = null;
  let paraAutoAgentsKey = '';
  let paraAutoConfigKey = '';
  let paraAutoBusy = false;
  let paraAutoDirty = false;
  let paraAutoLastConfig = null;
  let bpAutoAgentsKey = '';
  let bpAutoConfigKey = '';
  let bpAutoBusy = false;
  let bpAutoDirty = false;
  let bpAutoLastConfig = null;
  let bpDualVolumeLastStatus = null;
  let bpDualVolumeDirty = false;
  let bpDualVolumeBusy = false;
  let riskSettingsBusy = false;
  let paraRiskSettingsBusy = false;
  let riskSettingsDirty = false;
  let riskSettingsSnapshot = null;
  let riskTestBusy = false;
  let latestGlobalRiskRatio = null;
  let paraLatestRiskRatio = null;
  let bpLatestRiskRatio = null;
  let grvtLatestRiskRatio = null;
  let grvtSymbolOptionsKey = '';
  let grvtAccountGridKey = '';
  let paraSymbolOptionsKey = '';
  let paraTwapSymbolOptionsKey = '';
  let paraAccountGridKey = '';
  let bpSymbolOptionsKey = '';
  let bpAccountGridKey = '';
  let paraRiskHistoryEntries = [];
  let bpRiskHistoryEntries = [];

  function recomputeGlobalRiskRatio() {
    if (Number.isFinite(paraLatestRiskRatio)) {
      latestGlobalRiskRatio = paraLatestRiskRatio;
    } else if (Number.isFinite(grvtLatestRiskRatio)) {
      latestGlobalRiskRatio = grvtLatestRiskRatio;
    } else {
      latestGlobalRiskRatio = null;
    }
  }
  let riskHistoryBusy = false;
  let riskHistoryEntries = [];
  let lastRiskHistoryFetch = 0;
  const RISK_HISTORY_REFRESH_INTERVAL = 5000;
  const riskCapacityBufferState = {
    acceptedValue: null,
    acceptedAt: null,
    pendingValue: null,
    pendingCycles: 0,
    pendingDeltaPct: 0,
    pendingSince: null,
  };
  const paraRiskCapacityBufferState = {
    acceptedValue: null,
    acceptedAt: null,
    pendingValue: null,
    pendingCycles: 0,
    pendingDeltaPct: 0,
    pendingSince: null,
  };
  // BTC/ETH simulation state removed.

  const PARA_STALE_WARN_SEC = 10;
  const PARA_STALE_CRIT_SEC = 30;

      const numberFormatter = new Intl.NumberFormat(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 6,
        notation: 'compact'
      });

      function toNumber(value) {
        if (value === null || value === undefined) {
          return 0;
        }
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : 0;
      }

      function clamp(value, min, max) {
        if (!Number.isFinite(value)) {
          return min;
        }
        if (value < min) {
          return min;
        }
        if (value > max) {
          return max;
        }
        return value;
      }

      function parseDecimal(value) {
        if (value === null || value === undefined) {
          return null;
        }
        if (typeof value === 'number') {
          return Number.isFinite(value) ? value : null;
        }
        const normalized = String(value).replace(/,/g, '').trim();
        if (!normalized || normalized === '--') {
          return null;
        }
        const numeric = Number(normalized);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function computePercent(numerator, denominator) {
        if (!Number.isFinite(numerator) || !Number.isFinite(denominator) || Math.abs(denominator) < 1e-12) {
          return null;
        }
        return (numerator / denominator) * 100;
      }

      function formatPercent(value, digits = 2) {
        if (!Number.isFinite(value)) {
          return '—';
        }
        return `${value.toFixed(digits)}%`;
      }

      function formatSignedPercent(value, digits = 2) {
        if (!Number.isFinite(value)) {
          return '—';
        }
        const prefix = value > 0 ? '+' : '';
        return `${prefix}${value.toFixed(digits)}%`;
      }

      function formatSignedNumber(value, digits = 6) {
        if (!Number.isFinite(value)) {
          return '—';
        }
        const prefix = value > 0 ? '+' : '';
        return `${prefix}${value.toFixed(digits)}`;
      }

      function percentClass(value) {
        if (!Number.isFinite(value) || Math.abs(value) < 1e-9) {
          return 'vol-neutral';
        }
        return value > 0 ? 'vol-positive' : 'vol-negative';
      }

      function formatMultiplier(value, digits = 2) {
        if (!Number.isFinite(value)) {
          return '—';
        }
        return `${value.toFixed(digits)}x`;
      }

      function extractNumeric(bucket, key) {
        if (!bucket) {
          return null;
        }
        const value = bucket[key];
        if (typeof value === 'number') {
          return Number.isFinite(value) ? value : null;
        }
        return parseDecimal(value);
      }

      function getSeriesBounds(...seriesList) {
        let min = Infinity;
        let max = -Infinity;
        let hasValue = false;

        for (const series of seriesList) {
          for (const value of series) {
            if (!Number.isFinite(value)) {
              continue;
            }
            hasValue = true;
            if (value < min) {
              min = value;
            }
            if (value > max) {
              max = value;
            }
          }
        }

        if (!hasValue) {
          return { hasValue: false, min: 0, max: 0 };
        }

        if (min === max) {
          const epsilon = Math.abs(min) > 0 ? Math.abs(min) * 0.05 : 0.05;
          min -= epsilon;
          max += epsilon;
        }

        const padding = (max - min) * 0.08;
        return {
          hasValue: true,
          min: min - padding,
          max: max + padding,
        };
      }

      function prepareCanvas(canvas) {
        if (!canvas) {
          return null;
        }

        const rect = canvas.getBoundingClientRect();
        const width = rect.width || canvas.parentElement?.clientWidth || 600;
        const height = rect.height || 260;
        const dpr = window.devicePixelRatio || 1;

        canvas.width = width * dpr;
        canvas.height = height * dpr;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          return null;
        }

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        return { ctx, width, height };
      }

      function drawSeries(ctx, values, mapX, mapY, color) {
        ctx.beginPath();
        let started = false;
        for (let index = 0; index < values.length; index += 1) {
          const value = values[index];
          if (!Number.isFinite(value)) {
            started = false;
            continue;
          }

          const x = mapX(index);
          const y = mapY(value);
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        }

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function drawTimedSeries(ctx, points, mapX, mapY, color, width = 2) {
        ctx.beginPath();
        let started = false;
        for (const point of points) {
          const ts = Number(point.ts);
          const value = Number(point.value);
          if (!Number.isFinite(ts) || !Number.isFinite(value)) {
            started = false;
            continue;
          }
          const x = mapX(ts);
          const y = mapY(value);
          if (!Number.isFinite(x) || !Number.isFinite(y)) {
            started = false;
            continue;
          }
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
      }

      // Spread / strategy monitor modules removed.

      function escapeHtml(value) {
        return String(value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function formatDecimal(value, fractionDigits = 4) {
        if (value === null || value === undefined) {
          return '--';
        }
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed || trimmed === '--' || trimmed.toLowerCase() === 'none') {
            return '--';
          }
          value = trimmed.replace(/,/g, '');
        }
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return '--';
        }
        return numeric.toFixed(fractionDigits);
      }

      function formatUsd(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return '--';
        }
        return `$${numberFormatter.format(numeric)}`;
      }

      function formatCoinAmount(value, fractionDigits = 4) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          // Spread/Strategy renderers removed.
        };
      }

      function describeSymbolScope(symbols) {
        if (!Array.isArray(symbols)) {
          return '全部';
        }
        const normalized = symbols
          .map((symbol) => normalizeSymbolLabel(symbol))
          .filter(Boolean);
        if (!normalized.length) {
          return '全部';
        }
        return normalized.join(', ');
      }

      function describeTransferDirection(direction) {
        if (!direction) {
          return '—';
        }
        const normalized = String(direction).trim().toLowerCase();
        if (normalized === 'main_to_sub') {
          return '主账户 → 子账户';
        }
        if (normalized === 'sub_to_main') {
          return '子账户 → 主账户';
        }
        if (normalized === 'main_to_main') {
          return '主账户 → 主账户';
        }
        if (normalized === 'l2_transfer') {
          return 'L2 转账';
        }
        return normalized;
      }

      function formatTransferRoute(payload) {
        if (!payload) {
          return '—';
        }
        if (payload.target_l2_address) {
          return `→ ${payload.target_l2_address}`;
        }
        const fromAccount = payload.from_account_id || payload.from_account || payload.from || '';
        const fromSub = payload.from_sub_account_id ?? payload.from_sub_account ?? '';
        const toAccount = payload.to_account_id || payload.to_account || payload.to || '';
        const toSub = payload.to_sub_account_id ?? payload.to_sub_account ?? '';
        const formatSide = (account, sub) => {
          if (!account && !sub) {
            return '?';
          }
          if (!sub) {
            return account || '?';
          }
          return `${account || '?'} (#${sub})`;
        };
        return `${formatSide(fromAccount, fromSub)} → ${formatSide(toAccount, toSub)}`;
      }

      function getInputValue(element) {
        if (!element) {
          return '';
        }
        return String(element.value ?? '').trim();
      }

      function setInputValue(element, value, { force = false } = {}) {
        if (!element) {
          return;
        }
        if (!force && element.value) {
          return;
        }
        element.value = value ?? '';
      }

      function buildTransferRouteFromDefaults(defaults, direction) {
        if (!defaults) {
          return null;
        }
        const normalizedDirection = String(direction || defaults.direction || 'sub_to_main').toLowerCase();
        if (defaults.routes && typeof defaults.routes === 'object') {
          const fromRoutes = defaults.routes[normalizedDirection];
          if (fromRoutes && typeof fromRoutes === 'object') {
            return fromRoutes;
          }
        }
        const normalize = (value) => {
          if (value === null || value === undefined) {
            return '';
          }
          return String(value).trim();
        };
        const mainAccount = normalize(defaults.main_account_id || defaults.from_account_id);
        const tradingSub = normalize(defaults.sub_account_id || defaults.to_sub_account_id);
        const mainSub = normalize(defaults.main_sub_account_id || defaults.to_sub_account_id || '0') || '0';
        if (!mainAccount) {
          return null;
        }
        if (normalizedDirection === 'sub_to_main') {
          if (!tradingSub) {
            return null;
          }
          return {
            from_account_id: mainAccount,
            from_sub_account_id: tradingSub,
            to_account_id: mainAccount,
            to_sub_account_id: mainSub,
          };
        }
        if (normalizedDirection === 'main_to_sub') {
          if (!tradingSub) {
            return null;
          }
          return {
            from_account_id: mainAccount,
            from_sub_account_id: mainSub,
            to_account_id: mainAccount,
            to_sub_account_id: tradingSub,
          };
        }
        return null;
      }

      function setGrvtTransferStatus(message) {
        if (grvtTransferStatus) {
          grvtTransferStatus.textContent = message || '等待指令…';
        }
      }

      function updateGrvtTransferButtons() {
        if (!grvtTransferSubmitButton) {
          return;
        }
        const sourceValue = grvtTransferSourceSelect?.value || '';
        const targetValue = grvtTransferTargetSelect?.value || '';
        const selectionsReady = Boolean(sourceValue && targetValue && sourceValue !== targetValue);
        grvtTransferSubmitButton.disabled = grvtTransferLocked || !selectionsReady;
      }

      function syncGrvtTransferSelectionStatus() {
        if (grvtTransferLocked) {
          return;
        }
        const sourceOptions = grvtTransferSourceSelect?.options?.length || 0;
        const targetOptions = grvtTransferTargetSelect?.options?.length || 0;
        const sourceValue = grvtTransferSourceSelect?.value;
        const targetValue = grvtTransferTargetSelect?.value;
        if (!sourceOptions || !targetOptions) {
          setGrvtTransferStatus('等待 VPS 提供转账参数…');
          return;
        }
        if (Math.min(sourceOptions, targetOptions) < 2) {
          setGrvtTransferStatus('至少需要两台 VPS 才能执行主账户互转');
          return;
        }
        if (!sourceValue || !targetValue) {
          setGrvtTransferStatus('请先选择来源和目标 VPS');
          return;
        }
        if (sourceValue === targetValue) {
          setGrvtTransferStatus('请为来源与目标选择不同的 VPS');
          return;
        }
        setGrvtTransferStatus('等待指令…');
      }

      function updateGrvtTransferAgents(options) {
        if (!grvtTransferPanel || !grvtTransferSourceSelect || !grvtTransferTargetSelect) {
          return;
        }
        const normalized = Array.isArray(options)
          ? options
              .map((option) => {
                const agentId = option?.agentId || option?.agent || option?.id || '';
                if (!agentId) {
                  return null;
                }
                const label = option?.label || option?.name || agentId;
                const defaults = option?.defaults && typeof option.defaults === 'object' ? option.defaults : {};
                return { agentId, label, defaults };
              })
              .filter(Boolean)
          : [];

        if (!normalized.length) {
          grvtTransferPanel.classList.add('hidden');
          grvtTransferSourceSelect.innerHTML = '';
          grvtTransferTargetSelect.innerHTML = '';
          grvtTransferDefaults.clear();
          grvtTransferLocked = false;
          grvtTransferOptionsKey = '';
          setGrvtTransferStatus('等待 VPS 提供转账参数…');
          updateGrvtTransferButtons();
          return;
        }

        const optionsKey = normalized
          .map((option) => `${option.agentId}:${JSON.stringify(option.defaults || {})}`)
          .join('|');
        const shouldRebuild =
          optionsKey !== grvtTransferOptionsKey ||
          grvtTransferSourceSelect.options.length !== normalized.length ||
          grvtTransferTargetSelect.options.length !== normalized.length;
        grvtTransferDefaults.clear();
        for (const option of normalized) {
          grvtTransferDefaults.set(option.agentId, option.defaults || {});
        }
        grvtTransferPanel.classList.remove('hidden');

        if (shouldRebuild) {
          grvtTransferOptionsKey = optionsKey;
          const previousSource = grvtTransferSourceSelect.value;
          const previousTarget = grvtTransferTargetSelect.value;
          const rebuildSelect = (select, previous) => {
            select.innerHTML = '';
            for (const option of normalized) {
              const element = document.createElement('option');
              element.value = option.agentId;
              element.textContent = option.label;
              select.appendChild(element);
            }
            if (previous && normalized.some((option) => option.agentId === previous)) {
              select.value = previous;
            } else if (select.options.length) {
              select.selectedIndex = 0;
            } else {
              select.value = '';
            }
          };
          rebuildSelect(grvtTransferSourceSelect, previousSource);
          rebuildSelect(grvtTransferTargetSelect, previousTarget);

          if (
            normalized.length > 1 &&
            grvtTransferSourceSelect.value &&
            grvtTransferSourceSelect.value === grvtTransferTargetSelect.value
          ) {
            const alternative = normalized.find((option) => option.agentId !== grvtTransferSourceSelect.value);
            if (alternative) {
              grvtTransferTargetSelect.value = alternative.agentId;
            }
          }
        }

        const sourceAgent = grvtTransferSourceSelect.value;
        const targetAgent = grvtTransferTargetSelect.value;
        if (sourceAgent) {
          applyGrvtTransferDefaults('source', { forceAll: true });
        }
        if (targetAgent) {
          applyGrvtTransferDefaults('target', { forceAll: true });
        }
        syncGrvtTransferSelectionStatus();
        updateGrvtTransferButtons();
      }

      function applyGrvtTransferDefaults(role, { forceAll = false } = {}) {
        const select = role === 'target' ? grvtTransferTargetSelect : grvtTransferSourceSelect;
        const agentId = select?.value;
        if (!agentId) {
          updateGrvtTransferButtons();
          return;
        }
        const defaults = grvtTransferDefaults.get(agentId) || {};
        if (role === 'source') {
          if (grvtTransferCurrencyInput && (forceAll || !grvtTransferCurrencyInput.value)) {
            grvtTransferCurrencyInput.value = (defaults.currency || 'USDT').toUpperCase();
          }
          if (grvtTransferTypeInput && (forceAll || !grvtTransferTypeInput.value)) {
            grvtTransferTypeInput.value = defaults.transfer_type || 'spot';
          }
        }
        updateGrvtTransferRoute({ force: true });
        updateGrvtTransferButtons();
      }

      function updateGrvtTransferRoute({ force = false } = {}) {
        const sourceId = grvtTransferSourceSelect?.value;
        const targetId = grvtTransferTargetSelect?.value;
        const sourceDefaults = (sourceId && grvtTransferDefaults.get(sourceId)) || {};
        const targetDefaults = (targetId && grvtTransferDefaults.get(targetId)) || {};
        const direction = 'main_to_main';
        const sourceRoute = buildTransferRouteFromDefaults(sourceDefaults, direction) || {};
        const targetRoute = buildTransferRouteFromDefaults(targetDefaults, direction) || {};
        const fallbackFromAccount =
          sourceRoute.from_account_id ||
          sourceDefaults.main_account_id ||
          sourceDefaults.from_account_id ||
          '';
        const fallbackFromSub =
          sourceRoute.from_sub_account_id ||
          sourceDefaults.main_sub_account_id ||
          sourceDefaults.sub_account_id ||
          sourceDefaults.from_sub_account_id ||
          '0';
        const fallbackToAccount =
          targetRoute.to_account_id ||
          targetDefaults.main_account_id ||
          targetDefaults.to_account_id ||
          sourceRoute.to_account_id ||
          '';
        const fallbackToSub =
          targetRoute.to_sub_account_id ||
          targetDefaults.main_sub_account_id ||
          targetDefaults.to_sub_account_id ||
          sourceRoute.to_sub_account_id ||
          '0';
        setInputValue(grvtTransferFromAccountInput, fallbackFromAccount, { force });
        setInputValue(grvtTransferFromSubInput, fallbackFromSub, { force });
        setInputValue(grvtTransferToAccountInput, fallbackToAccount, { force });
        setInputValue(grvtTransferToSubInput, fallbackToSub, { force });
      }

      async function sendGrvtTransfer() {
        if (grvtTransferLocked) {
          return;
        }
        const sourceAgentId = grvtTransferSourceSelect?.value;
        const targetAgentId = grvtTransferTargetSelect?.value;
        if (!sourceAgentId || !targetAgentId) {
          setGrvtTransferStatus('请先选择来源和目标 VPS');
          return;
        }
        if (sourceAgentId === targetAgentId && (grvtTransferSourceSelect?.options?.length || 0) > 1) {
          setGrvtTransferStatus('来源与目标 VPS 必须不同');
          return;
        }
        const amountValue = parseFloat(getInputValue(grvtTransferAmountInput) || '0');
        if (!Number.isFinite(amountValue) || amountValue <= 0) {
          setGrvtTransferStatus('请输入合法的数量');
          return;
        }
        const currencyValue = (getInputValue(grvtTransferCurrencyInput) || 'USDT').toUpperCase();
        const payload = {
          agent_ids: [sourceAgentId],
          target_agent_id: targetAgentId,
          num_tokens: amountValue,
          currency: currencyValue,
          direction: 'main_to_main',
          from_account_id: getInputValue(grvtTransferFromAccountInput),
          from_sub_account_id: getInputValue(grvtTransferFromSubInput),
          to_account_id: getInputValue(grvtTransferToAccountInput),
          to_sub_account_id: getInputValue(grvtTransferToSubInput),
          transfer_type: getInputValue(grvtTransferTypeInput) || undefined,
        };

        const missing = Object.entries({
          from_account_id: payload.from_account_id,
          from_sub_account_id: payload.from_sub_account_id,
          to_account_id: payload.to_account_id,
          to_sub_account_id: payload.to_sub_account_id,
        })
          .filter(([, value]) => !value)
          .map(([key]) => key);
        if (missing.length) {
          setGrvtTransferStatus(`缺少字段：${missing.join(', ')}`);
          return;
        }

        if (!payload.transfer_type) {
          delete payload.transfer_type;
        }

        const reason = getInputValue(grvtTransferReasonInput);
        if (reason) {
          payload.reason = reason;
        }

        grvtTransferLocked = true;
        updateGrvtTransferButtons();
        setGrvtTransferStatus('提交转账请求…');
        try {
          const response = await fetch('/grvt/transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          setGrvtTransferStatus('等待 VPS ACK…');
          await refreshMetrics();
        } catch (error) {
          grvtTransferLocked = false;
          updateGrvtTransferButtons();
          setGrvtTransferStatus(`请求失败：${error}`);
        }
      }

      function renderGrvtTransferHistory(summary) {
        if (!grvtTransferHistoryBody) {
          return;
        }
        const requests = Array.isArray(summary?.requests)
          ? summary.requests.filter((request) => (request?.action || '').toLowerCase() === 'transfer')
          : [];
        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const pendingStatuses = ['pending', 'in_progress'];
        let locked = false;
        let statusMessage = '等待指令…';
        const resolveTargetLabel = (payload) => {
          if (!payload || typeof payload !== 'object') {
            return '';
          }
          const metadata = payload.transfer_metadata && typeof payload.transfer_metadata === 'object' ? payload.transfer_metadata : {};
          return metadata.target_agent_label || metadata.target_agent_id || payload.target_agent_id || '';
        };

        const active = summary?.active_request;
        const activeIsTransfer = (active?.action || '').toLowerCase() === 'transfer' && pendingStatuses.includes(normalizeStatus(active?.overall_status));
        const pendingCandidate = activeIsTransfer ? active : requests.find((request) => pendingStatuses.includes(normalizeStatus(request.overall_status)));
        if (pendingCandidate) {
          locked = true;
          const targetAgents = Array.isArray(pendingCandidate.target_agents) ? pendingCandidate.target_agents.join(', ') : 'VPS';
          const pendingTarget = resolveTargetLabel(pendingCandidate.payload);
          const targetHint = pendingTarget ? ` → ${pendingTarget}` : '';
          statusMessage = `等待 ${(targetAgents || 'VPS')}${targetHint} ACK…`;
        } else if (requests.length) {
          const latest = requests[0];
          const latestStatus = normalizeStatus(latest.overall_status);
          const payload = latest?.payload || {};
          const directionText = describeTransferDirection(payload.direction || latest?.direction);
          if (latestStatus === 'completed' || latestStatus === 'acknowledged') {
            statusMessage = `最近一次 ${directionText} 已完成`;
          } else if (latestStatus === 'failed') {
            statusMessage = `最近一次 ${directionText} 部分失败`;
          } else if (latestStatus) {
            statusMessage = `最近状态：${latestStatus}`;
          }
        }

        grvtTransferLocked = locked;
        setGrvtTransferStatus(statusMessage);
        updateGrvtTransferButtons();

        if (!requests.length) {
          grvtTransferHistoryBody.innerHTML = '<tr><td colspan="6">暂无转账记录</td></tr>';
          return;
        }

        const rows = [];
        for (const request of requests.slice(0, 6)) {
          const createdText = formatTimestamp(request.created_at) ?? '--';
          const payload = request.payload || {};
          const sourceAgents = Array.isArray(request.target_agents) ? request.target_agents.join(', ') : '—';
          const targetLabel = resolveTargetLabel(payload) || '—';
          const amountValue = `${numberFormatter.format(toNumber(payload.num_tokens ?? request.magnitude ?? 0))} ${(payload.currency || 'USDC').toUpperCase()}`;
          const routeText = formatTransferRoute(payload);
          const statusText = request.overall_status || 'pending';
          const reasonText = payload?.transfer_metadata?.reason || payload.reason || '';
          const directionText = describeTransferDirection(payload.direction || payload?.transfer_metadata?.direction || request.direction);
          const noteText = reasonText ? `${statusText} / ${reasonText}` : statusText;
          rows.push(`
            <tr>
              <td>${escapeHtml(createdText)}</td>
              <td>${escapeHtml(`${sourceAgents || '—'} → ${targetLabel || '—'}`)}</td>
              <td>${escapeHtml(directionText)}</td>
              <td>${escapeHtml(amountValue)}</td>
              <td>${escapeHtml(routeText)}</td>
              <td>${escapeHtml(noteText)}</td>
            </tr>
          `);
        }

        grvtTransferHistoryBody.innerHTML = rows.join('');
        if (!locked) {
          syncGrvtTransferSelectionStatus();
        }
      }

      function setParaTransferStatus(message) {
        if (paraTransferStatus) {
          paraTransferStatus.textContent = message || '等待指令…';
        }
      }

      function updateParaTransferButtons() {
        if (!paraTransferSubmitButton) {
          return;
        }
        const sourceValue = paraTransferSourceSelect?.value || '';
        const targetValue = paraTransferTargetSelect?.value || '';
        const targetAddress = getInputValue(paraTransferTargetAddressInput);
        const selectionsReady = Boolean(sourceValue && targetValue && sourceValue !== targetValue && targetAddress);
        paraTransferSubmitButton.disabled = paraTransferLocked || !selectionsReady;
      }

      function syncParaTransferSelectionStatus() {
        if (paraTransferLocked) {
          return;
        }
        const sourceOptions = paraTransferSourceSelect?.options?.length || 0;
        const targetOptions = paraTransferTargetSelect?.options?.length || 0;
        const sourceValue = paraTransferSourceSelect?.value;
        const targetValue = paraTransferTargetSelect?.value;
        if (!sourceOptions || !targetOptions) {
          setParaTransferStatus('等待 VPS 提供转账参数…');
          return;
        }
        if (Math.min(sourceOptions, targetOptions) < 2) {
          setParaTransferStatus('至少需要两台 VPS 才能执行主账户互转');
          return;
        }
        if (!sourceValue || !targetValue) {
          setParaTransferStatus('请先选择来源和目标 VPS');
          return;
        }
        if (sourceValue === targetValue) {
          setParaTransferStatus('请为来源与目标选择不同的 VPS');
          return;
        }
        const targetAddress = getInputValue(paraTransferTargetAddressInput);
        if (!targetAddress) {
          setParaTransferStatus('目标 L2 地址缺失');
          return;
        }
        setParaTransferStatus('等待指令…');
      }

      function updateParaTransferAgents(options) {
        if (!paraTransferPanel || !paraTransferSourceSelect || !paraTransferTargetSelect) {
          return;
        }
        const normalized = Array.isArray(options)
          ? options
              .map((option) => {
                const agentId = option?.agentId || option?.agent || option?.id || '';
                if (!agentId) {
                  return null;
                }
                const label = option?.label || option?.name || agentId;
                const defaults = option?.defaults && typeof option.defaults === 'object' ? option.defaults : {};
                return { agentId, label, defaults };
              })
              .filter(Boolean)
          : [];

        if (!normalized.length) {
          paraTransferPanel.classList.add('hidden');
          paraTransferSourceSelect.innerHTML = '';
          paraTransferTargetSelect.innerHTML = '';
          paraTransferDefaults.clear();
          paraTransferLocked = false;
          paraTransferOptionsKey = '';
          setParaTransferStatus('等待 VPS 提供转账参数…');
          updateParaTransferButtons();
          return;
        }

        const optionsKey = normalized
          .map((option) => `${option.agentId}:${JSON.stringify(option.defaults || {})}`)
          .join('|');
        const shouldRebuild =
          optionsKey !== paraTransferOptionsKey ||
          paraTransferSourceSelect.options.length !== normalized.length ||
          paraTransferTargetSelect.options.length !== normalized.length;
        paraTransferDefaults.clear();
        for (const option of normalized) {
          paraTransferDefaults.set(option.agentId, option.defaults || {});
        }
        paraTransferPanel.classList.remove('hidden');

        if (shouldRebuild) {
          paraTransferOptionsKey = optionsKey;
          const previousSource = paraTransferSourceSelect.value;
          const previousTarget = paraTransferTargetSelect.value;
          const rebuildSelect = (select, previous) => {
            select.innerHTML = '';
            for (const option of normalized) {
              const element = document.createElement('option');
              element.value = option.agentId;
              element.textContent = option.label;
              select.appendChild(element);
            }
            if (previous && normalized.some((option) => option.agentId === previous)) {
              select.value = previous;
            } else if (select.options.length) {
              select.selectedIndex = 0;
            } else {
              select.value = '';
            }
          };
          rebuildSelect(paraTransferSourceSelect, previousSource);
          rebuildSelect(paraTransferTargetSelect, previousTarget);

          if (
            normalized.length > 1 &&
            paraTransferSourceSelect.value &&
            paraTransferSourceSelect.value === paraTransferTargetSelect.value
          ) {
            const alternative = normalized.find((option) => option.agentId !== paraTransferSourceSelect.value);
            if (alternative) {
              paraTransferTargetSelect.value = alternative.agentId;
            }
          }
        }

        const sourceAgent = paraTransferSourceSelect.value;
        const targetAgent = paraTransferTargetSelect.value;
        if (sourceAgent) {
          applyParaTransferDefaults('source', { forceAll: true });
        }
        if (targetAgent) {
          applyParaTransferDefaults('target', { forceAll: true });
        }
        syncParaTransferSelectionStatus();
        updateParaTransferButtons();
      }

      function applyParaTransferDefaults(role, { forceAll = false } = {}) {
        const select = role === 'target' ? paraTransferTargetSelect : paraTransferSourceSelect;
        const agentId = select?.value;
        if (!agentId) {
          updateParaTransferButtons();
          return;
        }
        const defaults = paraTransferDefaults.get(agentId) || {};
        if (role === 'source') {
          if (paraTransferCurrencyInput && (forceAll || !paraTransferCurrencyInput.value)) {
            paraTransferCurrencyInput.value = (defaults.currency || 'USDC').toUpperCase();
          }
          if (paraTransferTypeInput && (forceAll || !paraTransferTypeInput.value)) {
            paraTransferTypeInput.value = defaults.transfer_type || 'spot';
          }
        } else if (role === 'target') {
          const targetAddr = defaults.l2_address || defaults.target_l2_address || '';
          setInputValue(paraTransferTargetAddressInput, targetAddr, { force: forceAll });
        }
        updateParaTransferButtons();
      }

      function updateParaTransferRoute({ force = false } = {}) {
        const targetId = paraTransferTargetSelect?.value;
        const targetDefaults = (targetId && paraTransferDefaults.get(targetId)) || {};
        const targetAddr = targetDefaults.l2_address || targetDefaults.target_l2_address || '';
        setInputValue(paraTransferTargetAddressInput, targetAddr, { force });
      }

      async function sendParaTransfer() {
        if (paraTransferLocked) {
          return;
        }
        const sourceAgentId = paraTransferSourceSelect?.value;
        const targetAgentId = paraTransferTargetSelect?.value;
        if (!sourceAgentId || !targetAgentId) {
          setParaTransferStatus('请先选择来源和目标 VPS');
          return;
        }
        if (sourceAgentId === targetAgentId && (paraTransferSourceSelect?.options?.length || 0) > 1) {
          setParaTransferStatus('来源与目标 VPS 必须不同');
          return;
        }
        const amountValue = parseFloat(getInputValue(paraTransferAmountInput) || '0');
        if (!Number.isFinite(amountValue) || amountValue <= 0) {
          setParaTransferStatus('请输入合法的数量');
          return;
        }
        const targetAddress = getInputValue(paraTransferTargetAddressInput);
        if (!targetAddress) {
          setParaTransferStatus('请输入目标 L2 地址');
          return;
        }
  const currencyValue = (getInputValue(paraTransferCurrencyInput) || 'USDC').toUpperCase();
        const payload = {
          agent_ids: [sourceAgentId],
          target_agent_id: targetAgentId,
          num_tokens: amountValue,
          currency: currencyValue,
          target_l2_address: targetAddress,
          transfer_type: getInputValue(paraTransferTypeInput) || undefined,
        };

        if (!payload.transfer_type) {
          delete payload.transfer_type;
        }

        const reason = getInputValue(paraTransferReasonInput);
        if (reason) {
          payload.reason = reason;
        }

        paraTransferLocked = true;
        updateParaTransferButtons();
        setParaTransferStatus('提交转账请求…');
        try {
          const response = await fetch('/para/transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          setParaTransferStatus('等待 VPS ACK…');
          await refreshMetrics();
        } catch (error) {
          paraTransferLocked = false;
          updateParaTransferButtons();
          setParaTransferStatus(`请求失败：${error}`);
        }
      }

      function renderParaTransferHistory(summary) {
        if (!paraTransferHistoryBody) {
          return;
        }
        const requests = Array.isArray(summary?.requests)
          ? summary.requests.filter((request) => (request?.action || '').toLowerCase() === 'transfer')
          : [];
        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const pendingStatuses = ['pending', 'in_progress'];
        let locked = false;
        let statusMessage = '等待指令…';
        const resolveTargetLabel = (payload) => {
          if (!payload || typeof payload !== 'object') {
            return '';
          }
          const metadata = payload.transfer_metadata && typeof payload.transfer_metadata === 'object' ? payload.transfer_metadata : {};
          return metadata.target_agent_label || metadata.target_agent_id || payload.target_agent_id || '';
        };

        const active = summary?.active_request;
        const activeIsTransfer = (active?.action || '').toLowerCase() === 'transfer' && pendingStatuses.includes(normalizeStatus(active?.overall_status));
        const pendingCandidate = activeIsTransfer ? active : requests.find((request) => pendingStatuses.includes(normalizeStatus(request.overall_status)));
        if (pendingCandidate) {
          locked = true;
          const targetAgents = Array.isArray(pendingCandidate.target_agents) ? pendingCandidate.target_agents.join(', ') : 'VPS';
          const pendingTarget = resolveTargetLabel(pendingCandidate.payload);
          const targetHint = pendingTarget ? ` → ${pendingTarget}` : '';
          statusMessage = `等待 ${(targetAgents || 'VPS')}${targetHint} ACK…`;
        } else if (requests.length) {
          const latest = requests[0];
          const latestStatus = normalizeStatus(latest.overall_status);
          const payload = latest?.payload || {};
          const directionText = describeTransferDirection(payload.direction || latest?.direction);
          if (latestStatus === 'completed' || latestStatus === 'acknowledged') {
            statusMessage = `最近一次 ${directionText} 已完成`;
          } else if (latestStatus === 'failed') {
            statusMessage = `最近一次 ${directionText} 部分失败`;
          } else if (latestStatus) {
            statusMessage = `最近状态：${latestStatus}`;
          }
        }

        paraTransferLocked = locked;
        setParaTransferStatus(statusMessage);
        updateParaTransferButtons();

        if (!requests.length) {
          paraTransferHistoryBody.innerHTML = '<tr><td colspan="6">暂无转账记录</td></tr>';
          return;
        }

        const rows = [];
        for (const request of requests.slice(0, 6)) {
          const createdText = formatTimestamp(request.created_at) ?? '--';
          const payload = request.payload || {};
          const sourceAgents = Array.isArray(request.target_agents) ? request.target_agents.join(', ') : '—';
          const targetLabel = resolveTargetLabel(payload) || '—';
          const amountValue = `${numberFormatter.format(toNumber(payload.num_tokens ?? request.magnitude ?? 0))} ${(payload.currency || 'USDT').toUpperCase()}`;
          const routeText = formatTransferRoute(payload);
          const statusText = request.overall_status || 'pending';
          const reasonText = payload?.transfer_metadata?.reason || payload.reason || '';
          const directionText = describeTransferDirection(payload.direction || payload?.transfer_metadata?.direction || request.direction);
          const noteText = reasonText ? `${statusText} / ${reasonText}` : statusText;
          rows.push(`
            <tr>
              <td>${escapeHtml(createdText)}</td>
              <td>${escapeHtml(`${sourceAgents || '—'} → ${targetLabel || '—'}`)}</td>
              <td>${escapeHtml(directionText)}</td>
              <td>${escapeHtml(amountValue)}</td>
              <td>${escapeHtml(routeText)}</td>
              <td>${escapeHtml(noteText)}</td>
            </tr>
          `);
        }

        paraTransferHistoryBody.innerHTML = rows.join('');
        if (!locked) {
          syncParaTransferSelectionStatus();
        }
      }

      function setAutoBalanceStatusMessage(message) {
        if (grvtAutoStatus) {
          grvtAutoStatus.textContent = message || '等待配置…';
        }
      }

      function setParaAutoBalanceStatusMessage(message) {
        if (paraAutoStatus) {
          paraAutoStatus.textContent = message || '等待配置…';
        }
      }

      function setBpAutoBalanceStatusMessage(message) {
        if (bpAutoStatus) {
          bpAutoStatus.textContent = message || '等待配置…';
        }
      }

      function getRiskViews() {
        return [
          {
            scope: 'global',
            panel: grvtRiskPanel,
            statusPill: riskSettingsStatus,
            message: riskSettingsMessage,
            testMessage: document.getElementById('risk-test-message'),
            enabledInput: riskAlertEnabledInput,
            staleEnabledInput: riskStaleEnabledInput,
            thresholdSlider: riskThresholdSlider,
            thresholdInput: riskThresholdInput,
            resetInput: riskResetInput,
            cooldownInput: riskCooldownInput,
            thresholdLabel: riskThresholdLabel,
            meta: riskMeta,
            barkUrlInput: riskBarkUrlInput,
            barkAppendInput: riskBarkAppendInput,
            barkTimeoutInput: riskBarkTimeoutInput,
            titleTemplateInput: riskTitleTemplateInput,
            bodyTemplateInput: riskBodyTemplateInput,
            staleCriticalInput: riskStaleCriticalInput,
            saveButton: riskSaveButton,
            disableButton: riskDisableButton,
            refreshButton: riskRefreshButton,
            testButton: riskTestButton,
          },
          {
            scope: 'para',
            panel: paraRiskPanel,
            statusPill: paraRiskSettingsStatus,
            message: paraRiskSettingsMessage,
            testMessage: paraRiskTestMessage,
            enabledInput: paraRiskAlertEnabledInput,
            thresholdSlider: paraRiskThresholdSlider,
            thresholdInput: paraRiskThresholdInput,
            resetInput: paraRiskResetInput,
            cooldownInput: paraRiskCooldownInput,
            thresholdLabel: paraRiskThresholdLabel,
            meta: paraRiskMeta,
            barkUrlInput: paraRiskBarkUrlInput,
            barkAppendInput: paraRiskBarkAppendInput,
            barkTimeoutInput: paraRiskBarkTimeoutInput,
            titleTemplateInput: paraRiskTitleTemplateInput,
            bodyTemplateInput: paraRiskBodyTemplateInput,
            saveButton: paraRiskSaveButton,
            disableButton: paraRiskDisableButton,
            refreshButton: paraRiskRefreshButton,
            testButton: paraRiskTestButton,
          },
          {
            scope: 'bp',
            panel: bpRiskPanel,
            statusPill: bpRiskSettingsStatus,
            message: bpRiskSettingsMessage,
            testMessage: bpRiskTestMessage,
            enabledInput: bpRiskAlertEnabledInput,
            thresholdSlider: bpRiskThresholdSlider,
            thresholdInput: bpRiskThresholdInput,
            resetInput: bpRiskResetInput,
            cooldownInput: bpRiskCooldownInput,
            thresholdLabel: bpRiskThresholdLabel,
            meta: bpRiskMeta,
            barkUrlInput: bpRiskBarkUrlInput,
            barkAppendInput: bpRiskBarkAppendInput,
            barkTimeoutInput: bpRiskBarkTimeoutInput,
            titleTemplateInput: bpRiskTitleTemplateInput,
            bodyTemplateInput: bpRiskBodyTemplateInput,
            saveButton: bpRiskSaveButton,
            disableButton: bpRiskDisableButton,
            refreshButton: bpRiskRefreshButton,
            testButton: bpRiskTestButton,
          },
        ].filter((view) => view.panel);
      }

      function updateAutoBalanceButtons() {
        [grvtAutoSaveButton, grvtAutoDisableButton, grvtAutoRefreshButton].forEach((button) => {
          if (button) {
            button.disabled = autoBalanceBusy;
          }
        });
      }

      function updateParaAutoBalanceButtons() {
        [paraAutoSaveButton, paraAutoDisableButton, paraAutoRefreshButton].forEach((button) => {
          if (button) {
            button.disabled = paraAutoBusy;
          }
        });
      }

      function updateBpAutoBalanceButtons() {
        [bpAutoSaveButton, bpAutoDisableButton, bpAutoRefreshButton].forEach((button) => {
          if (button) {
            button.disabled = bpAutoBusy;
          }
        });
      }

      function markAutoBalanceDirty() {
        autoBalanceDirty = true;
        if (!autoBalanceBusy) {
          setAutoBalanceStatusMessage('配置未保存');
        }
      }

      function markParaAutoBalanceDirty() {
        paraAutoDirty = true;
        if (!paraAutoBusy) {
          setParaAutoBalanceStatusMessage('配置未保存');
        }
      }

      function markBpAutoBalanceDirty() {
        bpAutoDirty = true;
        if (!bpAutoBusy) {
          setBpAutoBalanceStatusMessage('配置未保存');
        }
      }

      function markBpDualVolumeDirty() {
        bpDualVolumeDirty = true;
      }

      function renderAutoBalanceList(element, items, emptyLabel) {
        if (!element) {
          return;
        }
        if (!items || !items.length) {
          element.innerHTML = `<li>${escapeHtml(emptyLabel)}</li>`;
          return;
        }
        element.innerHTML = items.map((item) => `<li>${escapeHtml(item)}</li>`).join('');
      }

      function updateAutoBalanceAgentOptions(agentMap) {
        if (!grvtAutoAgentASelect || !grvtAutoAgentBSelect) {
          return;
        }
        const entries = agentMap && typeof agentMap === 'object'
          ? Object.entries(agentMap)
          : [];
        const options = entries
          .map(([agentId, metrics]) => {
            const instrument = metrics?.instrument ? ` · ${metrics.instrument}` : '';
            return { agentId, label: `${agentId}${instrument}` };
          })
          .sort((a, b) => a.agentId.localeCompare(b.agentId, undefined, { sensitivity: 'base' }));
        const key = options.map((option) => `${option.agentId}:${option.label}`).join('|');
        if (key === autoBalanceAgentsKey) {
          return;
        }
        autoBalanceAgentsKey = key;
        const hasOption = (select, value) => {
          if (!select || !value) {
            return false;
          }
          return Array.from(select.options || []).some((option) => option.value === value);
        };
        const rebuild = (select, previous) => {
          if (!select) {
            return;
          }
          select.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = '选择 VPS';
          select.appendChild(placeholder);
          for (const option of options) {
            const element = document.createElement('option');
            element.value = option.agentId;
            element.textContent = option.label;
            select.appendChild(element);
          }
          if (previous && options.some((option) => option.agentId === previous)) {
            select.value = previous;
          } else {
            select.value = '';
          }
        };
        rebuild(grvtAutoAgentASelect, grvtAutoAgentASelect.value);
        rebuild(grvtAutoAgentBSelect, grvtAutoAgentBSelect.value);
        if (!grvtAutoAgentASelect.value && autoBalanceLastConfig?.agent_a && hasOption(grvtAutoAgentASelect, autoBalanceLastConfig.agent_a)) {
          grvtAutoAgentASelect.value = autoBalanceLastConfig.agent_a;
        }
        if (!grvtAutoAgentBSelect.value && autoBalanceLastConfig?.agent_b && hasOption(grvtAutoAgentBSelect, autoBalanceLastConfig.agent_b)) {
          grvtAutoAgentBSelect.value = autoBalanceLastConfig.agent_b;
        }
      }

      function updateParaAutoBalanceAgentOptions(agentMap) {
        if (!paraAutoAgentASelect || !paraAutoAgentBSelect) {
          return;
        }
        const entries = agentMap && typeof agentMap === 'object'
          ? Object.entries(agentMap)
          : [];
        const options = entries
          .map(([agentId, metrics]) => {
            const instrument = metrics?.instrument ? ` · ${metrics.instrument}` : '';
            return { agentId, label: `${agentId}${instrument}` };
          })
          .sort((a, b) => a.agentId.localeCompare(b.agentId, undefined, { sensitivity: 'base' }));
        const key = options.map((option) => `${option.agentId}:${option.label}`).join('|');
        if (key === paraAutoAgentsKey) {
          return;
        }
        paraAutoAgentsKey = key;
        const hasOption = (select, value) => {
          if (!select || !value) {
            return false;
          }
          return Array.from(select.options || []).some((option) => option.value === value);
        };
        const rebuild = (select, previous) => {
          if (!select) {
            return;
          }
          select.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = '选择 VPS';
          select.appendChild(placeholder);
          for (const option of options) {
            const element = document.createElement('option');
            element.value = option.agentId;
            element.textContent = option.label;
            select.appendChild(element);
          }
          if (previous && options.some((option) => option.agentId === previous)) {
            select.value = previous;
          } else {
            select.value = '';
          }
        };
        rebuild(paraAutoAgentASelect, paraAutoAgentASelect.value);
        rebuild(paraAutoAgentBSelect, paraAutoAgentBSelect.value);
        if (!paraAutoAgentASelect.value && paraAutoLastConfig?.agent_a && hasOption(paraAutoAgentASelect, paraAutoLastConfig.agent_a)) {
          paraAutoAgentASelect.value = paraAutoLastConfig.agent_a;
        }
        if (!paraAutoAgentBSelect.value && paraAutoLastConfig?.agent_b && hasOption(paraAutoAgentBSelect, paraAutoLastConfig.agent_b)) {
          paraAutoAgentBSelect.value = paraAutoLastConfig.agent_b;
        }
      }

      function updateBpAutoBalanceAgentOptions(agentMap) {
        const hasBpAuto = !!(bpAutoAgentASelect && bpAutoAgentBSelect);
        const entries = agentMap && typeof agentMap === 'object'
          ? Object.entries(agentMap)
          : [];
        const options = entries
          .map(([agentId, metrics]) => {
            const instrument = metrics?.instrument ? ` · ${metrics.instrument}` : '';
            return { agentId, label: `${agentId}${instrument}` };
          })
          .sort((a, b) => a.agentId.localeCompare(b.agentId, undefined, { sensitivity: 'base' }));
        const key = options.map((option) => `${option.agentId}:${option.label}`).join('|');
        if (key === bpAutoAgentsKey) {
          return;
        }
        bpAutoAgentsKey = key;
        const hasOption = (select, value) => {
          if (!select || !value) {
            return false;
          }
          return Array.from(select.options || []).some((option) => option.value === value);
        };
        const rebuild = (select, previous) => {
          if (!select) {
            return;
          }
          select.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = '选择 VPS';
          select.appendChild(placeholder);
          for (const option of options) {
            const element = document.createElement('option');
            element.value = option.agentId;
            element.textContent = option.label;
            select.appendChild(element);
          }
          if (previous && options.some((option) => option.agentId === previous)) {
            select.value = previous;
          } else {
            select.value = '';
          }
        };
        if (hasBpAuto) {
          rebuild(bpAutoAgentASelect, bpAutoAgentASelect.value);
          rebuild(bpAutoAgentBSelect, bpAutoAgentBSelect.value);
          if (!bpAutoAgentASelect.value && bpAutoLastConfig?.agent_a && hasOption(bpAutoAgentASelect, bpAutoLastConfig.agent_a)) {
            bpAutoAgentASelect.value = bpAutoLastConfig.agent_a;
          }
          if (!bpAutoAgentBSelect.value && bpAutoLastConfig?.agent_b && hasOption(bpAutoAgentBSelect, bpAutoLastConfig.agent_b)) {
            bpAutoAgentBSelect.value = bpAutoLastConfig.agent_b;
          }
        }
        if (bpDualAgentASelect || bpDualAgentBSelect) {
          rebuild(bpDualAgentASelect, bpDualAgentASelect?.value);
          rebuild(bpDualAgentBSelect, bpDualAgentBSelect?.value);
          const dualCfg = bpDualVolumeLastStatus?.config;
          if (!bpDualAgentASelect?.value && dualCfg?.agent_a && hasOption(bpDualAgentASelect, dualCfg.agent_a)) {
            bpDualAgentASelect.value = dualCfg.agent_a;
          }
          if (!bpDualAgentBSelect?.value && dualCfg?.agent_b && hasOption(bpDualAgentBSelect, dualCfg.agent_b)) {
            bpDualAgentBSelect.value = dualCfg.agent_b;
          }
        }
      }

      function applyBpAutoBalanceConfig(config, { markClean = false } = {}) {
        if (!bpAutoEnabledInput) {
          return;
        }
        const enabled = Boolean(config);
        bpAutoEnabledInput.checked = enabled;
        const setValue = (element, value, fallback = '') => {
          if (!element) {
            return;
          }
          if (value === null || value === undefined || value === '') {
            element.value = fallback;
          } else {
            element.value = value;
          }
        };
        if (bpAutoAgentASelect) {
          bpAutoAgentASelect.value = config?.agent_a ?? '';
        }
        if (bpAutoAgentBSelect) {
          bpAutoAgentBSelect.value = config?.agent_b ?? '';
        }
        const thresholdPercentRaw = config?.threshold_percent;
        let thresholdPercent = Number(thresholdPercentRaw);
        if (!Number.isFinite(thresholdPercent)) {
          const ratio = Number(config?.threshold_ratio);
          thresholdPercent = Number.isFinite(ratio) ? ratio * 100 : NaN;
        }
        setValue(
          bpAutoThresholdInput,
          Number.isFinite(thresholdPercent) ? thresholdPercent.toString() : ''
        );
        setValue(bpAutoMinTransferInput, config?.min_transfer ?? '');
        setValue(bpAutoMaxTransferInput, config?.max_transfer ?? '');
        setValue(bpAutoCurrencyInput, 'USDC', 'USDC');
        setValue(
          bpAutoCooldownInput,
          config && Number.isFinite(Number(config.cooldown_seconds))
            ? String(config.cooldown_seconds)
            : ''
        );
        if (bpAutoUseAvailableInput) {
          bpAutoUseAvailableInput.checked = Boolean(config?.use_available_equity);
        }
        if (bpAutoPairLabel) {
          if (config?.agent_a && config?.agent_b) {
            bpAutoPairLabel.textContent = `${config.agent_a} ↔ ${config.agent_b}`;
          } else {
            bpAutoPairLabel.textContent = '未配置';
          }
        }
        bpAutoLastConfig = config ? { ...config } : null;
        if (markClean) {
          bpAutoDirty = false;
          bpAutoConfigKey = JSON.stringify(config || null);
        }
      }

      function buildBpAutoBalancePayload() {
        const enabled = bpAutoEnabledInput?.checked ?? false;
        if (!enabled) {
          return { enabled: false };
        }
        const agentA = bpAutoAgentASelect?.value || '';
        const agentB = bpAutoAgentBSelect?.value || '';
        if (!agentA || !agentB || agentA === agentB) {
          throw new Error('请选择两台不同的 Backpack VPS');
        }
        const thresholdText = getInputValue(bpAutoThresholdInput);
        const thresholdPercent = Number(thresholdText);
        if (!Number.isFinite(thresholdPercent) || thresholdPercent <= 0) {
          throw new Error('阈值百分比必须大于 0');
        }
        const minTransferText = getInputValue(bpAutoMinTransferInput);
        const minTransferValue = Number(minTransferText);
        if (!minTransferText || !Number.isFinite(minTransferValue) || minTransferValue <= 0) {
          throw new Error('最小划转金额必须大于 0');
        }
        const payload = {
          enabled: true,
          agent_a: agentA,
          agent_b: agentB,
          threshold_percent: thresholdPercent,
          min_transfer: minTransferText,
          currency: 'USDC',
          use_available_equity: Boolean(bpAutoUseAvailableInput?.checked),
        };
        const maxTransferText = getInputValue(bpAutoMaxTransferInput);
        if (maxTransferText) {
          const maxTransferValue = Number(maxTransferText);
          if (!Number.isFinite(maxTransferValue) || maxTransferValue <= 0) {
            throw new Error('最大划转金额需大于 0');
          }
          payload.max_transfer = maxTransferText;
        }
        const cooldownText = getInputValue(bpAutoCooldownInput);
        if (cooldownText) {
          const cooldownValue = Number(cooldownText);
          if (!Number.isFinite(cooldownValue) || cooldownValue < 0) {
            throw new Error('冷却时间需为非负数字');
          }
          payload.cooldown_seconds = cooldownValue;
        }
        return payload;
      }

      function renderBpAutoBalanceStatus(status, agentCount = 0) {
        if (!bpAutoPanel) {
          return;
        }
        if (!status) {
          setBpAutoBalanceStatusMessage('后端尚未提供自动平衡状态');
          renderAutoBalanceList(bpAutoMeasurement, [], '暂无实时测量');
          renderAutoBalanceList(bpAutoLastAction, [], '暂无执行记录');
          if (bpAutoPairLabel) {
            bpAutoPairLabel.textContent = '未配置';
          }
          return;
        }
        const summaryParts = [];
        summaryParts.push(status.enabled ? '已启用' : '未启用');
        const config = status.config || null;
        if (config?.threshold_percent !== undefined) {
          const thresholdValue = Number(config.threshold_percent);
          if (Number.isFinite(thresholdValue)) {
            summaryParts.push(`阈值 ${thresholdValue.toFixed(2)}%`);
          }
        }
        if (agentCount > 0 && agentCount < 2) {
          summaryParts.push('至少需要两台 Backpack VPS');
        }
        const cooldownUntil = Number(status.cooldown_until);
        if (status.cooldown_active && Number.isFinite(cooldownUntil)) {
          const remaining = Math.max(0, cooldownUntil - Date.now() / 1000);
          summaryParts.push(`冷却中 ${formatDuration(remaining)}`);
        }
        if (status.last_error) {
          summaryParts.push(`错误：${status.last_error}`);
        }
        setBpAutoBalanceStatusMessage(summaryParts.join(' · '));
        if (bpAutoPairLabel) {
          if (config?.agent_a && config?.agent_b) {
            bpAutoPairLabel.textContent = `${config.agent_a} ↔ ${config.agent_b}`;
          } else {
            bpAutoPairLabel.textContent = '未配置';
          }
        }
        const currency = 'USDC';
        const measurement = status.measurement || null;
        const measurementItems = [];
        if (measurement) {
          const ratioPercent = Number.isFinite(Number(measurement.ratio))
            ? `${(Number(measurement.ratio) * 100).toFixed(2)}%`
            : '—';
          const thresholdText = Number.isFinite(Number(config?.threshold_percent))
            ? `${Number(config.threshold_percent).toFixed(2)}%`
            : '—';
          measurementItems.push(`权益差值 ${formatAutoBalanceNumber(measurement.difference)} ${currency}`);
          measurementItems.push(`差值比例 ${ratioPercent} / 阈值 ${thresholdText}`);
          measurementItems.push(`计划划转 ${formatAutoBalanceNumber(measurement.transfer_amount)} ${currency}`);
          measurementItems.push(`方向 ${measurement.source_agent || '?'} → ${measurement.target_agent || '?'}`);
        }
        renderAutoBalanceList(bpAutoMeasurement, measurementItems, '暂无实时测量');
        const lastItems = [];
        if (status.last_transfer_amount && status.last_direction) {
          const from = status.last_direction.from || '?';
          const to = status.last_direction.to || '?';
          lastItems.push(`上次划转 ${status.last_transfer_amount} ${currency} · ${from} → ${to}`);
        }
        const lastActionTs = Number(status.last_action_at);
        if (Number.isFinite(lastActionTs) && lastActionTs > 0) {
          lastItems.push(`执行时间 ${formatTimestamp(lastActionTs) || '—'}`);
        }
        if (status.last_request_id) {
          lastItems.push(`请求编号 ${status.last_request_id}`);
        }
        if (!status.cooldown_active && Number.isFinite(cooldownUntil) && cooldownUntil > 0) {
          lastItems.push(`冷却截止 ${formatTimestamp(cooldownUntil) || '—'}`);
        }
        if (status.last_error) {
          lastItems.push(`最近错误 ${status.last_error}`);
        }
        renderAutoBalanceList(
          bpAutoLastAction,
          lastItems,
          status.enabled ? '尚无执行记录' : '停用状态'
        );
      }

      function renderBpAutoBalance(statusPayload, agentsMap) {
        if (!bpAutoPanel) {
          return;
        }
        updateBpAutoBalanceAgentOptions(agentsMap);
        const agentCount = agentsMap && typeof agentsMap === 'object'
          ? Object.keys(agentsMap).length
          : 0;
        renderBpAutoBalanceStatus(statusPayload, agentCount);
        if (!statusPayload || bpAutoDirty || bpAutoBusy) {
          return;
        }
        const config = statusPayload.config || null;
        const serialized = JSON.stringify(config || null);
        if (serialized !== bpAutoConfigKey) {
          applyBpAutoBalanceConfig(config, { markClean: true });
        }
      }

      async function submitBpAutoBalanceConfig() {
        if (bpAutoBusy) {
          return;
        }
        let payload;
        try {
          payload = buildBpAutoBalancePayload();
        } catch (error) {
          setBpAutoBalanceStatusMessage(error.message || String(error));
          return;
        }
        bpAutoBusy = true;
        updateBpAutoBalanceButtons();
        setBpAutoBalanceStatusMessage('提交自动平衡配置…');
        try {
          const response = await fetch('/backpack/auto_balance/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyBpAutoBalanceConfig(result.config, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.backpack_accounts
            ? Object.keys(lastMetricsSnapshot.backpack_accounts).length
            : 0;
          renderBpAutoBalanceStatus(result.status, agentCount);
          setBpAutoBalanceStatusMessage('配置已保存');
          await refreshMetrics();
        } catch (error) {
          setBpAutoBalanceStatusMessage(`保存失败：${error}`);
        } finally {
          bpAutoBusy = false;
          updateBpAutoBalanceButtons();
        }
      }

      async function disableBpAutoBalance() {
        if (bpAutoBusy) {
          return;
        }
        bpAutoBusy = true;
        updateBpAutoBalanceButtons();
        setBpAutoBalanceStatusMessage('停用自动平衡…');
        try {
          const response = await fetch('/backpack/auto_balance/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ enabled: false }),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyBpAutoBalanceConfig(null, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.backpack_accounts
            ? Object.keys(lastMetricsSnapshot.backpack_accounts).length
            : 0;
          renderBpAutoBalanceStatus(result.status, agentCount);
          setBpAutoBalanceStatusMessage('已停用');
          await refreshMetrics();
        } catch (error) {
          setBpAutoBalanceStatusMessage(`停用失败：${error}`);
        } finally {
          bpAutoBusy = false;
          updateBpAutoBalanceButtons();
        }
      }

      async function loadBpAutoBalanceConfig({ silent = false } = {}) {
        if (bpAutoBusy) {
          return;
        }
        bpAutoBusy = true;
        updateBpAutoBalanceButtons();
        if (!silent) {
          setBpAutoBalanceStatusMessage('刷新自动平衡配置…');
        }
        try {
          const response = await fetch('/backpack/auto_balance/config', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyBpAutoBalanceConfig(result.config, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.backpack_accounts
            ? Object.keys(lastMetricsSnapshot.backpack_accounts).length
            : 0;
          renderBpAutoBalanceStatus(result.status, agentCount);
          if (!silent) {
            setBpAutoBalanceStatusMessage('配置已更新');
          }
        } catch (error) {
          if (!silent) {
            setBpAutoBalanceStatusMessage(`刷新失败：${error}`);
          }
        } finally {
          bpAutoBusy = false;
          updateBpAutoBalanceButtons();
        }
      }

      function applyAutoBalanceConfig(config, { markClean = false } = {}) {
        if (!grvtAutoEnabledInput) {
          return;
        }
        const enabled = Boolean(config);
        grvtAutoEnabledInput.checked = enabled;
        const setValue = (element, value, fallback = '') => {
          if (!element) {
            return;
          }
          if (value === null || value === undefined || value === '') {
            element.value = fallback;
          } else {
            element.value = value;
          }
        };
        if (grvtAutoAgentASelect) {
          grvtAutoAgentASelect.value = config?.agent_a ?? '';
        }
        if (grvtAutoAgentBSelect) {
          grvtAutoAgentBSelect.value = config?.agent_b ?? '';
        }
        const thresholdPercentRaw = config?.threshold_percent;
        let thresholdPercent = Number(thresholdPercentRaw);
        if (!Number.isFinite(thresholdPercent)) {
          const ratio = Number(config?.threshold_ratio);
          thresholdPercent = Number.isFinite(ratio) ? ratio * 100 : NaN;
        }
        setValue(
          grvtAutoThresholdInput,
          Number.isFinite(thresholdPercent) ? thresholdPercent.toString() : ''
        );
        setValue(grvtAutoMinTransferInput, config?.min_transfer ?? '');
        setValue(grvtAutoMaxTransferInput, config?.max_transfer ?? '');
        setValue(grvtAutoCurrencyInput, config?.currency ?? 'USDT', 'USDT');
        setValue(
          grvtAutoCooldownInput,
          config && Number.isFinite(Number(config.cooldown_seconds))
            ? String(config.cooldown_seconds)
            : ''
        );
        if (grvtAutoUseAvailableInput) {
          grvtAutoUseAvailableInput.checked = Boolean(config?.use_available_equity);
        }
        if (grvtAutoPairLabel) {
          if (config?.agent_a && config?.agent_b) {
            grvtAutoPairLabel.textContent = `${config.agent_a} ↔ ${config.agent_b}`;
          } else {
            grvtAutoPairLabel.textContent = '未配置';
          }
        }
        autoBalanceLastConfig = config ? { ...config } : null;
        if (markClean) {
          autoBalanceDirty = false;
          autoBalanceConfigKey = JSON.stringify(config || null);
        }
      }

      function buildAutoBalancePayload() {
        const enabled = grvtAutoEnabledInput?.checked ?? false;
        if (!enabled) {
          return { enabled: false };
        }
        const agentA = grvtAutoAgentASelect?.value || '';
        const agentB = grvtAutoAgentBSelect?.value || '';
        if (!agentA || !agentB || agentA === agentB) {
          throw new Error('请选择两台不同的 VPS');
        }
        const thresholdText = getInputValue(grvtAutoThresholdInput);
        const thresholdPercent = Number(thresholdText);
        if (!Number.isFinite(thresholdPercent) || thresholdPercent <= 0) {
          throw new Error('阈值百分比必须大于 0');
        }
        const minTransferText = getInputValue(grvtAutoMinTransferInput);
        const minTransferValue = Number(minTransferText);
        if (!minTransferText || !Number.isFinite(minTransferValue) || minTransferValue <= 0) {
          throw new Error('最小划转金额必须大于 0');
        }
        const payload = {
          enabled: true,
          agent_a: agentA,
          agent_b: agentB,
          threshold_percent: thresholdPercent,
          min_transfer: minTransferText,
          currency: (getInputValue(grvtAutoCurrencyInput) || 'USDT').toUpperCase(),
          use_available_equity: Boolean(grvtAutoUseAvailableInput?.checked),
        };
        const maxTransferText = getInputValue(grvtAutoMaxTransferInput);
        if (maxTransferText) {
          const maxTransferValue = Number(maxTransferText);
          if (!Number.isFinite(maxTransferValue) || maxTransferValue <= 0) {
            throw new Error('最大划转金额需大于 0');
          }
          payload.max_transfer = maxTransferText;
        }
        const cooldownText = getInputValue(grvtAutoCooldownInput);
        if (cooldownText) {
          const cooldownValue = Number(cooldownText);
          if (!Number.isFinite(cooldownValue) || cooldownValue < 0) {
            throw new Error('冷却时间需为非负数字');
          }
          payload.cooldown_seconds = cooldownValue;
        }
        return payload;
      }

      function formatAutoBalanceNumber(value) {
        const numeric = parseDecimal(value);
        if (Number.isFinite(numeric)) {
          return numberFormatter.format(numeric);
        }
        if (value === null || value === undefined || value === '') {
          return '--';
        }
        return String(value);
      }

      function renderAutoBalanceStatus(status, agentCount = 0) {
        if (!grvtAutoPanel) {
          return;
        }
        if (!status) {
          setAutoBalanceStatusMessage('后端尚未提供自动平衡状态');
          renderAutoBalanceList(grvtAutoMeasurement, [], '暂无实时测量');
          renderAutoBalanceList(grvtAutoLastAction, [], '暂无执行记录');
          if (grvtAutoPairLabel) {
            grvtAutoPairLabel.textContent = '未配置';
          }
          return;
        }
        const summaryParts = [];
        summaryParts.push(status.enabled ? '已启用' : '未启用');
        const config = status.config || null;
        if (config?.threshold_percent !== undefined) {
          const thresholdValue = Number(config.threshold_percent);
          if (Number.isFinite(thresholdValue)) {
            summaryParts.push(`阈值 ${thresholdValue.toFixed(2)}%`);
          }
        }
        if (agentCount > 0 && agentCount < 2) {
          summaryParts.push('至少需要两台 VPS');
        }
        const cooldownUntil = Number(status.cooldown_until);
        if (status.cooldown_active && Number.isFinite(cooldownUntil)) {
          const remaining = Math.max(0, cooldownUntil - Date.now() / 1000);
          summaryParts.push(`冷却中 ${formatDuration(remaining)}`);
        }
        if (status.last_error) {
          summaryParts.push(`错误：${status.last_error}`);
        }
        setAutoBalanceStatusMessage(summaryParts.join(' · '));
        if (grvtAutoPairLabel) {
          if (config?.agent_a && config?.agent_b) {
            grvtAutoPairLabel.textContent = `${config.agent_a} ↔ ${config.agent_b}`;
          } else {
            grvtAutoPairLabel.textContent = '未配置';
          }
        }
        const currency = (config?.currency || 'USDT').toUpperCase();
        const measurement = status.measurement || null;
        const measurementItems = [];
        if (measurement) {
          const ratioPercent = Number.isFinite(Number(measurement.ratio))
            ? `${(Number(measurement.ratio) * 100).toFixed(2)}%`
            : '—';
          const thresholdText = Number.isFinite(Number(config?.threshold_percent))
            ? `${Number(config.threshold_percent).toFixed(2)}%`
            : '—';
          measurementItems.push(`权益差值 ${formatAutoBalanceNumber(measurement.difference)} ${currency}`);
          measurementItems.push(`差值比例 ${ratioPercent} / 阈值 ${thresholdText}`);
          measurementItems.push(`计划划转 ${formatAutoBalanceNumber(measurement.transfer_amount)} ${currency}`);
          measurementItems.push(`方向 ${measurement.source_agent || '?'} → ${measurement.target_agent || '?'}`);
        }
        renderAutoBalanceList(grvtAutoMeasurement, measurementItems, '暂无实时测量');
        const lastItems = [];
        if (status.last_transfer_amount && status.last_direction) {
          const from = status.last_direction.from || '?';
          const to = status.last_direction.to || '?';
          lastItems.push(`上次划转 ${status.last_transfer_amount} ${currency} · ${from} → ${to}`);
        }
        const lastActionTs = Number(status.last_action_at);
        if (Number.isFinite(lastActionTs) && lastActionTs > 0) {
          lastItems.push(`执行时间 ${formatTimestamp(lastActionTs) || '—'}`);
        }
        if (status.last_request_id) {
          lastItems.push(`请求编号 ${status.last_request_id}`);
        }
        if (!status.cooldown_active && Number.isFinite(cooldownUntil) && cooldownUntil > 0) {
          lastItems.push(`冷却截止 ${formatTimestamp(cooldownUntil) || '—'}`);
        }
        if (status.last_error) {
          lastItems.push(`最近错误 ${status.last_error}`);
        }
        renderAutoBalanceList(
          grvtAutoLastAction,
          lastItems,
          status.enabled ? '尚无执行记录' : '停用状态'
        );
      }

      function renderAutoBalance(statusPayload, agentsMap) {
        if (!grvtAutoPanel) {
          return;
        }
        updateAutoBalanceAgentOptions(agentsMap);
        const agentCount = agentsMap && typeof agentsMap === 'object'
          ? Object.keys(agentsMap).length
          : 0;
        renderAutoBalanceStatus(statusPayload, agentCount);
        if (!statusPayload || autoBalanceDirty || autoBalanceBusy) {
          return;
        }
        const config = statusPayload.config || null;
        const serialized = JSON.stringify(config || null);
        if (serialized !== autoBalanceConfigKey) {
          applyAutoBalanceConfig(config, { markClean: true });
        }
      }

      async function submitAutoBalanceConfig() {
        if (autoBalanceBusy) {
          return;
        }
        let payload;
        try {
          payload = buildAutoBalancePayload();
        } catch (error) {
          setAutoBalanceStatusMessage(error.message || String(error));
          return;
        }
        autoBalanceBusy = true;
        updateAutoBalanceButtons();
        setAutoBalanceStatusMessage('提交自动平衡配置…');
        try {
          const response = await fetch('/auto_balance/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyAutoBalanceConfig(result.config, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderAutoBalanceStatus(result.status, agentCount);
          setAutoBalanceStatusMessage('配置已保存');
          await refreshMetrics();
        } catch (error) {
          setAutoBalanceStatusMessage(`保存失败：${error}`);
        } finally {
          autoBalanceBusy = false;
          updateAutoBalanceButtons();
        }
      }

      async function disableAutoBalance() {
        if (autoBalanceBusy) {
          return;
        }
        autoBalanceBusy = true;
        updateAutoBalanceButtons();
        setAutoBalanceStatusMessage('停用自动平衡…');
        try {
          const response = await fetch('/auto_balance/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ enabled: false }),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyAutoBalanceConfig(null, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderAutoBalanceStatus(result.status, agentCount);
          setAutoBalanceStatusMessage('已停用');
          await refreshMetrics();
        } catch (error) {
          setAutoBalanceStatusMessage(`停用失败：${error}`);
        } finally {
          autoBalanceBusy = false;
          updateAutoBalanceButtons();
        }
      }

      async function loadAutoBalanceConfig({ silent = false } = {}) {
        if (autoBalanceBusy) {
          return;
        }
        autoBalanceBusy = true;
        updateAutoBalanceButtons();
        if (!silent) {
          setAutoBalanceStatusMessage('刷新自动平衡配置…');
        }
        try {
          const response = await fetch('/auto_balance/config', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyAutoBalanceConfig(result.config, { markClean: true });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderAutoBalanceStatus(result.status, agentCount);
          if (!silent) {
            setAutoBalanceStatusMessage('配置已更新');
          }
        } catch (error) {
          if (!silent) {
            setAutoBalanceStatusMessage(`刷新失败：${error}`);
          }
        } finally {
          autoBalanceBusy = false;
          updateAutoBalanceButtons();
        }
      }

      function applyParaAutoBalanceConfig(config, { markClean = false, enabledOverride = undefined } = {}) {
        if (!paraAutoEnabledInput) {
          return;
        }
        const enabled = enabledOverride !== undefined ? Boolean(enabledOverride) : Boolean(config);
        paraAutoEnabledInput.checked = enabled;
        const setValue = (element, value, fallback = '') => {
          if (!element) {
            return;
          }
          if (value === null || value === undefined || value === '') {
            element.value = fallback;
          } else {
            element.value = value;
          }
        };
        if (paraAutoAgentASelect) {
          paraAutoAgentASelect.value = config?.agent_a ?? '';
        }
        if (paraAutoAgentBSelect) {
          paraAutoAgentBSelect.value = config?.agent_b ?? '';
        }
        const thresholdPercentRaw = config?.threshold_percent;
        let thresholdPercent = Number(thresholdPercentRaw);
        if (!Number.isFinite(thresholdPercent)) {
          const ratio = Number(config?.threshold_ratio);
          thresholdPercent = Number.isFinite(ratio) ? ratio * 100 : NaN;
        }
        setValue(
          paraAutoThresholdInput,
          Number.isFinite(thresholdPercent) ? thresholdPercent.toString() : ''
        );
        setValue(paraAutoMinTransferInput, config?.min_transfer ?? '');
        setValue(paraAutoMaxTransferInput, config?.max_transfer ?? '');
        setValue(paraAutoCurrencyInput, config?.currency ?? 'USDC', 'USDC');
        setValue(
          paraAutoCooldownInput,
          config && Number.isFinite(Number(config.cooldown_seconds))
            ? String(config.cooldown_seconds)
            : ''
        );
        if (paraAutoUseAvailableInput) {
          paraAutoUseAvailableInput.checked = Boolean(config?.use_available_equity);
        }
        if (paraAutoPairLabel) {
          if (config?.agent_a && config?.agent_b) {
            paraAutoPairLabel.textContent = `${config.agent_a} ↔ ${config.agent_b}`;
          } else {
            paraAutoPairLabel.textContent = '未配置';
          }
        }
        paraAutoLastConfig = config ? { ...config } : null;
        if (markClean) {
          paraAutoDirty = false;
          paraAutoConfigKey = JSON.stringify(config || null);
        }
      }

      function buildParaAutoBalancePayload() {
        const enabled = paraAutoEnabledInput?.checked ?? false;
        if (!enabled) {
          return { enabled: false };
        }
        const agentA = paraAutoAgentASelect?.value || '';
        const agentB = paraAutoAgentBSelect?.value || '';
        if (!agentA || !agentB || agentA === agentB) {
          throw new Error('请选择两台不同的 PARA VPS');
        }
        const thresholdText = getInputValue(paraAutoThresholdInput);
        const thresholdPercent = Number(thresholdText);
        if (!Number.isFinite(thresholdPercent) || thresholdPercent <= 0) {
          throw new Error('阈值百分比必须大于 0');
        }
        const minTransferText = getInputValue(paraAutoMinTransferInput);
        const minTransferValue = Number(minTransferText);
        if (!minTransferText || !Number.isFinite(minTransferValue) || minTransferValue <= 0) {
          throw new Error('最小划转金额必须大于 0');
        }
        const payload = {
          enabled: true,
          agent_a: agentA,
          agent_b: agentB,
          threshold_percent: thresholdPercent,
          min_transfer: minTransferText,
          currency: (getInputValue(paraAutoCurrencyInput) || 'USDC').toUpperCase(),
          use_available_equity: Boolean(paraAutoUseAvailableInput?.checked),
        };
        const maxTransferText = getInputValue(paraAutoMaxTransferInput);
        if (maxTransferText) {
          const maxTransferValue = Number(maxTransferText);
          if (!Number.isFinite(maxTransferValue) || maxTransferValue <= 0) {
            throw new Error('最大划转金额需大于 0');
          }
          payload.max_transfer = maxTransferText;
        }
        const cooldownText = getInputValue(paraAutoCooldownInput);
        if (cooldownText) {
          const cooldownValue = Number(cooldownText);
          if (!Number.isFinite(cooldownValue) || cooldownValue < 0) {
            throw new Error('冷却时间需为非负数字');
          }
          payload.cooldown_seconds = cooldownValue;
        }
        return payload;
      }

      function renderParaAutoBalanceStatus(status, agentCount = 0) {
        if (!paraAutoPanel) {
          return;
        }
        if (!status) {
          setParaAutoBalanceStatusMessage('后端尚未提供自动平衡状态');
          renderAutoBalanceList(paraAutoMeasurement, [], '暂无实时测量');
          renderAutoBalanceList(paraAutoLastAction, [], '暂无执行记录');
          if (paraAutoPairLabel) {
            paraAutoPairLabel.textContent = '未配置';
          }
          return;
        }
        const summaryParts = [];
        summaryParts.push(status.enabled ? '已启用' : '未启用');
        const config = status.config || null;
        if (config?.threshold_percent !== undefined) {
          const thresholdValue = Number(config.threshold_percent);
          if (Number.isFinite(thresholdValue)) {
            summaryParts.push(`阈值 ${thresholdValue.toFixed(2)}%`);
          }
        }
        if (agentCount > 0 && agentCount < 2) {
          summaryParts.push('至少需要两台 PARA VPS');
        }
        const cooldownUntil = Number(status.cooldown_until);
        if (status.cooldown_active && Number.isFinite(cooldownUntil)) {
          const remaining = Math.max(0, cooldownUntil - Date.now() / 1000);
          summaryParts.push(`冷却中 ${formatDuration(remaining)}`);
        }
        if (status.last_error) {
          summaryParts.push(`错误：${status.last_error}`);
        }
        setParaAutoBalanceStatusMessage(summaryParts.join(' · '));
        if (paraAutoPairLabel) {
          if (config?.agent_a && config?.agent_b) {
            paraAutoPairLabel.textContent = `${config.agent_a} ↔ ${config.agent_b}`;
          } else {
            paraAutoPairLabel.textContent = '未配置';
          }
        }
        const currency = (config?.currency || 'USDC').toUpperCase();
        const measurement = status.measurement || null;
        const measurementItems = [];
        if (measurement) {
          const ratioPercent = Number.isFinite(Number(measurement.ratio))
            ? `${(Number(measurement.ratio) * 100).toFixed(2)}%`
            : '—';
          const thresholdText = Number.isFinite(Number(config?.threshold_percent))
            ? `${Number(config.threshold_percent).toFixed(2)}%`
            : '—';
          measurementItems.push(`权益差值 ${formatAutoBalanceNumber(measurement.difference)} ${currency}`);
          measurementItems.push(`差值比例 ${ratioPercent} / 阈值 ${thresholdText}`);
          measurementItems.push(`计划划转 ${formatAutoBalanceNumber(measurement.transfer_amount)} ${currency}`);
          measurementItems.push(`方向 ${measurement.source_agent || '?'} → ${measurement.target_agent || '?'}`);
        }
        renderAutoBalanceList(paraAutoMeasurement, measurementItems, '暂无实时测量');
        const lastItems = [];
        if (status.last_transfer_amount && status.last_direction) {
          const from = status.last_direction.from || '?';
          const to = status.last_direction.to || '?';
          lastItems.push(`上次划转 ${status.last_transfer_amount} ${currency} · ${from} → ${to}`);
        }
        const lastActionTs = Number(status.last_action_at);
        if (Number.isFinite(lastActionTs) && lastActionTs > 0) {
          lastItems.push(`执行时间 ${formatTimestamp(lastActionTs) || '—'}`);
        }
        if (status.last_request_id) {
          lastItems.push(`请求编号 ${status.last_request_id}`);
        }
        if (!status.cooldown_active && Number.isFinite(cooldownUntil) && cooldownUntil > 0) {
          lastItems.push(`冷却截止 ${formatTimestamp(cooldownUntil) || '—'}`);
        }
        if (status.last_error) {
          lastItems.push(`最近错误 ${status.last_error}`);
        }
        renderAutoBalanceList(
          paraAutoLastAction,
          lastItems,
          status.enabled ? '尚无执行记录' : '停用状态'
        );
      }

      function renderParaAutoBalance(statusPayload, agentsMap) {
        if (!paraAutoPanel) {
          return;
        }
        updateParaAutoBalanceAgentOptions(agentsMap);
        const agentCount = agentsMap && typeof agentsMap === 'object'
          ? Object.keys(agentsMap).length
          : 0;
        renderParaAutoBalanceStatus(statusPayload, agentCount);
        if (!statusPayload || paraAutoDirty || paraAutoBusy) {
          return;
        }
        const config = statusPayload.config || null;
        const serialized = JSON.stringify(config || null);
        if (serialized !== paraAutoConfigKey) {
          applyParaAutoBalanceConfig(config, { markClean: true });
        }
      }

      async function submitParaAutoBalanceConfig() {
        if (paraAutoBusy) {
          return;
        }
        let payload;
        try {
          payload = buildParaAutoBalancePayload();
        } catch (error) {
          setParaAutoBalanceStatusMessage(error.message || String(error));
          return;
        }
        paraAutoBusy = true;
        updateParaAutoBalanceButtons();
        setParaAutoBalanceStatusMessage('提交自动平衡配置…');
        try {
          const response = await fetch('/para/auto_balance/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          // Use backend-reported enabled flag to avoid UI flipping to disabled
          // when the backend intentionally returns config payload without an explicit enabled boolean.
          applyParaAutoBalanceConfig(result.config, {
            markClean: true,
            enabledOverride: result?.status?.enabled,
          });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderParaAutoBalanceStatus(result.status, agentCount);
          setParaAutoBalanceStatusMessage('配置已保存');
          await refreshMetrics();
        } catch (error) {
          setParaAutoBalanceStatusMessage(`保存失败：${error}`);
        } finally {
          paraAutoBusy = false;
          updateParaAutoBalanceButtons();
        }
      }

      async function disableParaAutoBalance() {
        if (paraAutoBusy) {
          return;
        }
        paraAutoBusy = true;
        updateParaAutoBalanceButtons();
        setParaAutoBalanceStatusMessage('停用自动平衡…');
        try {
          const response = await fetch('/para/auto_balance/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ enabled: false }),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyParaAutoBalanceConfig(null, { markClean: true, enabledOverride: false });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderParaAutoBalanceStatus(result.status, agentCount);
          setParaAutoBalanceStatusMessage('已停用');
          await refreshMetrics();
        } catch (error) {
          setParaAutoBalanceStatusMessage(`停用失败：${error}`);
        } finally {
          paraAutoBusy = false;
          updateParaAutoBalanceButtons();
        }
      }

      async function loadParaAutoBalanceConfig({ silent = false } = {}) {
        if (paraAutoBusy) {
          return;
        }
        paraAutoBusy = true;
        updateParaAutoBalanceButtons();
        if (!silent) {
          setParaAutoBalanceStatusMessage('刷新自动平衡配置…');
        }
        try {
          const response = await fetch('/para/auto_balance/config', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyParaAutoBalanceConfig(result.config, {
            markClean: true,
            enabledOverride: result?.status?.enabled,
          });
          const agentCount = lastMetricsSnapshot && lastMetricsSnapshot.agents
            ? Object.keys(lastMetricsSnapshot.agents).length
            : 0;
          renderParaAutoBalanceStatus(result.status, agentCount);
          if (!silent) {
            setParaAutoBalanceStatusMessage('配置已更新');
          }
        } catch (error) {
          if (!silent) {
            setParaAutoBalanceStatusMessage(`刷新失败：${error}`);
          }
        } finally {
          paraAutoBusy = false;
          updateParaAutoBalanceButtons();
        }
      }

      // --- GRVT Auto Balance wiring ---
      if (grvtAutoEnabledInput) grvtAutoEnabledInput.addEventListener('change', markAutoBalanceDirty);
      if (grvtAutoAgentASelect) grvtAutoAgentASelect.addEventListener('change', markAutoBalanceDirty);
      if (grvtAutoAgentBSelect) grvtAutoAgentBSelect.addEventListener('change', markAutoBalanceDirty);
      if (grvtAutoThresholdInput) grvtAutoThresholdInput.addEventListener('input', markAutoBalanceDirty);
      if (grvtAutoMinTransferInput) grvtAutoMinTransferInput.addEventListener('input', markAutoBalanceDirty);
      if (grvtAutoMaxTransferInput) grvtAutoMaxTransferInput.addEventListener('input', markAutoBalanceDirty);
      if (grvtAutoCurrencyInput) grvtAutoCurrencyInput.addEventListener('input', markAutoBalanceDirty);
      if (grvtAutoCooldownInput) grvtAutoCooldownInput.addEventListener('input', markAutoBalanceDirty);
      if (grvtAutoUseAvailableInput) grvtAutoUseAvailableInput.addEventListener('change', markAutoBalanceDirty);

      if (grvtAutoSaveButton) {
        grvtAutoSaveButton.addEventListener('click', () => {
          submitAutoBalanceConfig();
        });
      }
      if (grvtAutoDisableButton) {
        grvtAutoDisableButton.addEventListener('click', () => {
          disableAutoBalance();
        });
      }
      if (grvtAutoRefreshButton) {
        grvtAutoRefreshButton.addEventListener('click', () => {
          loadAutoBalanceConfig();
        });
      }

      // --- PARA Auto Balance wiring ---
      // Without these listeners the "保存配置" button does nothing, which matches
      // the reported behavior (no backend log line, still shows disabled).
      if (paraAutoEnabledInput) paraAutoEnabledInput.addEventListener('change', markParaAutoBalanceDirty);
      if (paraAutoAgentASelect) paraAutoAgentASelect.addEventListener('change', markParaAutoBalanceDirty);
      if (paraAutoAgentBSelect) paraAutoAgentBSelect.addEventListener('change', markParaAutoBalanceDirty);
      if (paraAutoThresholdInput) paraAutoThresholdInput.addEventListener('input', markParaAutoBalanceDirty);
      if (paraAutoMinTransferInput) paraAutoMinTransferInput.addEventListener('input', markParaAutoBalanceDirty);
      if (paraAutoMaxTransferInput) paraAutoMaxTransferInput.addEventListener('input', markParaAutoBalanceDirty);
      if (paraAutoCurrencyInput) paraAutoCurrencyInput.addEventListener('input', markParaAutoBalanceDirty);
      if (paraAutoCooldownInput) paraAutoCooldownInput.addEventListener('input', markParaAutoBalanceDirty);
      if (paraAutoUseAvailableInput) paraAutoUseAvailableInput.addEventListener('change', markParaAutoBalanceDirty);

      if (paraAutoSaveButton) {
        paraAutoSaveButton.addEventListener('click', () => {
          console.debug('[para-auto] save clicked', { origin: location.origin });
          submitParaAutoBalanceConfig();
        });
      }
      if (paraAutoDisableButton) {
        paraAutoDisableButton.addEventListener('click', () => {
          console.debug('[para-auto] disable clicked');
          disableParaAutoBalance();
        });
      }
      if (paraAutoRefreshButton) {
        paraAutoRefreshButton.addEventListener('click', () => {
          console.debug('[para-auto] refresh clicked');
          loadParaAutoBalanceConfig();
        });
      }

      // --- Backpack Auto Balance wiring ---
      if (bpAutoEnabledInput) bpAutoEnabledInput.addEventListener('change', markBpAutoBalanceDirty);
      if (bpAutoAgentASelect) bpAutoAgentASelect.addEventListener('change', markBpAutoBalanceDirty);
      if (bpAutoAgentBSelect) bpAutoAgentBSelect.addEventListener('change', markBpAutoBalanceDirty);
      if (bpAutoThresholdInput) bpAutoThresholdInput.addEventListener('input', markBpAutoBalanceDirty);
      if (bpAutoMinTransferInput) bpAutoMinTransferInput.addEventListener('input', markBpAutoBalanceDirty);
      if (bpAutoMaxTransferInput) bpAutoMaxTransferInput.addEventListener('input', markBpAutoBalanceDirty);
      if (bpAutoCooldownInput) bpAutoCooldownInput.addEventListener('input', markBpAutoBalanceDirty);
      if (bpAutoUseAvailableInput) bpAutoUseAvailableInput.addEventListener('change', markBpAutoBalanceDirty);

      if (bpAutoSaveButton) {
        bpAutoSaveButton.addEventListener('click', () => {
          submitBpAutoBalanceConfig();
        });
      }
      if (bpAutoDisableButton) {
        bpAutoDisableButton.addEventListener('click', () => {
          disableBpAutoBalance();
        });
      }
      if (bpAutoRefreshButton) {
        bpAutoRefreshButton.addEventListener('click', () => {
          loadBpAutoBalanceConfig();
        });
      }

      function getRiskThresholdSummary(snapshotOverride = null) {
        const snapshot = snapshotOverride || riskSettingsSnapshot;
        if (!snapshot) {
          return GLOBAL_RISK_THRESHOLD_TEXT;
        }
        const parts = [];
        const thresholdPercent = Number.isFinite(snapshot.threshold_percent)
          ? Number(snapshot.threshold_percent)
          : Number(snapshot.threshold) * 100;
        if (Number.isFinite(thresholdPercent) && thresholdPercent > 0) {
          parts.push(`阈值 ${thresholdPercent.toFixed(1)}%`);
        }
        const resetPercent = Number.isFinite(snapshot.reset_ratio_percent)
          ? Number(snapshot.reset_ratio_percent)
          : Number(snapshot.reset_ratio) * 100;
        if (Number.isFinite(resetPercent) && resetPercent > 0) {
          parts.push(`重置 ${resetPercent.toFixed(1)}%`);
        }
        const cooldownSeconds = Number.isFinite(snapshot.cooldown)
          ? Number(snapshot.cooldown)
          : Number(snapshot.cooldown_minutes) * 60;
        if (Number.isFinite(cooldownSeconds) && cooldownSeconds > 0) {
          if (cooldownSeconds >= 60) {
            const minutes = cooldownSeconds / 60;
            parts.push(`冷却 ${minutes >= 10 ? minutes.toFixed(0) : minutes.toFixed(1)}m`);
          } else {
            parts.push(`冷却 ${cooldownSeconds.toFixed(0)}s`);
          }
        }
        return parts.length ? parts.join(' / ') : GLOBAL_RISK_THRESHOLD_TEXT;
      }

      function updateRiskThresholdLabel(value) {
        getRiskViews().forEach((view) => {
          if (!view.thresholdLabel) {
            return;
          }
          if (Number.isFinite(value)) {
            view.thresholdLabel.textContent = `阈值 ${value.toFixed(1)}%`;
          } else {
            view.thresholdLabel.textContent = '阈值 --%';
          }
        });
      }

  function updateRiskMeta() {
        const parts = [];
        // Global 面板显示 global/latest 的 risk ratio；PARA 面板严格显示 paraLatestRiskRatio
        const views = getRiskViews();
        for (const view of views) {
          const viewParts = [];
          const isPara = view.scope === 'para';
          const isBp = view.scope === 'bp';
          const ratio = isPara ? paraLatestRiskRatio : (isBp ? bpLatestRiskRatio : latestGlobalRiskRatio);
          if (Number.isFinite(ratio)) {
            viewParts.push(`当前风险 ${(ratio * 100).toFixed(2)}%`);
          }
          const snapshot = isPara ? paraRiskSettingsSnapshot : (isBp ? bpRiskSettingsSnapshot : globalRiskSettingsSnapshot);
          const thresholdSummary = getRiskThresholdSummary(snapshot);
          if (thresholdSummary) {
            viewParts.push(thresholdSummary);
          }
          const lastAlertTs = Number(snapshot?.last_alert_at);
          if (Number.isFinite(lastAlertTs) && lastAlertTs > 0) {
            viewParts.push(`上次推送 ${formatTimestamp(lastAlertTs) || '—'}`);
          }
          const cooldownRemaining = Number(snapshot?.cooldown_remaining);
          if (Number.isFinite(cooldownRemaining) && cooldownRemaining > 0.5) {
            viewParts.push(`冷却剩余 ${formatDuration(cooldownRemaining)}`);
          }
          const text = viewParts.length ? viewParts.join(' · ') : '等待风险数据…';
          if (view.meta) {
            view.meta.textContent = text;
          }
        }
        return;
        const thresholdSummary = getRiskThresholdSummary();
        if (thresholdSummary) {
          parts.push(thresholdSummary);
        }
        const lastAlertTs = Number(riskSettingsSnapshot?.last_alert_at);
        if (Number.isFinite(lastAlertTs) && lastAlertTs > 0) {
          parts.push(`上次推送 ${formatTimestamp(lastAlertTs) || '—'}`);
        }
        const cooldownRemaining = Number(riskSettingsSnapshot?.cooldown_remaining);
        if (Number.isFinite(cooldownRemaining) && cooldownRemaining > 0.5) {
          parts.push(`冷却剩余 ${formatDuration(cooldownRemaining)}`);
        }
        const text = parts.length ? parts.join(' · ') : '等待风险数据…';
        getRiskViews().forEach((view) => {
          if (view.meta) {
            view.meta.textContent = text;
          }
        });
      }

      function setRiskStatusMessage(message, { scope = 'all' } = {}) {
        const views = getRiskViews().filter((view) => {
          if (scope === 'all') {
            return true;
          }
          if (scope === 'para') {
            return view.scope === 'para';
          }
          if (scope === 'bp') {
            return view.scope === 'bp';
          }
          return view.scope === 'global';
        });
        views.forEach((view) => {
          if (view.message) {
            view.message.textContent = message || '未加载';
          }
        });
      }

      function setRiskTestMessage(message) {
        getRiskViews().forEach((view) => {
          if (view.testMessage) {
            view.testMessage.textContent = message || '';
          }
        });
      }

      function describeRiskAlertSource(entry) {
        if (!entry) {
          return '—';
        }
        const source = String(entry.source || 'auto').toLowerCase();
        let label = source === 'test' ? '测试' : '自动';
        if (entry.status === 'error') {
          label += ' · 失败';
        }
        const kind = String(entry.kind || '').toLowerCase();
        if (kind === 'para_stale') {
          label += ' · 数据不新鲜';
        } else if (kind === 'grvt_stale') {
          label += ' · 数据不新鲜';
        }
        return label;
      }

      function renderRiskHistory(entries) {
        if (!riskHistoryBody || !riskHistoryEmpty) {
          return;
        }
        riskHistoryBody.innerHTML = '';
        if (!Array.isArray(entries) || !entries.length) {
          riskHistoryEmpty.classList.remove('hidden');
          return;
        }
        riskHistoryEmpty.classList.add('hidden');
        const fragment = document.createDocumentFragment();
        for (const entry of entries) {
          const row = document.createElement('tr');
          const timeText = formatTimestamp(entry.timestamp) || '—';
          const sourceText = describeRiskAlertSource(entry);
          const accountLabel = entry.account_label || 'Global';
          const agentLabel = entry.agent_id ? ` (${entry.agent_id})` : '';
          const ratioPercent = Number.isFinite(entry?.ratio_percent)
            ? entry.ratio_percent
            : Number.isFinite(entry?.ratio)
              ? entry.ratio * 100
              : null;
          const ratioText = Number.isFinite(ratioPercent) ? formatPercent(ratioPercent, 1) : '—';
          const baseLabel = entry.base_label ? ` ${entry.base_label}` : '';
          const lossText = `${entry.loss_value || '--'} / ${entry.base_value || '--'}${baseLabel}`;
          row.innerHTML = `
            <td>${escapeHtml(timeText)}</td>
            <td>${escapeHtml(sourceText)}</td>
            <td>${escapeHtml(accountLabel + agentLabel)}</td>
            <td>${escapeHtml(ratioText)}</td>
            <td>${escapeHtml(lossText)}</td>
          `;
          fragment.appendChild(row);
        }
        riskHistoryBody.appendChild(fragment);
      }

          function renderParaRiskHistory(entries) {
            if (!paraRiskHistoryBody || !paraRiskHistoryEmpty) {
              return;
            }
            paraRiskHistoryBody.innerHTML = '';
            const filtered = Array.isArray(entries)
              ? entries.filter((entry) => {
                  const kind = String(entry?.kind || '').toLowerCase();
                  return kind === 'para_risk' || kind === 'para_stale';
                })
              : [];
            if (!filtered.length) {
              paraRiskHistoryEmpty.classList.remove('hidden');
              if (paraRiskHistoryStatus) {
                paraRiskHistoryStatus.textContent = '暂无告警';
              }
              return;
            }
            paraRiskHistoryEmpty.classList.add('hidden');
            const fragment = document.createDocumentFragment();
            for (const entry of filtered) {
              const row = document.createElement('tr');
              const timeText = formatTimestamp(entry.timestamp) || '—';
              const sourceText = describeRiskAlertSource(entry);
              const accountLabel = entry.account_label || '—';
              const agentLabel = entry.agent_id ? ` (${entry.agent_id})` : '';
              const hasAuthority = Boolean(
                entry?.authority_used ||
                  entry?.authority_base_value ||
                  Number.isFinite(Number(entry?.authority_base_value_raw))
              );

              const ratioPercent = hasAuthority
                ? Number.isFinite(entry?.authority_ratio_percent)
                  ? entry.authority_ratio_percent
                  : Number.isFinite(entry?.authority_ratio)
                    ? entry.authority_ratio * 100
                    : null
                : Number.isFinite(entry?.ratio_percent)
                  ? entry.ratio_percent
                  : Number.isFinite(entry?.ratio)
                    ? entry.ratio * 100
                    : null;
              const ratioText = Number.isFinite(ratioPercent) ? formatPercent(ratioPercent, 1) : '—';

              const baseLabel = hasAuthority
                ? entry.authority_base_label
                  ? ` ${entry.authority_base_label}`
                  : ' risk_capacity(frontend_authority)'
                : entry.base_label
                  ? ` ${entry.base_label}`
                  : ' 裕量';

              const lossValue = hasAuthority
                ? entry.authority_loss_value || entry.authority_loss_value_raw
                : entry.loss_value || entry.loss_value_raw;
              const baseValue = hasAuthority
                ? entry.authority_base_value || entry.authority_base_value_raw
                : entry.base_value || entry.base_value_raw;
              const lossText = `${lossValue || '--'} / ${baseValue || '--'}${baseLabel}`;

              const rawBaseValue = entry?.raw_base_value;
              const rawBaseLabel = entry?.raw_base_label;
              const rawSuffix = rawBaseValue
                ? `\nraw: ${rawBaseValue}${rawBaseLabel ? ` (${rawBaseLabel})` : ''}`
                : '';

              const authorityRawBaseValue = entry?.authority_raw_base_value;
              const authorityRawSuffix = authorityRawBaseValue ? `\nauthority_raw: ${authorityRawBaseValue}` : '';

              const computedAt = entry?.para_risk_computed_at;
              const equitySum = entry?.para_equity_sum;
              const maxIm = entry?.para_max_initial_margin;
              const accountCount = entry?.para_account_count;
              const inputParts = [];
              if (Number.isFinite(Number(computedAt)) && Number(computedAt) > 0) {
                inputParts.push(`ts: ${formatTimestamp(Number(computedAt)) || Number(computedAt)}`);
              }
              if (equitySum) {
                inputParts.push(`equity_sum: ${equitySum}`);
              }
              if (maxIm) {
                inputParts.push(`maxIM: ${maxIm}`);
              }
              if (Number.isFinite(Number(accountCount)) && Number(accountCount) >= 0) {
                inputParts.push(`accounts: ${Number(accountCount)}`);
              }

              if (hasAuthority) {
                if (entry?.authority_latest_update) {
                  inputParts.push(`authority_latest_update: ${formatTimestamp(entry.authority_latest_update) || entry.authority_latest_update}`);
                }
                if (entry?.authority_equity_sum) {
                  inputParts.push(`authority_equity_sum: ${entry.authority_equity_sum}`);
                }
                if (entry?.authority_max_initial_margin) {
                  inputParts.push(`authority_maxIM: ${entry.authority_max_initial_margin}`);
                }
                if (Number.isFinite(Number(entry?.authority_account_count)) && Number(entry.authority_account_count) >= 0) {
                  inputParts.push(`authority_accounts: ${Number(entry.authority_account_count)}`);
                }
                if (entry?.authority_im_source) {
                  inputParts.push(`authority_im_source: ${entry.authority_im_source}`);
                }
                if (entry?.authority_buffer_status || entry?.authority_buffer_note) {
                  inputParts.push(`authority_buffer: ${entry.authority_buffer_status || entry.authority_buffer_note}`);
                }
              }
              const inputsSuffix = inputParts.length ? `\ninputs: ${inputParts.join(' | ')}` : '';
              const combinedLossText = rawSuffix ? `${lossText}${rawSuffix}` : lossText;
              const withAuthorityRaw = authorityRawSuffix ? `${combinedLossText}${authorityRawSuffix}` : combinedLossText;
              const combinedLossTextWithInputs = inputsSuffix ? `${withAuthorityRaw}${inputsSuffix}` : withAuthorityRaw;
              row.innerHTML = `
                <td>${escapeHtml(timeText)}</td>
                <td>${escapeHtml(sourceText)}</td>
                <td>${escapeHtml(accountLabel + agentLabel)}</td>
                <td>${escapeHtml(ratioText)}</td>
                <td style="white-space: pre-line;">${escapeHtml(combinedLossTextWithInputs)}</td>
              `;
              fragment.appendChild(row);
            }
            paraRiskHistoryBody.appendChild(fragment);
            if (paraRiskHistoryStatus) {
              paraRiskHistoryStatus.textContent = `已加载 ${filtered.length} 条告警（PARA）`;
            }
          }

          function renderBpRiskHistory(entries) {
            if (!bpRiskHistoryBody || !bpRiskHistoryEmpty) {
              return;
            }
            const filtered = Array.isArray(entries)
              ? entries.filter((entry) => String(entry?.kind || '').toLowerCase() === 'bp_risk')
              : [];

            bpRiskHistoryBody.innerHTML = '';
            if (!filtered.length) {
              bpRiskHistoryEmpty.classList.remove('hidden');
              if (bpRiskHistoryStatus) {
                bpRiskHistoryStatus.textContent = '暂无告警';
              }
              return;
            }
            bpRiskHistoryEmpty.classList.add('hidden');

            const fragment = document.createDocumentFragment();
            for (const entry of filtered) {
              const row = document.createElement('tr');
              const timeText = entry?.timestamp ? formatTimestamp(entry.timestamp) : '--';
              const sourceText = String(entry?.source || '--');
              const accountLabel = String(entry?.account_label || '--');
              const agentId = String(entry?.agent_id || '');
              const agentLabel = agentId ? ` (${agentId})` : '';
              const ratioText = Number.isFinite(Number(entry?.ratio_percent))
                ? `${Number(entry.ratio_percent).toFixed(1)}%`
                : (Number.isFinite(Number(entry?.ratio)) ? `${(Number(entry.ratio) * 100).toFixed(1)}%` : '--%');
              const baseLabel = String(entry?.base_label || '--');
              const baseText = String(entry?.base_value || '--');
              const lossText = `${String(entry?.loss_value || '--')} / ${baseLabel} ${baseText}`;
              row.innerHTML = `
                <td>${escapeHtml(timeText)}</td>
                <td>${escapeHtml(sourceText)}</td>
                <td>${escapeHtml(accountLabel + agentLabel)}</td>
                <td>${escapeHtml(ratioText)}</td>
                <td style="white-space: pre-line;">${escapeHtml(lossText)}</td>
              `;
              fragment.appendChild(row);
            }
            bpRiskHistoryBody.appendChild(fragment);
            if (bpRiskHistoryStatus) {
              bpRiskHistoryStatus.textContent = `已加载 ${filtered.length} 条告警（Backpack）`;
            }
          }

      async function loadRiskHistory({ silent = false } = {}) {
        if (riskHistoryBusy) {
          return;
        }
        const now = performance.now();
        if (silent && now - lastRiskHistoryFetch < RISK_HISTORY_REFRESH_INTERVAL) {
          return;
        }
        riskHistoryBusy = true;
        if (!silent && riskHistoryStatus) {
          riskHistoryStatus.textContent = '读取告警历史…';
        }
        try {
          const response = await fetch('/risk_alert/history', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          riskHistoryEntries = Array.isArray(result?.history) ? result.history : [];
          renderRiskHistory(riskHistoryEntries);
          paraRiskHistoryEntries = riskHistoryEntries;
          renderParaRiskHistory(paraRiskHistoryEntries);
          bpRiskHistoryEntries = riskHistoryEntries;
          renderBpRiskHistory(bpRiskHistoryEntries);
          lastRiskHistoryFetch = performance.now();
          if (riskHistoryStatus) {
            riskHistoryStatus.textContent = `已加载 ${riskHistoryEntries.length} 条告警`;
          }
          if (paraRiskHistoryStatus) {
            const paraCount = Array.isArray(paraRiskHistoryEntries)
              ? paraRiskHistoryEntries.filter((entry) => {
                  const kind = String(entry?.kind || '').toLowerCase();
                  return kind === 'para_risk' || kind === 'para_stale';
                }).length
              : 0;
            paraRiskHistoryStatus.textContent = paraCount
              ? `已加载 ${paraCount} 条告警（PARA）`
              : '暂无告警';
          }
          if (bpRiskHistoryStatus) {
            const bpCount = Array.isArray(bpRiskHistoryEntries)
              ? bpRiskHistoryEntries.filter((entry) => String(entry?.kind || '').toLowerCase() === 'bp_risk').length
              : 0;
            bpRiskHistoryStatus.textContent = bpCount
              ? `已加载 ${bpCount} 条告警（Backpack）`
              : '暂无告警';
          }
        } catch (error) {
          if (riskHistoryStatus) {
            riskHistoryStatus.textContent = `读取失败：${error}`;
          }
          if (paraRiskHistoryStatus) {
            paraRiskHistoryStatus.textContent = `读取失败：${error}`;
          }
          if (bpRiskHistoryStatus) {
            bpRiskHistoryStatus.textContent = `读取失败：${error}`;
          }
        } finally {
          riskHistoryBusy = false;
        }
      }

      function maybeRefreshRiskHistory() {
        loadRiskHistory({ silent: true });
      }

      function updateRiskInputsState() {
        getRiskViews().forEach((view) => {
          const viewBusy = view.scope === 'para'
            ? paraRiskSettingsBusy
            : (view.scope === 'bp' ? bpRiskSettingsBusy : riskSettingsBusy);
          const enabled = Boolean(view.enabledInput?.checked);
          const disableThreshold = viewBusy || !enabled;
          [view.thresholdSlider, view.thresholdInput, view.resetInput, view.cooldownInput].forEach((input) => {
            if (input) {
              input.disabled = disableThreshold && input !== view.enabledInput;
            }
          });
          [view.barkUrlInput, view.barkTimeoutInput, view.titleTemplateInput, view.bodyTemplateInput, view.barkAppendInput].forEach((input) => {
            if (input) {
              input.disabled = viewBusy;
            }
          });
          if (view.staleEnabledInput) {
            view.staleEnabledInput.disabled = viewBusy;
          }
          if (view.staleCriticalInput) {
            const staleEnabled = Boolean(view.staleEnabledInput?.checked);
            view.staleCriticalInput.disabled = viewBusy || !staleEnabled;
          }
        });
      }

      function updateRiskButtons() {
        getRiskViews().forEach((view) => {
          const disabled = view.scope === 'para'
            ? paraRiskSettingsBusy
            : (view.scope === 'bp' ? bpRiskSettingsBusy : riskSettingsBusy);
          [view.saveButton, view.refreshButton].forEach((button) => {
            if (button) {
              button.disabled = disabled;
            }
          });
          if (view.disableButton) {
            const enabled = Boolean(view.enabledInput?.checked);
            view.disableButton.disabled = disabled || !enabled;
          }
          if (view.testButton) {
            const viewBarkUrl = view.barkUrlInput ? getInputValue(view.barkUrlInput) : '';
            const hasDestination = Boolean(String(viewBarkUrl || '').trim());
            view.testButton.disabled = disabled || riskTestBusy || !hasDestination;
            view.testButton.textContent = riskTestBusy ? '测试中…' : '测试 Bark';
          }
        });
        updateRiskInputsState();
      }

      function markRiskSettingsDirty() {
        if (riskSettingsBusy) {
          return;
        }
        riskSettingsDirty = true;
        setRiskStatusMessage('配置未保存', { scope: 'global' });
      }

      function markParaRiskSettingsDirty() {
        if (paraRiskSettingsBusy) {
          return;
        }
        paraRiskSettingsDirty = true;
        setRiskStatusMessage('配置未保存', { scope: 'para' });
      }

      function markBpRiskSettingsDirty() {
        if (bpRiskSettingsBusy) {
          return;
        }
        bpRiskSettingsDirty = true;
        setRiskStatusMessage('配置未保存', { scope: 'bp' });
      }

      let globalRiskSettingsSnapshot = null;
      let paraRiskSettingsSnapshot = null;
  let bpRiskSettingsSnapshot = null;

  let bpRiskSettingsBusy = false;
  let bpRiskSettingsDirty = false;

      function normalizeRiskSettingsSnapshot(settings) {
        const snapshot = settings ? { ...settings } : null;
        if (snapshot) {
          if (!Number.isFinite(snapshot.threshold_percent) && Number.isFinite(snapshot.threshold)) {
            snapshot.threshold_percent = Number(snapshot.threshold) * 100;
          }
          if (!Number.isFinite(snapshot.cooldown) && Number.isFinite(snapshot.cooldown_minutes)) {
            snapshot.cooldown = Number(snapshot.cooldown_minutes) * 60;
          }
        }
        return snapshot;
      }

      function applyRiskSettings(settings, { markClean = false, scope = 'global' } = {}) {
        const normalized = normalizeRiskSettingsSnapshot(settings);
        if (scope === 'para') {
          paraRiskSettingsSnapshot = normalized;
        } else if (scope === 'bp') {
          bpRiskSettingsSnapshot = normalized;
        } else {
          globalRiskSettingsSnapshot = normalized;
        }

        const activeSnapshot = scope === 'para'
          ? paraRiskSettingsSnapshot
          : (scope === 'bp' ? bpRiskSettingsSnapshot : globalRiskSettingsSnapshot);

        const views = scope === 'para'
          ? getRiskViews().filter((view) => view.scope === 'para')
          : (scope === 'bp' ? getRiskViews().filter((view) => view.scope === 'bp') : getRiskViews().filter((view) => view.scope !== 'para' && view.scope !== 'bp'));

        const hasThreshold = Number.isFinite(activeSnapshot?.threshold_percent)
          ? Number(activeSnapshot.threshold_percent) > 0
          : Number(activeSnapshot?.threshold) > 0;
        const enabled = Boolean(activeSnapshot?.enabled && hasThreshold);
        const thresholdPercent = Number(activeSnapshot?.threshold_percent ?? (activeSnapshot?.threshold ?? 0) * 100);
        const resetPercent = Number(activeSnapshot?.reset_ratio_percent ?? (activeSnapshot?.reset_ratio ?? 0) * 100);
        const cooldownMinutes = Number.isFinite(activeSnapshot?.cooldown_minutes)
          ? Number(activeSnapshot.cooldown_minutes)
          : (Number.isFinite(activeSnapshot?.cooldown) ? Number(activeSnapshot.cooldown) / 60 : 0);
        const staleCriticalSeconds = Number(activeSnapshot?.stale_critical_seconds ?? 0);
        const staleEnabled = Number.isFinite(staleCriticalSeconds) && staleCriticalSeconds > 0;

        views.forEach((view) => {
          if (view.enabledInput) {
            view.enabledInput.checked = enabled;
          }
          if (view.thresholdSlider) {
            const sliderValue = Number.isFinite(thresholdPercent) ? clamp(thresholdPercent, 5, 90) : 30;
            view.thresholdSlider.value = sliderValue;
          }
          if (view.thresholdInput) {
            view.thresholdInput.value = Number.isFinite(thresholdPercent) ? thresholdPercent.toFixed(1) : '';
          }
          if (view.resetInput) {
            view.resetInput.value = Number.isFinite(resetPercent) ? resetPercent.toFixed(1) : '';
          }
          if (view.cooldownInput) {
            view.cooldownInput.value = Number.isFinite(cooldownMinutes) ? Math.max(0, cooldownMinutes).toFixed(1) : '';
          }
          if (view.staleEnabledInput) {
            view.staleEnabledInput.checked = staleEnabled;
          }
          if (view.staleCriticalInput) {
            view.staleCriticalInput.value = staleEnabled ? String(Math.max(1, Math.round(staleCriticalSeconds))) : '';
          }
          if (view.barkUrlInput) {
            view.barkUrlInput.value = activeSnapshot?.bark_url ?? '';
          }
          if (view.barkAppendInput) {
            view.barkAppendInput.checked = Boolean(activeSnapshot?.bark_append_payload ?? true);
          }
          if (view.barkTimeoutInput) {
            view.barkTimeoutInput.value = activeSnapshot?.bark_timeout ?? '';
          }
          if (view.titleTemplateInput) {
            view.titleTemplateInput.value = activeSnapshot?.title_template ?? '';
          }
          if (view.bodyTemplateInput) {
            view.bodyTemplateInput.value = activeSnapshot?.body_template ?? '';
          }
          if (view.statusPill) {
            view.statusPill.textContent = enabled ? `已启用 · ${getRiskThresholdSummary(activeSnapshot)}` : '未启用';
          }
        });
        updateRiskThresholdLabel(thresholdPercent);
        if (markClean) {
          if (scope === 'para') {
            paraRiskSettingsDirty = false;
          } else if (scope === 'bp') {
            bpRiskSettingsDirty = false;
          } else {
            riskSettingsDirty = false;
          }
          setRiskStatusMessage('配置已同步', { scope });
        }
        updateRiskButtons();
        updateRiskMeta();
      }

      async function loadBpRiskSettings({ silent = false } = {}) {
        if (!bpRiskPanel || bpRiskSettingsBusy) {
          return;
        }
        bpRiskSettingsBusy = true;
        updateRiskButtons();
        if (!silent) {
          setRiskStatusMessage('读取 Backpack 风险配置…', { scope: 'bp' });
        }
        try {
          const response = await fetch('/bp/risk_alert/settings', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyRiskSettings(result.settings, { markClean: true, scope: 'bp' });
        } catch (error) {
          setRiskStatusMessage(`读取失败：${error}`, { scope: 'bp' });
        } finally {
          bpRiskSettingsBusy = false;
          updateRiskButtons();
        }
      }

      async function saveBpRiskSettings({ enabledOverride } = {}) {
        if (!bpRiskPanel || bpRiskSettingsBusy) {
          return;
        }
        let payload;
        try {
          payload = buildRiskSettingsPayload({ enabledOverride, scope: 'bp' });
        } catch (error) {
          setRiskStatusMessage(error.message || String(error), { scope: 'bp' });
          return;
        }
        bpRiskSettingsBusy = true;
        updateRiskButtons();
        setRiskStatusMessage('保存 Backpack 风险配置…', { scope: 'bp' });
        try {
          const response = await fetch('/bp/risk_alert/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyRiskSettings(result.settings, { markClean: true, scope: 'bp' });
          setRiskStatusMessage('Backpack 配置已保存', { scope: 'bp' });
          await refreshMetrics();
        } catch (error) {
          setRiskStatusMessage(`保存失败：${error}`, { scope: 'bp' });
        } finally {
          bpRiskSettingsBusy = false;
          updateRiskButtons();
        }
      }

      async function disableBpRiskAlerts() {
        await saveBpRiskSettings({ enabledOverride: false });
      }

      function buildRiskSettingsPayload({ enabledOverride, scope = 'global' } = {}) {
        const payload = {};
        const views = scope === 'para'
          ? getRiskViews().filter((view) => view.scope === 'para')
          : (scope === 'bp'
            ? getRiskViews().filter((view) => view.scope === 'bp')
            : getRiskViews().filter((view) => view.scope !== 'para' && view.scope !== 'bp'));

        const pickValue = (...inputs) => {
          for (const input of inputs) {
            const value = getInputValue(input);
            if (value !== '' && value !== undefined && value !== null) {
              return value;
            }
          }
          return '';
        };

        const pickNumber = (...inputs) => {
          let candidate = null;
          for (const input of inputs) {
            if (!input) {
              continue;
            }
            const raw = getInputValue(input);
            if (raw === '') {
              continue;
            }
            const parsed = parseDecimal(raw);
            if (Number.isFinite(parsed)) {
              candidate = parsed;
              continue;
            }
            if (input.value !== undefined && input.value !== null && String(input.value).trim() !== '') {
              const numeric = Number(input.value);
              if (Number.isFinite(numeric)) {
                candidate = numeric;
              }
            }
          }
          return candidate;
        };

        const enabledFromInputs = views.some((view) => Boolean(view.enabledInput?.checked));
        const enabled = enabledOverride !== undefined ? enabledOverride : enabledFromInputs;
        payload.enabled = enabled;

        const thresholdPercent = pickNumber(
          ...views.map((v) => v.thresholdInput),
          ...views.map((v) => v.thresholdSlider),
        );
        if (enabled) {
          if (!Number.isFinite(thresholdPercent) || thresholdPercent <= 0) {
            throw new Error('请设置大于 0 的触发阈值');
          }
          payload.threshold_percent = thresholdPercent;
          const resetPercent = pickNumber(...views.map((v) => v.resetInput));
          if (Number.isFinite(resetPercent) && resetPercent > 0) {
            payload.reset_ratio_percent = resetPercent;
          }
        }

  const cooldownMinutes = pickNumber(...views.map((v) => v.cooldownInput));
        if (Number.isFinite(cooldownMinutes) && cooldownMinutes >= 0) {
          payload.cooldown_minutes = cooldownMinutes;
        }

  const barkUrl = pickValue(...views.map((v) => v.barkUrlInput));
        if (barkUrl) {
          payload.bark_url = barkUrl;
        }

        const pickCheckbox = (...inputs) => {
          let candidate = null;
          for (const input of inputs) {
            if (!input) continue;
            candidate = Boolean(input.checked);
          }
          return candidate;
        };

  const barkAppendValue = pickCheckbox(...views.map((v) => v.barkAppendInput));
        if (barkAppendValue !== null) {
          payload.bark_append_payload = barkAppendValue;
        }

  const barkTimeout = pickNumber(...views.map((v) => v.barkTimeoutInput));
        if (Number.isFinite(barkTimeout) && barkTimeout > 0) {
          payload.bark_timeout = barkTimeout;
        }

  const titleTemplate = pickValue(...views.map((v) => v.titleTemplateInput));
        if (titleTemplate) {
          payload.title_template = titleTemplate;
        }

  const bodyTemplate = pickValue(...views.map((v) => v.bodyTemplateInput));
        if (bodyTemplate) {
          payload.body_template = bodyTemplate;
        }

  const staleEnabledValue = pickCheckbox(...views.map((v) => v.staleEnabledInput));
  const staleCriticalValue = pickNumber(...views.map((v) => v.staleCriticalInput));
        if (staleEnabledValue !== null) {
          payload.stale_enabled = staleEnabledValue;
        }
        if (Number.isFinite(staleCriticalValue)) {
          payload.stale_critical_seconds = staleCriticalValue;
        } else if (staleEnabledValue === false) {
          payload.stale_critical_seconds = 0;
        }

        return payload;
      }

      async function loadRiskSettings({ silent = false } = {}) {
        if (!getRiskViews().length || riskSettingsBusy) {
          return;
        }
        riskSettingsBusy = true;
        updateRiskButtons();
        if (!silent) {
          setRiskStatusMessage('读取风险配置…', { scope: 'global' });
        }
        try {
          const response = await fetch('/risk_alert/settings', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyRiskSettings(result.settings, { markClean: true, scope: 'global' });
          // applyRiskSettings(markClean) 会更新状态消息
        } catch (error) {
          setRiskStatusMessage(`读取失败：${error}`, { scope: 'global' });
        } finally {
          riskSettingsBusy = false;
          updateRiskButtons();
        }
      }

      async function loadParaRiskSettings({ silent = false } = {}) {
        if (!paraRiskPanel || paraRiskSettingsBusy) {
          return;
        }
        paraRiskSettingsBusy = true;
        updateRiskButtons();
        if (!silent) {
          setRiskStatusMessage('读取 PARA 风险配置…', { scope: 'para' });
        }
        try {
          const response = await fetch('/para/risk_alert/settings', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyRiskSettings(result.settings, { markClean: true, scope: 'para' });
          // applyRiskSettings(markClean) 会更新状态消息
        } catch (error) {
          setRiskStatusMessage(`读取失败：${error}`, { scope: 'para' });
        } finally {
          paraRiskSettingsBusy = false;
          updateRiskButtons();
        }
      }

      async function saveRiskSettings({ enabledOverride } = {}) {
        if (!getRiskViews().length || riskSettingsBusy) {
          return;
        }
        let payload;
        try {
          payload = buildRiskSettingsPayload({ enabledOverride, scope: 'global' });
        } catch (error) {
          setRiskStatusMessage(error.message || String(error), { scope: 'global' });
          return;
        }
    riskSettingsBusy = true;
        updateRiskButtons();
        setRiskStatusMessage('保存风险配置…', { scope: 'global' });
        try {
          const response = await fetch('/risk_alert/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyRiskSettings(result.settings, { markClean: true, scope: 'global' });
          setRiskStatusMessage('配置已保存', { scope: 'global' });
          await refreshMetrics();
        } catch (error) {
          setRiskStatusMessage(`保存失败：${error}`, { scope: 'global' });
        } finally {
          riskSettingsBusy = false;
          updateRiskButtons();
        }
      }

      async function saveParaRiskSettings({ enabledOverride } = {}) {
        if (!paraRiskPanel || paraRiskSettingsBusy) {
          return;
        }
        let payload;
        try {
          payload = buildRiskSettingsPayload({ enabledOverride, scope: 'para' });
        } catch (error) {
          setRiskStatusMessage(error.message || String(error), { scope: 'para' });
          return;
        }
        paraRiskSettingsBusy = true;
        updateRiskButtons();
        setRiskStatusMessage('保存 PARA 风险配置…', { scope: 'para' });
        try {
          const response = await fetch('/para/risk_alert/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          applyRiskSettings(result.settings, { markClean: true, scope: 'para' });
          setRiskStatusMessage('PARA 配置已保存', { scope: 'para' });
          await refreshMetrics();
        } catch (error) {
          setRiskStatusMessage(`保存失败：${error}`, { scope: 'para' });
        } finally {
          paraRiskSettingsBusy = false;
          updateRiskButtons();
        }
      }

      async function disableRiskAlerts() {
        await saveRiskSettings({ enabledOverride: false });
      }

      async function disableParaRiskAlerts() {
        await saveParaRiskSettings({ enabledOverride: false });
      }

      async function triggerRiskTest() {
        const hasTestButton = getRiskViews().some((view) => view.testButton);
        if (!hasTestButton || riskTestBusy) {
          return;
        }
        riskTestBusy = true;
        updateRiskButtons();
        setRiskTestMessage('推送测试通知…（将出现在「告警历史」中）');
        try {
          const payload = {};
          if (Number.isFinite(latestGlobalRiskRatio) && latestGlobalRiskRatio > 0) {
            payload.ratio = latestGlobalRiskRatio;
          }
          const response = await fetch('/risk_alert/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          const alert = result?.alert || {};
          const ratioPercent = Number(alert.ratio_percent);
          const ratioText = Number.isFinite(ratioPercent) ? `${ratioPercent.toFixed(1)}%` : '--%';
          setRiskTestMessage(`推送成功 · 风险 ${ratioText}`);
        } catch (error) {
          setRiskTestMessage(`推送失败：${error}`);
        } finally {
          riskTestBusy = false;
          updateRiskButtons();
        }
      }

      async function triggerParaRiskTest() {
        if (!paraRiskPanel || riskTestBusy) {
          return;
        }
        riskTestBusy = true;
        updateRiskButtons();
        setRiskTestMessage('推送 PARA 测试通知…（将出现在「告警历史 (PARA)」中）');
        try {
          const payload = { kind: 'para_risk' };
          if (Number.isFinite(paraLatestRiskRatio) && paraLatestRiskRatio > 0) {
            payload.ratio = paraLatestRiskRatio;
          }
          const response = await fetch('/risk_alert/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          const alert = result?.alert || {};
          const server = result?.server || null;
          const debug = result?.debug || null;
          const ratioPercent = Number(alert.ratio_percent);
          const ratioText = Number.isFinite(ratioPercent) ? `${ratioPercent.toFixed(1)}%` : '--%';
          const serverText = server?.pid ? ` · pid=${server.pid}` : '';
          const debugText = debug
            ? ` · kind=${debug.parsed_kind || '--'} use_para=${debug.use_para ? 'Y' : 'N'} base=${debug.base_label || '--'}`
            : '';
          setRiskTestMessage(`推送成功 · PARA 风险 ${ratioText}${serverText}${debugText}`);
        } catch (error) {
          setRiskTestMessage(`推送失败：${error}`);
        } finally {
          riskTestBusy = false;
          updateRiskButtons();
          // Force refresh history after testing to avoid confusion.
          loadRiskHistory({ silent: false });
        }
      }

      async function triggerBpRiskTest() {
        if (!bpRiskPanel || riskTestBusy) {
          return;
        }
        riskTestBusy = true;
        updateRiskButtons();
        setRiskTestMessage('推送 Backpack 测试通知…（将出现在「告警历史 (Backpack)」中）');
        try {
          const payload = { kind: 'bp_risk' };
          if (Number.isFinite(bpLatestRiskRatio) && bpLatestRiskRatio > 0) {
            payload.ratio = bpLatestRiskRatio;
          }
          const response = await fetch('/risk_alert/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const result = await response.json();
          const alert = result?.alert || {};
          const ratioPercent = Number(alert.ratio_percent);
          const ratioText = Number.isFinite(ratioPercent) ? `${ratioPercent.toFixed(1)}%` : '--%';
          setRiskTestMessage(`推送成功 · Backpack 风险 ${ratioText}`);
        } catch (error) {
          setRiskTestMessage(`推送失败：${error}`);
        } finally {
          riskTestBusy = false;
          updateRiskButtons();
          loadRiskHistory({ silent: false });
        }
      }

      function extractBaseAsset(symbol) {
        if (!symbol) {
          return null;
        }
        let text = normalizeSymbolLabel(symbol);
        if (!text) {
          return null;
        }
        text = text.replace(/[:_\-\s]+/g, '/');
        const parts = text.split('/').filter(Boolean);
        let candidate = parts.length ? parts[0] : text;
        const suffixes = ['PERP', 'FUTURES', 'FUT', 'USD', 'USDT', 'USDC'];
        let stripped = true;
        while (stripped && candidate.length > 0) {
          stripped = false;
          for (const suffix of suffixes) {
            if (candidate.endsWith(suffix) && candidate.length > suffix.length) {
              candidate = candidate.slice(0, -suffix.length);
              stripped = true;
              break;
            }
          }
        }
        const match = candidate.match(/[A-Z]+/);
        return match ? match[0] : null;
      }

      // --- Symbol normalization ---
      // Some panels rely on normalizeSymbolLabel(), but older builds didn't include it.
      // Keep a lightweight implementation here to avoid runtime crashes that prevent
      // subsequent UI bootstrapping (e.g. Backpack markets dropdown).
      function normalizeSymbolLabel(symbol) {
        if (symbol == null) {
          return '';
        }
        let text = String(symbol).trim();
        if (!text) {
          return '';
        }
        // Prefer a consistent display value across exchanges.
        text = text.toUpperCase();
        // Common separators normalization.
        text = text.replace(/\s+/g, '');
        // Keep common futures naming but normalize delimiters.
        text = text.replace(/[:_\-]+/g, '-');
        return text;
      }

      // Shared helper for PARA/GRVT/Backpack adjustment panels.
      // Some earlier builds referenced it without defining it, which breaks the
      // click handler before the fetch() call is executed.
      function describeAdjustmentAction(action) {
        const value = String(action || '').trim().toLowerCase();
        if (value === 'add' || value === 'increase') {
          return '加仓';
        }
        if (value === 'reduce' || value === 'decrease') {
          return '减仓';
        }
        if (!value) {
          return '--';
        }
        return value.toUpperCase();
      }

      // Some pages used these helpers as globals; ensure they exist.
      function formatTimestamp(value) {
        if (value === undefined || value === null) {
          return null;
        }
        const n = Number(value);
        if (!Number.isFinite(n) || n <= 0) {
          return null;
        }
        // Heuristic: seconds vs milliseconds.
        const ms = n < 10_000_000_000 ? n * 1000 : n;
        try {
          return new Date(ms).toLocaleString();
        } catch {
          return null;
        }
      }

      function formatDuration(msOrSeconds) {
        const n = Number(msOrSeconds);
        if (!Number.isFinite(n) || n < 0) {
          return '--';
        }
        // Most callers pass seconds; tolerate milliseconds.
        const seconds = n > 10_000 ? Math.round(n / 1000) : Math.round(n);
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        if (minutes <= 0) {
          return `${secs}s`;
        }
        return `${minutes}m${String(secs).padStart(2, '0')}s`;
      }

      function resolveMarginTier(baseAsset, notionalValue) {
        if (!baseAsset || !Number.isFinite(notionalValue) || notionalValue <= 0) {
          return null;
        }
        const schedule = (MARGIN_SCHEDULES[baseAsset] && MARGIN_SCHEDULES[baseAsset].length)
          ? MARGIN_SCHEDULES[baseAsset]
          : DEFAULT_MARGIN_SCHEDULE;
        for (const tier of schedule) {
          if (notionalValue <= tier.maxNotional) {
            return tier;
          }
        }
        return schedule[schedule.length - 1] ?? null;
      }

      function computePositionMargin(position) {
        if (!position) {
          return null;
        }

        // Prefer API-provided margins if present
        const apiInitial = parseDecimal(position.initial_margin ?? position.initialMargin);
        const apiMaint = parseDecimal(position.maintenance_margin ?? position.maintenanceMargin);
        let notional = parseDecimal(position.notional_value ?? position.notional);

        const size = parseDecimal(position.net_size ?? position.size ?? position.quantity);
        let price = parseDecimal(position.mark_price ?? position.markPrice);
        if (!Number.isFinite(price)) {
          price = parseDecimal(position.entry_price ?? position.entryPrice);
        }
        if (!Number.isFinite(notional) && Number.isFinite(size) && Number.isFinite(price)) {
          notional = Math.abs(size * price);
        }

        const baseAsset = extractBaseAsset(position.symbol);

        // If API margins are available, return them directly (with rates when possible)
        if (Number.isFinite(apiInitial) || Number.isFinite(apiMaint)) {
          const effectiveNotional = Number.isFinite(notional) ? notional : null;
          return {
            baseAsset,
            notional: effectiveNotional,
            initialMargin: Number.isFinite(apiInitial) ? apiInitial : null,
            maintenanceMargin: Number.isFinite(apiMaint) ? apiMaint : null,
            initialRate: Number.isFinite(apiInitial) && Number.isFinite(effectiveNotional) && effectiveNotional > 0
              ? apiInitial / effectiveNotional
              : null,
            maintenanceRate: Number.isFinite(apiMaint) && Number.isFinite(effectiveNotional) && effectiveNotional > 0
              ? apiMaint / effectiveNotional
              : null,
          };
        }

        if (!Number.isFinite(size) || !Number.isFinite(price) || !Number.isFinite(notional) || notional <= 0) {
          return null;
        }

        const tier = resolveMarginTier(baseAsset, notional);
        if (!tier) {
          return { baseAsset, notional };
        }
        return {
          baseAsset,
          notional,
          initialMargin: notional * tier.initial,
          maintenanceMargin: notional * tier.maintenance,
          initialRate: tier.initial,
          maintenanceRate: tier.maintenance,
        };
      }

      function estimateTransferableFunds(input) {
        if (!input) {
          return null;
        }

        const pickFirstFinite = (...values) => {
          for (const value of values) {
            if (Number.isFinite(value)) {
              return Number(value);
            }
          }
          return null;
        };

        const equity = pickFirstFinite(
          input.equityValue,
          input.availableEquityValue,
          Number.isFinite(input.walletValue) && Number.isFinite(input.unrealizedPnl)
            ? Number(input.walletValue) + Number(input.unrealizedPnl)
            : null
        );
        if (equity === null) {
          return null;
        }

        const initialMargin = Number.isFinite(input.totalInitialMargin) && input.totalInitialMargin > 0
          ? Number(input.totalInitialMargin)
          : 0;
        const unrealizedProfit = Number.isFinite(input.unrealizedPnl) && input.unrealizedPnl > 0
          ? Number(input.unrealizedPnl)
          : 0;
        const estimated = equity - initialMargin - unrealizedProfit;
        if (!Number.isFinite(estimated)) {
          return null;
        }

        const clipped = Math.max(0, estimated);
        return {
          raw: estimated,
          value: clipped,
          basis: 'equity',
          initialMargin,
          unrealized: unrealizedProfit,
        };
      }

      function acceptRiskCapacityValue(state, value, timestamp) {
        const targetState = state || riskCapacityBufferState;
        targetState.acceptedValue = Number.isFinite(value) ? value : null;
        targetState.acceptedAt = Number.isFinite(timestamp) ? timestamp : Date.now() / 1000;
        targetState.pendingValue = null;
        targetState.pendingCycles = 0;
        targetState.pendingDeltaPct = 0;
        targetState.pendingSince = null;
      }

      function evaluateRiskCapacityBuffer({ hasValue, value, timestamp, baseNote, state = riskCapacityBufferState }) {
        const targetState = state || riskCapacityBufferState;
        const safeBaseNote = baseNote || '';
        const safeTimestamp = Number.isFinite(timestamp) ? timestamp : Date.now() / 1000;

        if (!hasValue || !Number.isFinite(value)) {
          targetState.pendingValue = null;
          targetState.pendingCycles = 0;
          targetState.pendingDeltaPct = 0;
          targetState.pendingSince = null;
          const accepted = targetState.acceptedValue;
          if (!Number.isFinite(accepted)) {
            return { displayValue: null, note: safeBaseNote || '缺少风险基数数据', status: 'missing' };
          }
          const noteParts = [];
          if (safeBaseNote) {
            noteParts.push(safeBaseNote);
          }
          noteParts.push('沿用上次值');
          return {
            displayValue: accepted,
            note: noteParts.join(' · '),
            status: 'stale',
          };
        }

        const previous = targetState.acceptedValue;
        if (!Number.isFinite(previous)) {
          acceptRiskCapacityValue(targetState, value, safeTimestamp);
          return { displayValue: value, note: safeBaseNote, status: 'fresh' };
        }

        const delta = Math.abs(value - previous);
        const base = Math.max(Math.abs(previous), 1);
        const percentDelta = delta / base;
        const exceedsThreshold = percentDelta >= RISK_CAPACITY_DEVIATION_THRESHOLD && delta >= RISK_CAPACITY_MIN_ABS_DELTA;

        if (!exceedsThreshold) {
          acceptRiskCapacityValue(targetState, value, safeTimestamp);
          return { displayValue: value, note: safeBaseNote, status: 'fresh' };
        }

        const tolerance = Math.max(Math.abs(value), 1) * RISK_CAPACITY_PENDING_TOLERANCE;
        if (Number.isFinite(targetState.pendingValue) && Math.abs(targetState.pendingValue - value) <= tolerance) {
          targetState.pendingCycles += 1;
        } else {
          targetState.pendingValue = value;
          targetState.pendingCycles = 1;
          targetState.pendingSince = safeTimestamp;
        }
        targetState.pendingDeltaPct = percentDelta;

        if (targetState.pendingCycles >= RISK_CAPACITY_CONFIRMATION_CYCLES) {
          acceptRiskCapacityValue(targetState, value, safeTimestamp);
          return { displayValue: value, note: safeBaseNote, status: 'fresh' };
        }

        const noteParts = [];
        if (safeBaseNote) {
          noteParts.push(safeBaseNote);
        }
  noteParts.push(`数据确认中 (${targetState.pendingCycles}/${RISK_CAPACITY_CONFIRMATION_CYCLES})`);
        noteParts.push(`偏差 ${formatPercent(percentDelta * 100, 1)}`);
        return {
          displayValue: previous,
          note: noteParts.join(' · '),
          status: 'pending',
        };
      }

      function updateGrvtSymbolOptions(symbols) {
        if (!grvtAdjustSymbolsSelect) {
          return;
        }
        const normalized = Array.from(
          new Set((Array.isArray(symbols) ? symbols : []).map((symbol) => normalizeSymbolLabel(symbol)).filter(Boolean))
        ).sort();
        const nextKey = normalized.join('|');
        if (nextKey === grvtSymbolOptionsKey && grvtAdjustSymbolsSelect.options.length === normalized.length) {
          return;
        }
        grvtSymbolOptionsKey = nextKey;
        const previousValue = normalizeSymbolLabel(grvtAdjustSymbolsSelect.value);
        grvtAdjustSymbolsSelect.innerHTML = '';
        grvtAdjustSymbolsSelect.disabled = normalized.length === 0;
        if (grvtResetSymbolButton) {
          grvtResetSymbolButton.disabled = normalized.length === 0;
        }
        let matched = false;
        for (const symbol of normalized) {
          const option = document.createElement('option');
          option.value = symbol;
          option.textContent = symbol;
          if (previousValue === symbol) {
            option.selected = true;
            matched = true;
          }
          grvtAdjustSymbolsSelect.appendChild(option);
        }

        if (!matched) {
          grvtAdjustSymbolsSelect.selectedIndex = -1;
        }
      }

      function getSelectedGrvtSymbols() {
        if (!grvtAdjustSymbolsSelect) {
          return null;
        }
        const value = grvtAdjustSymbolsSelect.value;
        if (!value) {
          return null;
        }
        return [value];
      }

      function clearGrvtSymbolSelection() {
        if (!grvtAdjustSymbolsSelect) {
          return;
        }
        grvtAdjustSymbolsSelect.value = '';
        grvtAdjustSymbolsSelect.selectedIndex = -1;
      }

      function updateParaSymbolOptions(symbols) {
        if (!paraAdjustSymbolsSelect) {
          return;
        }
        // If the user is currently interacting with the dropdown, avoid rebuilding options.
        // Rebuilding causes the list to jump around and can interrupt selection.
        // We'll refresh once focus returns.
        if (document.activeElement === paraAdjustSymbolsSelect) {
          return;
        }
        const normalized = Array.from(
          new Set((Array.isArray(symbols) ? symbols : []).map((symbol) => normalizeSymbolLabel(symbol)).filter(Boolean))
        ).sort();
        const nextKey = normalized.join('|');
        if (nextKey === paraSymbolOptionsKey && paraAdjustSymbolsSelect.options.length === normalized.length) {
          return;
        }
        paraSymbolOptionsKey = nextKey;
        const previousValue = normalizeSymbolLabel(paraAdjustSymbolsSelect.value);
        const disabled = normalized.length === 0;
        paraAdjustSymbolsSelect.disabled = disabled;
        if (paraResetSymbolButton) {
          paraResetSymbolButton.disabled = disabled;
        }

        // Diff-update options instead of resetting innerHTML to keep the UI stable.
        const existingValues = Array.from(paraAdjustSymbolsSelect.options).map((opt) => normalizeSymbolLabel(opt.value));
        const sameList = existingValues.length === normalized.length && existingValues.every((v, i) => v === normalized[i]);
        if (!sameList) {
          const oldScrollTop = paraAdjustSymbolsSelect.scrollTop;
          paraAdjustSymbolsSelect.innerHTML = '';
          for (const symbol of normalized) {
            const option = document.createElement('option');
            option.value = symbol;
            option.textContent = symbol;
            paraAdjustSymbolsSelect.appendChild(option);
          }
          // Best-effort restore scroll position.
          paraAdjustSymbolsSelect.scrollTop = oldScrollTop;
        }

        // Preserve selection if possible.
        if (previousValue && normalized.includes(previousValue)) {
          paraAdjustSymbolsSelect.value = previousValue;
        } else {
          paraAdjustSymbolsSelect.selectedIndex = -1;
        }
      }

      function getSelectedParaSymbols() {
        if (!paraAdjustSymbolsSelect) {
          return null;
        }
        const value = paraAdjustSymbolsSelect.value;
        if (!value) {
          return null;
        }
        return [value];
      }

      function clearParaSymbolSelection() {
        if (!paraAdjustSymbolsSelect) {
          return;
        }
        paraAdjustSymbolsSelect.value = '';
        paraAdjustSymbolsSelect.selectedIndex = -1;
      }

      function getSelectedSymbolsFromSelect(selectEl) {
        if (!selectEl) {
          return null;
        }
        const value = selectEl.value;
        if (!value) {
          return null;
        }
        return [value];
      }

      function updateParaTwapScheduleSymbolOptions(symbols) {
        if (!paraTwapScheduleSymbolsSelect) {
          return;
        }
        if (document.activeElement === paraTwapScheduleSymbolsSelect) {
          return;
        }
        const normalized = Array.from(
          new Set((Array.isArray(symbols) ? symbols : []).map((symbol) => normalizeSymbolLabel(symbol)).filter(Boolean))
        ).sort();
        const nextKey = normalized.join('|');
        if (nextKey === paraTwapSymbolOptionsKey && paraTwapScheduleSymbolsSelect.options.length === normalized.length) {
          return;
        }
        paraTwapSymbolOptionsKey = nextKey;
        const previousValue = normalizeSymbolLabel(paraTwapScheduleSymbolsSelect.value);
        const disabled = normalized.length === 0;
        paraTwapScheduleSymbolsSelect.disabled = disabled;
        if (paraTwapScheduleResetSymbolButton) {
          paraTwapScheduleResetSymbolButton.disabled = disabled;
        }

        const existingValues = Array.from(paraTwapScheduleSymbolsSelect.options).map((opt) => normalizeSymbolLabel(opt.value));
        const sameList = existingValues.length === normalized.length && existingValues.every((v, i) => v === normalized[i]);
        if (!sameList) {
          const oldScrollTop = paraTwapScheduleSymbolsSelect.scrollTop;
          paraTwapScheduleSymbolsSelect.innerHTML = '';
          for (const symbol of normalized) {
            const option = document.createElement('option');
            option.value = symbol;
            option.textContent = symbol;
            paraTwapScheduleSymbolsSelect.appendChild(option);
          }
          paraTwapScheduleSymbolsSelect.scrollTop = oldScrollTop;
        }

        if (previousValue && normalized.includes(previousValue)) {
          paraTwapScheduleSymbolsSelect.value = previousValue;
        } else {
          paraTwapScheduleSymbolsSelect.selectedIndex = -1;
        }
      }

      if (paraTwapScheduleSymbolsSelect) {
        paraTwapScheduleSymbolsSelect.addEventListener('blur', () => {
          refreshMetrics();
        });
        paraTwapScheduleSymbolsSelect.addEventListener('change', () => {
          refreshMetrics();
        });
      }

      // Refresh the symbol list after the user closes the dropdown.
      // While focused, we intentionally skip option rebuilds to avoid the UI jumping.
      if (paraAdjustSymbolsSelect) {
        paraAdjustSymbolsSelect.addEventListener('blur', () => {
          refreshMetrics();
        });
        paraAdjustSymbolsSelect.addEventListener('change', () => {
          refreshMetrics();
        });
      }

      function updateBpSymbolOptions(symbols) {
        if (!bpAdjustSymbolsSelect) {
          return;
        }
        if (document.activeElement === bpAdjustSymbolsSelect) {
          return;
        }
        const normalized = Array.from(
          new Set((Array.isArray(symbols) ? symbols : []).map((symbol) => normalizeSymbolLabel(symbol)).filter(Boolean))
        ).sort();
        const nextKey = normalized.join('|');
        if (nextKey === bpSymbolOptionsKey && bpAdjustSymbolsSelect.options.length === normalized.length) {
          return;
        }
        bpSymbolOptionsKey = nextKey;
        const previousValue = normalizeSymbolLabel(bpAdjustSymbolsSelect.value);
        const disabled = normalized.length === 0;
        bpAdjustSymbolsSelect.disabled = disabled;
        if (bpResetSymbolButton) {
          bpResetSymbolButton.disabled = disabled;
        }

        const existingValues = Array.from(bpAdjustSymbolsSelect.options).map((opt) => normalizeSymbolLabel(opt.value));
        const sameList = existingValues.length === normalized.length && existingValues.every((v, i) => v === normalized[i]);
        if (!sameList) {
          const oldScrollTop = bpAdjustSymbolsSelect.scrollTop;
          bpAdjustSymbolsSelect.innerHTML = '';
          for (const symbol of normalized) {
            const option = document.createElement('option');
            option.value = symbol;
            option.textContent = symbol;
            bpAdjustSymbolsSelect.appendChild(option);
          }
          bpAdjustSymbolsSelect.scrollTop = oldScrollTop;
        }

        if (previousValue && normalized.includes(previousValue)) {
          bpAdjustSymbolsSelect.value = previousValue;
        } else {
          bpAdjustSymbolsSelect.selectedIndex = -1;
        }
      }

      function getSelectedBpSymbols() {
        if (!bpAdjustSymbolsSelect) {
          return null;
        }
        const value = bpAdjustSymbolsSelect.value;
        if (!value) {
          return null;
        }
        return [value];
      }

      function clearBpSymbolSelection() {
        if (!bpAdjustSymbolsSelect) {
          return;
        }
        bpAdjustSymbolsSelect.value = '';
        bpAdjustSymbolsSelect.selectedIndex = -1;
      }

      if (bpAdjustSymbolsSelect) {
        bpAdjustSymbolsSelect.addEventListener('blur', () => {
          refreshMetrics();
        });
        bpAdjustSymbolsSelect.addEventListener('change', () => {
          refreshMetrics();
        });
      }

      function updateBpAdjustButtons() {
        if (bpAdjustLocked && bpAdjustLockedSince && Date.now() - bpAdjustLockedSince > BP_ADJUST_LOCK_TIMEOUT_MS) {
          bpAdjustLocked = false;
          bpPendingRequestId = null;
          bpAdjustLockedSince = 0;
          if (!shouldRespectBpAdjustSticky()) {
            setBpAdjustStatus('等待 VPS ACK 超时，已自动解锁（可重新下发）', { stickyMs: 30_000 });
          }
        }
        const disabled = bpAdjustLocked;
        [bpAdjustAddButton, bpAdjustReduceButton].forEach((button) => {
          if (button) {
            button.disabled = disabled;
          }
        });
      }

      function updateBpTwapVisibility() {
        const mode = (bpOrderModeSelect?.value || 'twap').toLowerCase();
        if (bpTwapDurationWrapper) {
          bpTwapDurationWrapper.style.display = mode === 'twap' ? 'block' : 'none';
        }
        if (bpTwapStepWrapper) {
          bpTwapStepWrapper.style.display = mode === 'twap' ? 'block' : 'none';
        }
      }

      function clampBpTwapStepSeconds(value) {
        const raw = typeof value === 'string' ? parseFloat(value) : Number(value);
        const step = Number.isFinite(raw) ? raw : 0;
        const min = 1;
        const max = 3600;
        if (step <= 0) {
          return null;
        }
        return Math.max(min, Math.min(max, Math.round(step)));
      }

      async function sendBpAdjustment(action) {
        if (!action || bpAdjustLocked) {
          return;
        }

        // Dual-VPS hedge mode: prefer using Backpack Auto-Balance pair (A/B) as the
        // default target agents for every add/reduce request.
        // Backend refuses to default to broadcast "all" for /backpack/adjust, so we
        // explicitly submit one request per agent_id.
        const pickAgentId = (raw) => String(raw || '').trim();
        const agentIds = Array.from(
          new Set(
            [
              pickAgentId(bpAutoAgentASelect?.value),
              pickAgentId(bpAutoAgentBSelect?.value),
            ].filter(Boolean)
          )
        );

        // Fallback: if auto-balance pair isn't configured, use the currently selected strategy agent.
        if (!agentIds.length) {
          const fallback = pickAgentId(selectedStrategyAgent?.agent || selectedStrategyAgent?.agent_id || selectedStrategyAgent?.id);
          if (fallback) {
            agentIds.push(fallback);
          }
        }

        if (!agentIds.length) {
          setBpAdjustStatus(
            '请求失败：未配置对冲 VPS（请在「Backpack 自动平衡」里选择账户 A/B 作为默认下发对象）',
            { stickyMs: 30_000 }
          );
          return;
        }

        // Disallow same-symbol concurrent TWAP on the same agent.
        const selectedSymbols = getSelectedBpSymbols() || [];
        const selectedSymbol = selectedSymbols.length ? String(selectedSymbols[0] || '').trim() : '';
        if (selectedSymbol && bpActiveSymbolsForAgent.has(selectedSymbol)) {
          setBpAdjustStatus(`该币种 ${selectedSymbol} 的 TWAP 正在运行中（同 agent 不允许同 symbol 并发）`, { stickyMs: 15_000 });
          return;
        }

        // Ensure we always provide immediate UI feedback that survives the 2s refresh loop.
        setBpAdjustStatus(`已点击：${describeAdjustmentAction(action)}，准备提交…`, { stickyMs: 8000 });
        try {
          console.debug('[bp-adjust] click', { action });
        } catch (_) {
          // ignore
        }

  const rawMagnitude = parseFloat(bpAdjustSizeInput?.value ?? '1');
        const magnitude = Number.isFinite(rawMagnitude) && rawMagnitude > 0 ? rawMagnitude : 1;
    // Per request UX: don't block further actions while waiting for VPS ACK.
    // We'll rely on "same symbol" anti-concurrency check instead.
    bpAdjustLocked = false;
    bpAdjustLockedSince = 0;
    updateBpAdjustButtons();
    setBpAdjustStatus(`提交${describeAdjustmentAction(action)}请求…`, { stickyMs: 8000 });

        const buildBasePayload = () => {
          const base = { action, magnitude };
          const symbols = selectedSymbols;
          if (symbols && symbols.length) {
            base.symbols = symbols;
          }

          const orderMode = (bpOrderModeSelect?.value || 'twap').toLowerCase();
          if (orderMode === 'twap') {
            const duration = clampTwapDurationSeconds(bpTwapDurationInput?.value ?? 0) || 900;
            base.order_mode = 'twap';
            base.twap_duration_seconds = duration;

            const stepSeconds = clampBpTwapStepSeconds(bpTwapStepInput?.value ?? 0);
            if (stepSeconds) {
              base.twap_step_seconds = stepSeconds;
            }
          } else {
            base.order_mode = 'market';
          }
          return base;
        };

        const submitOne = async (agentId) => {
          const payload = { agent_id: agentId, ...buildBasePayload() };
          if (DEBUG_UI) {
            setBpAdjustStatus(`DEBUG: POST /backpack/adjust · payload=${JSON.stringify(payload)}`, { stickyMs: 30000 });
          }
          const response = await fetch('/backpack/adjust', {
            method: 'POST',
            credentials: 'same-origin',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(payload)
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            const detail = (text || '').trim();
            throw new Error(detail ? `HTTP ${response.status}: ${detail}` : `HTTP ${response.status}`);
          }
          const responsePayload = await response.json();
          return responsePayload?.request?.request_id ?? responsePayload?.request_id ?? null;
        };

        try {
          if (typeof fetch !== 'function') {
            throw new Error('fetch 不可用（浏览器环境异常）');
          }

          setBpAdjustStatus(
            `提交中：将下发到 ${agentIds.length} 个 VPS（${agentIds.join(', ')}）…`,
            { stickyMs: 12000 }
          );

          const results = [];
          for (const aid of agentIds) {
            try {
              const reqId = await submitOne(aid);
              results.push({ agent_id: aid, ok: true, request_id: reqId });
            } catch (err) {
              results.push({ agent_id: aid, ok: false, error: String(err || 'unknown error') });
            }
          }

          const okCount = results.filter((r) => r.ok).length;
          const failCount = results.length - okCount;
          const reqIds = results.filter((r) => r.ok && r.request_id).map((r) => `${r.agent_id}:${r.request_id}`);
          const failBrief = results
            .filter((r) => !r.ok)
            .map((r) => `${r.agent_id}=${r.error.replace(/\s+/g, ' ').slice(0, 120)}`)
            .join(' | ');

          // Choose a representative request_id (first success) for legacy UI fields.
          bpPendingRequestId = results.find((r) => r.ok && r.request_id)?.request_id ?? null;

          bpAdjustLocked = false;
          bpAdjustLockedSince = 0;
          updateBpAdjustButtons();

          if (!failCount) {
            setBpAdjustStatus(
              reqIds.length
                ? `已提交（${reqIds.join(', ')}），无需等待 ACK，可继续下发）`
                : '已提交（无需等待 ACK，可继续下发）',
              { stickyMs: 15000 }
            );
          } else {
            setBpAdjustStatus(
              `部分失败：成功 ${okCount}/${results.length}；失败 ${failCount}。${failBrief ? ` ${failBrief}` : ''}`,
              { stickyMs: 30_000 }
            );
          }

          await refreshMetrics();
        } catch (error) {
          bpAdjustLocked = false;
          bpAdjustLockedSince = 0;
          updateBpAdjustButtons();
          setBpAdjustStatus(`请求失败：${error}`, { stickyMs: 30_000 });
        }
      }

      // --- Backpack Internal Transfer ---
      const bpTransferFrom = document.getElementById('bp-transfer-from');
      const bpTransferTo = document.getElementById('bp-transfer-to');
      const bpTransferSymbol = document.getElementById('bp-transfer-symbol');
      const bpTransferQty = document.getElementById('bp-transfer-qty');
      const bpTransferSubmit = document.getElementById('bp-transfer-submit');
      const bpTransferStatus = document.getElementById('bp-transfer-status');

      function setBpTransferStatus(text, { stickyMs } = {}) {
        if (!bpTransferStatus) return;
        bpTransferStatus.textContent = String(text || '');
        if (stickyMs) {
          bpTransferStatus.dataset.stickyUntil = String(Date.now() + Number(stickyMs));
        }
      }

      function shouldRespectBpTransferSticky() {
        if (!bpTransferStatus) return false;
        const until = Number(bpTransferStatus.dataset.stickyUntil || 0);
        return until && Date.now() < until;
      }

      function getBpInternalTransferDirectory(rootPayload) {
        const dir = [];
        const src = rootPayload?.backpack_accounts;
        if (!src) return dir;

        // The caller passes either:
        // 1) a single snapshot object (rare), or
        // 2) a map: { [agentId]: snapshot }
        const snapshots = (src && typeof src === 'object' && !Array.isArray(src) && !('accounts' in src))
          ? Object.entries(src)
          : [[(rootPayload?.agent_id || 'backpack'), src]];

        for (const [agentId, snap] of snapshots) {
          if (!snap || typeof snap !== 'object') continue;
          const accounts = Array.isArray(snap.accounts) ? snap.accounts : [];
          const topAddr = (snap.internal_transfer_address || '').toString().trim();
          const labelFromSnap = (snap.instrument || snap.label || agentId || 'backpack').toString();
          if (topAddr) {
            dir.push({ agent_id: String(agentId), label: labelFromSnap, address: topAddr });
          }
          for (const a of accounts) {
            if (!a) continue;
            const aAgentId = (a.agent_id || a.agentId || agentId || a.name || '').toString().trim();
            const aLabel = (a.name || a.label || aAgentId || labelFromSnap || 'account').toString();
            const addr = (a.internal_transfer_address || a.internalTransferAddress || a.internal_address || '').toString().trim();
            if (aAgentId && addr) {
              dir.push({ agent_id: aAgentId, label: aLabel, address: addr });
            }
          }
        }

        return dir;
      }

      function renderBpInternalTransferDirectory(rootPayload) {
        if (!bpTransferFrom || !bpTransferTo) return;
        const dir = getBpInternalTransferDirectory(rootPayload);
        const unique = [];
        const seen = new Set();
        for (const item of dir) {
          const key = `${item.agent_id}::${item.address}`;
          if (seen.has(key)) continue;
          seen.add(key);
          unique.push(item);
        }

        const buildOptions = (selectEl, selectedAgentId) => {
          selectEl.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = unique.length ? '请选择' : '等待 monitor 上报地址…';
          selectEl.appendChild(placeholder);

          for (const item of unique) {
            const opt = document.createElement('option');
            opt.value = item.agent_id;
            opt.textContent = `${item.label} (${item.agent_id}) · ${item.address}`;
            opt.dataset.address = item.address;
            selectEl.appendChild(opt);
          }
          if (selectedAgentId && unique.some((u) => u.agent_id === selectedAgentId)) {
            selectEl.value = selectedAgentId;
          }
        };

        const prevFrom = bpTransferFrom.value;
        const prevTo = bpTransferTo.value;
        buildOptions(bpTransferFrom, prevFrom);
        buildOptions(bpTransferTo, prevTo);

        // Default pairing: if 2 entries exist, keep them opposite.
        if (unique.length === 2) {
          if (!bpTransferFrom.value) bpTransferFrom.value = unique[0].agent_id;
          if (!bpTransferTo.value) bpTransferTo.value = unique[1].agent_id;
          if (bpTransferFrom.value === bpTransferTo.value) {
            bpTransferTo.value = unique.find((u) => u.agent_id !== bpTransferFrom.value)?.agent_id || '';
          }
        }
      }

      async function sendBpInternalTransfer() {
        if (!bpTransferFrom || !bpTransferTo || !bpTransferQty) return;
        const fromAgent = (bpTransferFrom.value || '').trim();
        const toAgent = (bpTransferTo.value || '').trim();
        if (!fromAgent || !toAgent || fromAgent === toAgent) {
          setBpTransferStatus('请选择不同的 From/To 账号', { stickyMs: 15000 });
          return;
        }
        const fromOpt = bpTransferFrom.selectedOptions?.[0];
        const toOpt = bpTransferTo.selectedOptions?.[0];
        const toAddr = (toOpt?.dataset?.address || '').trim();
        if (!toAddr) {
          setBpTransferStatus('目标账号地址为空（请确认 monitor 已上报 internal 地址）', { stickyMs: 20000 });
          return;
        }

        const qtyRaw = parseFloat(bpTransferQty.value || '0');
        const qty = Number.isFinite(qtyRaw) && qtyRaw > 0 ? qtyRaw : 0;
        if (qty <= 0) {
          setBpTransferStatus('数量必须大于 0', { stickyMs: 15000 });
          return;
        }
        const symbol = (bpTransferSymbol?.value || 'USDC').trim() || 'USDC';

        const payload = {
          agent_id: fromAgent,
          action: 'transfer_internal',
          magnitude: qty,
          symbols: [symbol],
          payload: {
            address: toAddr,
            blockchain: 'Internal',
            autoBorrow: false,
            autoLendRedeem: true,
          }
        };

        setBpTransferStatus('提交内转请求…', { stickyMs: 10000 });
        try {
          const response = await fetch('/backpack/adjust', {
            method: 'POST',
            credentials: 'same-origin',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(payload)
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const respPayload = await response.json();
          const reqId = respPayload?.request?.request_id ?? respPayload?.request_id ?? null;
          setBpTransferStatus(
            reqId ? `已提交（request_id=${reqId}），等待 VPS 执行/ACK…` : '已提交，等待 VPS 执行/ACK…',
            { stickyMs: 15000 }
          );
          await refreshMetrics();
        } catch (err) {
          setBpTransferStatus(`提交失败：${err}`, { stickyMs: 30000 });
        }
      }

      if (bpTransferSubmit) {
        bpTransferSubmit.addEventListener('click', () => {
          sendBpInternalTransfer();
        });
      }

      async function fetchBackpackAdjustments() {
        try {
          // Keep adjustment history reasonably long.
          const response = await fetch('/backpack/adjustments?limit=200', {
            method: 'GET',
            credentials: 'same-origin',
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            return null;
          }
          return await response.json();
        } catch (_) {
          return null;
        }
      }

      async function fetchBackpackTransferHistory() {
        try {
          const response = await fetch('/backpack/adjustments?limit=10', {
            method: 'GET',
            credentials: 'same-origin',
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            return null;
          }
          return await response.json();
        } catch (_) {
          return null;
        }
      }

      function renderBackpackAdjustments(payload) {
        if (!bpAdjustPanel || !bpAdjustHistoryBody) {
          return;
        }

        const adjustments = Array.isArray(payload?.adjustments) ? payload.adjustments : [];
        const normalizeStatus = (value) => String(value || '').toLowerCase();

        // Coordinator/monitor semantics refresher:
        // - coordinator may keep adj.status == 'pending' for broadcast requests until finalization
        // - monitor may send interim updates (e.g. status='running' with extra.progress)
        // So we consider an adjustment "active" when it hasn't reached a terminal state.
        const isTerminal = (st) => ['completed', 'succeeded', 'success', 'failed', 'cancelled', 'canceled', 'terminated', 'timedout', 'timeout'].includes(st);
        const isActiveAgent = (agent) => {
          if (!agent || typeof agent !== 'object') return false;
          const st = normalizeStatus(agent.status);
          if (!st) return false;
          if (st === 'running') return true;
          if (st === 'in_progress' || st === 'pending') return true;
          // If progress payload exists, it's definitely in-flight.
          const extra = agent.extra;
          if (extra && typeof extra === 'object' && extra.progress) return true;
          return false;
        };

        // Prefer a per-agent lock (like PARA monitor behavior): allow multiple TWAPs to
        // exist concurrently as long as *this* VPS (agent) isn't already running one.
        // The dashboard doesn't always know the viewer's agent_id; we can usually infer it
        // from the metrics snapshot (selectedStrategyAgent) and fall back to "all".
        const currentAgentId = String(selectedStrategyAgent?.agent || selectedStrategyAgent?.agent_id || selectedStrategyAgent?.id || '').trim();
        const shouldLockForAgent = (agentRow) => {
          if (!agentRow || typeof agentRow !== 'object') return true;
          const aid = String(agentRow.agent_id || agentRow.agent || agentRow.id || '').trim();
          if (!currentAgentId) return true; // safest fallback
          return aid === currentAgentId;
        };

        // Rebuild active-symbol set for current agent on every refresh.
        bpActiveSymbolsForAgent.clear();
        const addActiveSymbols = (adj) => {
          const rawSymbols = adj?.target_symbols ?? adj?.symbols;
          if (Array.isArray(rawSymbols)) {
            for (const s of rawSymbols) {
              const sym = String(s || '').trim();
              if (sym) bpActiveSymbolsForAgent.add(sym);
            }
          } else if (typeof rawSymbols === 'string') {
            const sym = String(rawSymbols || '').trim();
            if (sym) bpActiveSymbolsForAgent.add(sym);
          }
        };

        // Build a set of active symbols for this agent by scanning all adjustments.
        // Active criteria: any scoped agent row is active (pending/in_progress/running/progress),
        // OR fallback (no agent info) with overall pending/in_progress.
        for (const adj of adjustments) {
          if (String(adj?.action || '').toLowerCase() === 'transfer_internal') {
            continue;
          }
          const st = normalizeStatus(adj?.overall_status ?? adj?.status);
          const agents = Array.isArray(adj?.agents) ? adj.agents : [];
          const scopedAgents = agents.filter(shouldLockForAgent);
          const hasActiveAgent = scopedAgents.some(isActiveAgent);
          const hasTerminalAgent = agents.some((a) => isTerminal(normalizeStatus(a?.status)));
          const isFallbackActive = (['pending', 'in_progress'].includes(st) && !hasTerminalAgent);
          if (hasActiveAgent || isFallbackActive) {
            addActiveSymbols(adj);
          }
        }

        // transfer_internal has its own panel/history fetch; don‘t mix it into adjust history.

        // Determine lock state
        // New behavior: do NOT globally lock the agent when it already has an active TWAP.
        // We only prevent same-symbol concurrency (checked in sendBpAdjustment).
        let locked = false;
        let active = null;
        for (const adj of adjustments) {
          const st = normalizeStatus(adj?.overall_status ?? adj?.status);
          const agents = Array.isArray(adj?.agents) ? adj.agents : [];
          // Per-agent locking: only care about the current agent's active state.
          const scopedAgents = agents.filter(shouldLockForAgent);
          const hasActiveAgent = scopedAgents.some(isActiveAgent);
          const hasTerminalAgent = agents.some((a) => isTerminal(normalizeStatus(a?.status)));

          // Primary: if any agent is still active, this request is active.
          if (hasActiveAgent) {
            active = adj;
            break;
          }

          // Fallback: when status says pending/in_progress but we have no agent detail,
          // treat it as active (classic behavior).
          if (['pending', 'in_progress'].includes(st) && !hasTerminalAgent) {
            active = adj;
            break;
          }
        }
        if (active) {
          locked = false;
          bpPendingRequestId = active.request_id || null;
          const agents = Array.isArray(active.agents) ? active.agents : [];
          const pendingAgents = agents.filter((a) => ['pending', 'in_progress', 'running'].includes(normalizeStatus(a?.status)));
          const scopeText = describeSymbolScope(active?.target_symbols ?? active?.symbols);
          if (!shouldRespectBpAdjustSticky()) {
            // If we have per-agent info and progress is flowing, show it as "运行中".
            const anyRunning = agents.some((a) => normalizeStatus(a?.status) === 'running' || (a?.extra && typeof a.extra === 'object' && a.extra.progress));
            if (anyRunning) {
              setBpAdjustStatus(`TWAP 运行中 · ${pendingAgents.length}/${agents.length || '-'} 个 VPS 未完成（${scopeText}）`);
            } else {
              setBpAdjustStatus(`等待 ${pendingAgents.length}/${agents.length || '-'} 个 VPS ACK（${scopeText}）`);
            }
          }
        } else if (adjustments.length) {
          const latest = adjustments[0];
          const st = normalizeStatus(latest?.overall_status ?? latest?.status);
          const scopeText = describeSymbolScope(latest?.target_symbols ?? latest?.symbols);
          if (!shouldRespectBpAdjustSticky()) {
            if (st === 'completed') {
              setBpAdjustStatus(`最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）已完成`);
            } else if (st === 'failed') {
              setBpAdjustStatus(`最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）部分失败`);
            } else {
              setBpAdjustStatus(`最近状态：${st || '--'}（${scopeText}）`);
            }
          }
        } else {
          if (!shouldRespectBpAdjustSticky()) {
            setBpAdjustStatus('等待指令…（默认全部币种）');
          }
        }

        bpAdjustLocked = locked;
        if (!locked) {
          bpPendingRequestId = null;
          bpAdjustLockedSince = 0;
        }
        updateBpAdjustButtons();

        // Render history (PARA-style grouped rows)
        // Dual-VPS hedge mode makes 2 requests (one per agent_id). For better UX,
        // group them into a single row when they belong to the same user click.
        const adjustmentRequestsRaw = adjustments
          .filter((a) => String(a?.action || '').toLowerCase() !== 'transfer_internal');

  const scopeFor = (adj) => describeSymbolScope(adj?.target_symbols ?? adj?.symbols);

        const normalizeSymbolsKey = (adj) => {
          const raw = adj?.target_symbols ?? adj?.symbols;
          const arr = Array.isArray(raw) ? raw : (raw ? [raw] : []);
          return arr.map((s) => String(s || '').trim()).filter(Boolean).sort().join(',');
        };

        // Identify "same click" groups by:
        // - same action
        // - same magnitude
        // - same symbol scope
        // - created_at within 2 seconds
        // - same order_mode (from payload)
        const GROUP_WINDOW_S = 2.0;
        const groupKeyFor = (adj) => {
          const created = Number(adj?.created_at);
          const createdBucket = Number.isFinite(created) ? Math.floor(created / GROUP_WINDOW_S) : 0;
          const action = String(adj?.action || '').toLowerCase();
          const magnitude = String(adj?.magnitude ?? '');
          const symKey = normalizeSymbolsKey(adj);
          const orderMode = String(adj?.payload?.order_mode || '').toLowerCase();
          return `${createdBucket}::${action}::${magnitude}::${symKey}::${orderMode}`;
        };

        const merged = [];
        const buckets = new Map();
        for (const adj of adjustmentRequestsRaw) {
          const key = groupKeyFor(adj);
          const list = buckets.get(key) || [];
          list.push(adj);
          buckets.set(key, list);
        }

        for (const list of buckets.values()) {
          // If only 1 request in this group, keep as-is.
          if (list.length <= 1) {
            merged.push(list[0]);
            continue;
          }

          // Merge multiple per-agent requests into a synthetic grouped entry.
          // We keep request_id from the newest one (for stable sorting), but merge agents.
          const sorted = list.slice().sort((a, b) => Number(b?.created_at || 0) - Number(a?.created_at || 0));
          const base = { ...(sorted[0] || {}) };
          const baseAgents = Array.isArray(base?.agents) ? base.agents : [];
          const mergedAgents = [...baseAgents];
          const seenAgents = new Set(baseAgents.map((a) => String(a?.agent_id || '').trim()).filter(Boolean));
          for (const item of sorted.slice(1)) {
            const agents = Array.isArray(item?.agents) ? item.agents : [];
            for (const a of agents) {
              const aid = String(a?.agent_id || '').trim();
              if (!aid) continue;
              if (seenAgents.has(aid)) continue;
              seenAgents.add(aid);
              mergedAgents.push(a);
            }
          }
          base.agents = mergedAgents;

          // Derive an overall_status that prioritizes running/in_progress.
          const statuses = mergedAgents.map((a) => normalizeStatus(a?.status));
          if (statuses.some((s) => s === 'running' || s === 'in_progress' || s === 'pending')) {
            base.overall_status = 'pending';
            base.status = 'pending';
          }
          if (statuses.some((s) => s === 'failed')) {
            // Keep pending if still running, otherwise failed.
            const anyActive = statuses.some((s) => s === 'running' || s === 'in_progress' || s === 'pending');
            if (!anyActive) {
              base.overall_status = 'failed';
              base.status = 'failed';
            }
          }
          if (statuses.length && statuses.every((s) => s === 'completed' || s === 'succeeded' || s === 'success')) {
            base.overall_status = 'completed';
            base.status = 'completed';
          }

          merged.push(base);
        }

        // Keep newest-first ordering.
        merged.sort((a, b) => Number(b?.created_at || 0) - Number(a?.created_at || 0));

        renderBpAdjustmentsTableStyle(merged, { scopeFor });
      }

      function renderBpTransferAdjustments(adjustments) {
        if (!bpTransferStatus) {
          return;
        }
        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const transfers = (Array.isArray(adjustments) ? adjustments : []).filter((a) => {
          return String(a?.action || '').toLowerCase() === 'transfer_internal';
        });

        // Render history table (latest 10)
        try {
          if (bpTransferHistoryBody) {
            if (!transfers.length) {
              bpTransferHistoryBody.innerHTML = '<tr><td colspan="7">暂无记录</td></tr>';
            } else {
              const safeText = (value) => {
                if (value === undefined || value === null) {
                  return '--';
                }
                const text = String(value).trim();
                return text ? text : '--';
              };
              const rows = [];

              const directory =
                typeof getBpInternalTransferDirectory === 'function'
                  ? getBpInternalTransferDirectory(lastMetricsSnapshot)
                  : [];

              const agentToAddressMap = new Map();
              const addressToAgentMap = new Map();
              const agentToLabelMap = new Map();
              if (Array.isArray(directory)) {
                for (const item of directory) {
                  if (!item || typeof item !== 'object') continue;
                  const aid = String(item.agent_id || '').trim();
                  const addr = String(item.address || '').trim();
                  const label = String(item.label || '').trim();
                  if (aid && addr) {
                    if (!agentToAddressMap.has(aid)) agentToAddressMap.set(aid, addr);
                    if (label && !agentToLabelMap.has(aid)) agentToLabelMap.set(aid, label);
                    if (!addressToAgentMap.has(addr)) addressToAgentMap.set(addr, aid);
                  }
                }
              }

              const agentToAddress = (agentId) => {
                const key = String(agentId || '').trim();
                return key ? agentToAddressMap.get(key) || null : null;
              };

              const addressToAgent = (address) => {
                const key = String(address || '').trim();
                return key ? addressToAgentMap.get(key) || null : null;
              };

              const agentToLabel = (agentId) => {
                const key = String(agentId || '').trim();
                return key ? agentToLabelMap.get(key) || null : null;
              };

              const formatParty = ({ agentId, address }) => {
                const aid = String(agentId || '').trim();
                const addr = String(address || '').trim();
                const label = (agentToLabel(aid) || aid || '').trim();
                // Always include both “who” and “where” when possible so From/To look consistent.
                if (label && addr) return `${label} (${addr})`;
                if (label) return label;
                if (addr) return addr;
                return '--';
              };

              for (const t of transfers.slice(0, 10)) {
                const createdText = formatTimestamp(t.created_at) ?? '--';
                // NOTE: internal transfer API may return a withdrawal object with status=pending
                // even when the monitor ack is "succeeded" (it only means the request was accepted).
                // Prefer showing "in_progress" when we can detect that backend status.
                const rawOverall = t.overall_status ?? t.status;
                let st = safeText(rawOverall);
                try {
                  const resultStatus = String(t?.agents?.[0]?.extra?.result?.status || '').toLowerCase();
                  const overallLower = String(rawOverall || '').toLowerCase();
                  if (resultStatus) {
                    if (['completed', 'success', 'succeeded', 'ok'].includes(resultStatus)) {
                      st = 'completed';
                    } else if (
                      !['completed', 'failed'].includes(overallLower) &&
                      ['pending', 'initiated', 'processing'].includes(resultStatus)
                    ) {
                      st = 'in_progress';
                    }
                  }
                } catch (_) {
                  // ignore
                }
                const fromAgent = safeText(t.agent_id);
                const fromAddr = agentToAddress(t.agent_id);
                const toAddrRaw = t?.payload?.address;
                const toAddr = safeText(toAddrRaw);
                const toAgent = toAddrRaw ? addressToAgent(toAddrRaw) : null;
                const toAgentAddr = toAgent ? agentToAddress(toAgent) : null;
                const sym = safeText(
                  (Array.isArray(t?.symbols) && t.symbols[0]) ||
                    (Array.isArray(t?.target_symbols) && t.target_symbols[0]) ||
                    t?.symbol
                );
                const qty = safeText(t.magnitude);
                const note = safeText(t.note);

                const fromCellText = formatParty({ agentId: t.agent_id, address: fromAddr || '' });
                const fromTitleParts = [];
                if (fromAgent && fromAddr) fromTitleParts.push(`agent_id=${fromAgent}`);
                const fromTitle = fromTitleParts.join(' ');

                // If To can't be mapped back to a known agent, we still show the address.
                // This happens when payload.address isn't the internal_transfer_address of any monitor.
                const toCellText = formatParty({ agentId: toAgent || '', address: toAgentAddr || toAddrRaw || '' });
                const toTitleParts = [];
                if (toAgent) toTitleParts.push(`agent_id=${toAgent}`);
                if (!toAgent && toAddrRaw) toTitleParts.push('unmapped_address');
                const toTitle = toTitleParts.join(' ');

                rows.push(`
                  <tr>
                    <td>${escapeHtml(createdText)}</td>
                    <td title="${escapeHtml(fromTitle)}">${escapeHtml(fromCellText)}</td>
                    <td title="${escapeHtml(toTitle)}">${escapeHtml(toCellText)}</td>
                    <td>${escapeHtml(sym)}</td>
                    <td>${escapeHtml(qty)}</td>
                    <td>${escapeHtml(st)}</td>
                    <td>${escapeHtml(note)}</td>
                  </tr>
                `);
              }
              bpTransferHistoryBody.innerHTML = rows.join('');
            }
          }
        } catch (_) {
          // ignore
        }

        // Status line respects sticky (avoid overriding “已提交…” too fast)
        if (shouldRespectBpTransferSticky()) {
          return;
        }

        if (!transfers.length) {
          setBpTransferStatus('等待指令…');
          return;
        }
        const latest = transfers[0];
        const st = normalizeStatus(latest?.overall_status ?? latest?.status);
        if (st === 'completed' || st === 'succeeded' || st === 'success') {
          setBpTransferStatus('最近一次内转已完成');
        } else if (st === 'failed' || st === 'error') {
          setBpTransferStatus(`最近一次内转失败：${latest?.note || '--'}`);
        } else {
          setBpTransferStatus(`内转状态：${st || '--'}`);
        }
      }

      function updateParaAdjustButtons() {
        const disabled = paraAdjustLocked;
        [paraAdjustAddButton, paraAdjustReduceButton].forEach((button) => {
          if (button) {
            button.disabled = disabled;
          }
        });
      }

      function clampTwapDurationSeconds(raw) {
        const value = Number.parseInt(raw, 10);
        if (!Number.isFinite(value)) {
          return null;
        }
        const clamped = Math.min(86400, Math.max(30, value));
        return Math.round(clamped / 30) * 30;
      }

      function clampIntervalSeconds(raw) {
        const value = Number.parseInt(raw, 10);
        if (!Number.isFinite(value)) {
          return null;
        }
        const clamped = Math.min(86400, Math.max(30, value));
        return Math.round(clamped / 30) * 30;
      }

      function formatTs(ts) {
        const num = Number(ts);
        if (!Number.isFinite(num) || num <= 0) {
          return null;
        }
        try {
          return new Date(num * 1000).toLocaleString();
        } catch (_) {
          return null;
        }
      }

      // -----------------------------
      // PARA TWAP Scheduler (multi-task)
      // -----------------------------

      let paraTwapSchedulerTasksDraft = [];
      let paraTwapScheduleEditingTaskId = null;

      function _setEditingTask(task) {
        const id = task && task.task_id ? String(task.task_id) : null;
        paraTwapScheduleEditingTaskId = id;
        if (paraTwapScheduleSaveEditButton) {
          paraTwapScheduleSaveEditButton.disabled = !id;
        }
        if (paraTwapScheduleEditHint) {
          if (id && task) {
            paraTwapScheduleEditHint.textContent = `当前编辑：${_formatSchedulerTaskSummary(task)}`;
          } else {
            paraTwapScheduleEditHint.textContent = '当前：新增任务';
          }
        }
      }

      function _getEditingTaskId() {
        return paraTwapScheduleEditingTaskId ? String(paraTwapScheduleEditingTaskId) : null;
      }

      function _applyTaskToForm(task) {
        const t = (task && typeof task === 'object') ? task : {};
        if (paraTwapScheduleIntervalInput && t.interval_seconds != null) {
          paraTwapScheduleIntervalInput.value = String(t.interval_seconds);
        }
        if (paraTwapScheduleActionSelect && t.action) {
          paraTwapScheduleActionSelect.value = String(t.action).toLowerCase() === 'reduce' ? 'reduce' : 'add';
        }
        if (paraTwapScheduleSizeInput && t.magnitude != null) {
          paraTwapScheduleSizeInput.value = String(t.magnitude);
        }
        if (paraTwapScheduleDurationInput && t.twap_duration_seconds != null) {
          paraTwapScheduleDurationInput.value = String(t.twap_duration_seconds);
        }
        // Symbols select: best-effort (multi-select). If element is simple select,
        // we fallback to clearing selection.
        try {
          if (paraTwapScheduleSymbolsSelect) {
            const syms = Array.isArray(t.symbols) ? t.symbols : [];
            for (const opt of Array.from(paraTwapScheduleSymbolsSelect.options || [])) {
              opt.selected = syms.includes(opt.value);
            }
          }
        } catch (_) {
          // ignore
        }
      }

      function _normalizeParaTwapSchedulerTasks(scheduler) {
        const tasks = Array.isArray(scheduler?.tasks) ? scheduler.tasks : [];
        return tasks.map((t, idx) => {
          const obj = (t && typeof t === 'object') ? t : {};
          return {
            task_id: String(obj.task_id || `task-${idx + 1}`),
            enabled: obj.enabled !== false,
            action: String(obj.action || 'add').toLowerCase(),
            magnitude: Number.isFinite(Number(obj.magnitude)) && Number(obj.magnitude) > 0 ? Number(obj.magnitude) : 1,
            interval_seconds: clampIntervalSeconds(obj.interval_seconds ?? 900) || 900,
            twap_duration_seconds: clampTwapDurationSeconds(obj.twap_duration_seconds ?? 900) || 900,
            symbols: Array.isArray(obj.symbols) ? obj.symbols : null,
            next_run_at: obj.next_run_at ?? null,
          };
        });
      }

      function _formatSchedulerTaskSummary(task) {
        const magnitude = task?.magnitude ?? '--';
        const scope = describeSymbolScope(task?.symbols);
        const interval = task?.interval_seconds ?? '--';
        const duration = task?.twap_duration_seconds ?? '--';
        return `${describeAdjustmentAction(task?.action)} ${magnitude} ${scope}，间隔 ${interval}s，TWAP ${duration}s`;
      }

      function renderParaTwapScheduler(scheduler) {
        if (!paraTwapScheduleStatus) {
          return;
        }

        const enabled = Boolean(scheduler?.enabled);
        const st = scheduler?.status || {};
        const tasks = _normalizeParaTwapSchedulerTasks(scheduler);

        // Keep an in-memory draft (so we can add/remove tasks before submitting).
        paraTwapSchedulerTasksDraft = tasks;
        const editingId = _getEditingTaskId();
        const editingTask = editingId ? tasks.find((t) => String(t.task_id) === String(editingId)) : null;
        if (editingId && !editingTask) {
          _setEditingTask(null);
        } else if (editingTask) {
          _setEditingTask(editingTask);
        }

        if (!enabled || !tasks.length) {
          paraTwapScheduleStatus.textContent = '未启用';
          renderParaTwapSchedulerHistory(st?.history);
          _renderParaTwapSchedulerTasksEditor(st);
          return;
        }

        const nextText = formatTs(st?.next_run_at);
        const lastText = formatTs(st?.last_run_at);
        const err = st?.last_error;
        const lastRid = st?.last_request_id;
        const timing = [lastText ? `上次：${lastText}` : null, nextText ? `下次：${nextText}` : null].filter(Boolean).join(' ｜ ');

        if (err) {
          paraTwapScheduleStatus.textContent = `已启用（共 ${tasks.length} 条任务）｜错误：${err}`;
        } else {
          paraTwapScheduleStatus.textContent = `已启用（共 ${tasks.length} 条任务）${timing ? ' ｜ ' + timing : ''}${lastRid ? ' ｜ 最近 request_id: ' + lastRid : ''}`;
        }

        _renderParaTwapSchedulerTasksEditor(st);
        renderParaTwapSchedulerHistory(st?.history);

      }

      function _renderParaTwapSchedulerTasksEditor(status) {
        // We reuse the existing status container to render a minimal task list editor
        // (no extra DOM ids required, safer for hotfix).
        const root = document.getElementById('paraTwapScheduleTasks') || null;
        if (!root) {
          return;
        }

        const tasks = Array.isArray(paraTwapSchedulerTasksDraft) ? paraTwapSchedulerTasksDraft : [];
        if (!tasks.length) {
          root.innerHTML = '<div class="muted">暂无任务，填表后点击“新增并保存”。</div>';
          return;
        }

        const nextRun = (t) => {
          // Prefer per-task next_run_at persisted from backend.
          const ts = t?.next_run_at;
          if (!ts) return '--';
          try {
            return new Date(Number(ts) * 1000).toLocaleString();
          } catch (_) {
            return '--';
          }
        };

        root.innerHTML = tasks.map((t, idx) => {
          const checked = t.enabled ? 'checked' : '';
          const scope = describeSymbolScope(t.symbols);
          const summary = _formatSchedulerTaskSummary(t);
          const editing = String(t.task_id) === String(_getEditingTaskId());
          const editingTag = editing ? '（编辑中）' : '';
          return `
            <div class="panel-row" style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:6px 0;">
              <label style="display:flex;align-items:center;gap:6px;">
                <input type="checkbox" data-ptwap-task-toggle="${escapeHtml(t.task_id)}" ${checked} />
                启用
              </label>
              <span style="min-width:240px;"><strong>${escapeHtml(summary + editingTag)}</strong></span>
              <span class="muted">范围：${escapeHtml(scope)}</span>
              <span class="muted">下次：${escapeHtml(nextRun(t))}</span>
              <button class="btn" data-ptwap-task-edit="${escapeHtml(t.task_id)}">编辑</button>
              <button class="btn" data-ptwap-task-fire="${escapeHtml(t.task_id)}">立即触发</button>
              <button class="btn btn-danger" data-ptwap-task-remove="${escapeHtml(t.task_id)}">删除</button>
            </div>
          `.trim();
        }).join('');
      }

      function renderParaTwapSchedulerHistory(history) {
        if (!paraTwapScheduleHistoryBody) {
          return;
        }
        const rows = [];
        const items = Array.isArray(history) ? history : [];
        if (!items.length) {
          paraTwapScheduleHistoryBody.innerHTML = '<tr><td colspan="8">暂无定时记录</td></tr>';
          return;
        }

        const requestList = Array.isArray(lastMetricsSnapshot?.para_adjustments?.requests)
          ? lastMetricsSnapshot.para_adjustments.requests
          : [];
        const requestMap = new Map();
        for (const req of requestList) {
          if (req && req.request_id) {
            requestMap.set(String(req.request_id), req);
          }
        }

        const safeText = (value) => {
          if (value === undefined || value === null) {
            return '--';
          }
          const text = String(value).trim();
          return text ? text : '--';
        };

        const formatMaybeNumber = (value, decimals = 6) => {
          if (value === undefined || value === null) {
            return '--';
          }
          const raw = String(value).trim();
          if (!raw) {
            return '--';
          }
          const parsed = Number(raw);
          if (!Number.isFinite(parsed)) {
            return raw;
          }
          const fixed = parsed.toFixed(Math.min(8, Math.max(0, decimals)));
          return fixed.replace(/\.0+$/, '').replace(/(\.[0-9]*?)0+$/, '$1');
        };

        const formatTs = (tsSeconds) => {
          const num = Number(tsSeconds);
          if (!Number.isFinite(num) || num <= 0) {
            return '--';
          }
          try {
            return new Date(num * 1000).toLocaleString();
          } catch (_) {
            return '--';
          }
        };

        const parseMsToText = (ms) => {
          const n = Number(ms);
          if (!Number.isFinite(n) || n <= 0) {
            return '--';
          }
          try {
            return new Date(n).toLocaleString();
          } catch (_) {
            return '--';
          }
        };

        const scopeFor = (symbols) => describeSymbolScope(symbols);

        const signatureFor = (cfg) => {
          const action = String(cfg?.action || '').toLowerCase();
          const magnitude = Number(cfg?.magnitude ?? 0);
          const interval = Number(cfg?.interval_seconds ?? 0);
          const duration = Number(cfg?.twap_duration_seconds ?? 0);
          const symbols = Array.isArray(cfg?.symbols) ? cfg.symbols.slice().sort() : [];
          return [action, magnitude, interval, duration, symbols.join(',')].join('|');
        };

        const aggregates = new Map();
        for (const item of items) {
          const cfg = (item?.config && typeof item.config === 'object') ? item.config : {};
          const roll = (item?.rollup && typeof item.rollup === 'object') ? item.rollup : {};
          const toNumber = (value) => {
            if (value === undefined || value === null) {
              return null;
            }
            const raw = String(value).trim();
            if (!raw) {
              return null;
            }
            const parsed = Number(raw);
            return Number.isFinite(parsed) ? parsed : null;
          };
          const pickNumber = (...values) => {
            for (const v of values) {
              const parsed = toNumber(v);
              if (parsed !== null) {
                return parsed;
              }
            }
            return null;
          };
          const computeRequestWear = (req) => {
            if (!req || typeof req !== 'object') {
              return null;
            }
            const agents = Array.isArray(req.agents) ? req.agents : [];
            const sortedAgents = agents
              .filter((agent) => agent && typeof agent === 'object')
              .slice()
              .sort((a, b) => String(a.agent_id || '').localeCompare(String(b.agent_id || '')))
              .slice(0, 2);
            const left = sortedAgents[0] || null;
            const right = sortedAgents[1] || null;
            if (!left || !right) {
              return null;
            }
            const aExtra = left.extra || {};
            const bExtra = right.extra || {};
            const aAvg = toNumber(aExtra?.avg_price);
            const bAvg = toNumber(bExtra?.avg_price);
            const aFilled = toNumber(aExtra?.filled_qty) ?? 0;
            const bFilled = toNumber(bExtra?.filled_qty) ?? 0;
            if (!Number.isFinite(aAvg) || !Number.isFinite(bAvg)) {
              return null;
            }
            const filledTotal = aFilled + bFilled;
            if (!(filledTotal > 0)) {
              return null;
            }
            const priceDiff = Math.abs(aAvg - bAvg);
            const wear = priceDiff * filledTotal;
            const notional = (aAvg * aFilled * 2) + (bAvg * bFilled * 2);
            if (!Number.isFinite(wear) || !Number.isFinite(notional) || notional <= 0) {
              return null;
            }
            return { wear, notional, filledTotal };
          };
          const key = signatureFor(cfg);
          const current = aggregates.get(key) || {
            created_at: item?.created_at ?? null,
            config: cfg,
            request_count: 0,
            completed: 0,
            filled_qty_total: 0,
            wear_total: 0,
            wear_qty_total: 0,
            notional_total: 0,
          };
          current.created_at = Math.min(Number(current.created_at || item?.created_at || 0) || 0, Number(item?.created_at || 0) || 0) || current.created_at;
          current.request_count += Number(roll.request_count ?? (Array.isArray(item?.request_ids) ? item.request_ids.length : 0)) || 0;
          current.completed += Number(roll.completed ?? 0) || 0;
          const requestIds = Array.isArray(item?.request_ids) ? item.request_ids : [];
          let reqWearTotal = 0;
          let reqNotionalTotal = 0;
          let reqFilledTotal = 0;
          let reqUsed = false;
          if (requestIds.length && requestMap.size) {
            for (const rid of requestIds) {
              const req = requestMap.get(String(rid));
              const wearSummary = computeRequestWear(req);
              if (wearSummary) {
                reqUsed = true;
                reqWearTotal += wearSummary.wear;
                reqNotionalTotal += wearSummary.notional;
                reqFilledTotal += wearSummary.filledTotal;
              }
            }
          }
          const filledQty = pickNumber(
            roll.filled_qty_total,
            roll.filled_qty,
            roll.qty_total,
            roll.qty
          ) ?? 0;
          const avgPrice = pickNumber(
            roll.avg_price,
            roll.avg_fill_price,
            roll.average_price
          );
          const wearTotalRaw = pickNumber(
            roll.wear_total,
            roll.wear_total_net,
            roll.wear_total_net_est,
            roll.wear
          );
          const wearQty = pickNumber(
            roll.wear_qty_total,
            roll.filled_qty_total,
            roll.filled_qty,
            roll.qty
          );
          const wearAvg = pickNumber(
            roll.wear_avg_per_unit,
            roll.wear_avg,
            roll.wear_per_unit
          );
          const wearTotal = reqUsed
            ? reqWearTotal
            : (wearTotalRaw ?? ((wearAvg != null && wearQty != null) ? (wearAvg * wearQty) : 0));
          const filledForAgg = reqUsed ? reqFilledTotal : filledQty;
          const notionalForAgg = reqUsed
            ? reqNotionalTotal
            : ((avgPrice != null && filledQty) ? (avgPrice * filledQty) : 0);
          current.filled_qty_total += filledForAgg;
          current.notional_total += Number.isFinite(notionalForAgg) ? notionalForAgg : 0;
          current.wear_total += Number.isFinite(wearTotal) ? wearTotal : 0;
          current.wear_qty_total += Number.isFinite(wearQty) ? wearQty : 0;
          aggregates.set(key, current);
        }

  const aggregatedList = Array.from(aggregates.values()).sort((a, b) => Number(b.created_at || 0) - Number(a.created_at || 0));
  const displayLimit = 20;
  const displayList = aggregatedList.slice(0, displayLimit);

  for (const item of displayList) {
          const cfg = item.config || {};
          const createdText = formatTs(item.created_at);
          const action = String(cfg?.action || '--').toLowerCase();
          const magnitude = formatMaybeNumber(cfg?.magnitude ?? '--', 6);
          const scope = scopeFor(cfg?.symbols);
          const requestCount = Number(item.request_count ?? 0);
          const completed = Number(item.completed ?? 0);
          const filledTotal = formatMaybeNumber(item.filled_qty_total ?? '--', 6);
          const wearTotal = formatMaybeNumber(item.wear_total ?? '--', 6);
          const wearPer10k = (item.notional_total ?? 0) > 0
            ? formatMaybeNumber((item.wear_total / item.notional_total) * 10000, 6)
            : '--';

          rows.push(`
            <tr>
              <td>${escapeHtml(createdText)}</td>
              <td>${escapeHtml(describeAdjustmentAction(action))}</td>
              <td>${escapeHtml(String(magnitude))}</td>
              <td>${escapeHtml(scope)}</td>
              <td title="完成 ${completed} / 批次 ${requestCount}">${escapeHtml(String(completed))}</td>
              <td>${escapeHtml(String(filledTotal))}</td>
              <td>${escapeHtml(String(wearPer10k))}</td>
              <td>${escapeHtml(String(wearTotal))}</td>
            </tr>
          `);
        }

        paraTwapScheduleHistoryBody.innerHTML = rows.join('');
      }

      async function refreshParaTwapScheduler() {
        try {
          const response = await fetch('/para/twap_scheduler/config');
          redirectIfUnauthorized(response);
          if (!response.ok) {
            return;
          }
          const data = await response.json();
          renderParaTwapScheduler(data);
        } catch (_) {
          // ignore
        }
      }

      async function submitParaTwapSchedulerConfig() {
        const interval = clampIntervalSeconds(paraTwapScheduleIntervalInput?.value ?? 900) || 900;
        const duration = clampTwapDurationSeconds(paraTwapScheduleDurationInput?.value ?? 900) || 900;
        const rawMagnitude = parseFloat(paraTwapScheduleSizeInput?.value ?? '1');
        const magnitude = Number.isFinite(rawMagnitude) && rawMagnitude > 0 ? rawMagnitude : 1;
        const action = (paraTwapScheduleActionSelect?.value || 'add').toLowerCase();

        // Build/patch task list: by default we update/create the first task from the form.
        const symbols = getSelectedSymbolsFromSelect(paraTwapScheduleSymbolsSelect);
        const draft = Array.isArray(paraTwapSchedulerTasksDraft) ? paraTwapSchedulerTasksDraft.slice() : [];
        const baseTask = {
          task_id: (draft[0] && draft[0].task_id) ? draft[0].task_id : null,
          enabled: true,
          action,
          magnitude,
          interval_seconds: interval,
          twap_duration_seconds: duration,
        };
        if (symbols) {
          baseTask.symbols = symbols;
        }
        if (draft.length) {
          draft[0] = { ...draft[0], ...baseTask };
        } else {
          draft.push(baseTask);
        }

        const payload = { enabled: true, tasks: draft };
        if (paraTwapScheduleStatus) {
          paraTwapScheduleStatus.textContent = '提交定时配置…';
        }
        try {
          const response = await fetch('/para/twap_scheduler/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const data = await response.json();
          renderParaTwapScheduler({ enabled: data?.enabled, tasks: data?.tasks, status: data?.status });
          await refreshMetrics();
        } catch (error) {
          if (paraTwapScheduleStatus) {
            paraTwapScheduleStatus.textContent = `提交失败：${error}`;
          }
        }
      }

      async function disableParaTwapScheduler() {
        if (paraTwapScheduleStatus) {
          paraTwapScheduleStatus.textContent = '停用中…';
        }
        try {
          const draft = Array.isArray(paraTwapSchedulerTasksDraft) ? paraTwapSchedulerTasksDraft.slice() : [];
          const paused = draft.map((t) => t ? { ...t, enabled: false } : t).filter(Boolean);
          const response = await fetch('/para/twap_scheduler/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'disable', enabled: false, tasks: paused }),
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          renderParaTwapScheduler({ enabled: false });
          await refreshMetrics();
        } catch (error) {
          if (paraTwapScheduleStatus) {
            paraTwapScheduleStatus.textContent = `停用失败：${error}`;
          }
        }
      }

      function _buildTaskFromForm() {
        const interval = clampIntervalSeconds(paraTwapScheduleIntervalInput?.value ?? 900) || 900;
        const duration = clampTwapDurationSeconds(paraTwapScheduleDurationInput?.value ?? 900) || 900;
        const rawMagnitude = parseFloat(paraTwapScheduleSizeInput?.value ?? '1');
        const magnitude = Number.isFinite(rawMagnitude) && rawMagnitude > 0 ? rawMagnitude : 1;
        const action = (paraTwapScheduleActionSelect?.value || 'add').toLowerCase();
        const symbols = getSelectedSymbolsFromSelect(paraTwapScheduleSymbolsSelect);
        if (!symbols || !symbols.length) {
          if (paraTwapScheduleStatus) {
            paraTwapScheduleStatus.textContent = '请先选择币种';
          }
          return null;
        }
        const task = {
          enabled: true,
          action,
          magnitude,
          interval_seconds: interval,
          twap_duration_seconds: duration,
          symbols,
        };
        return task;
      }

      async function _submitParaTwapSchedulerTasks(tasks) {
        const payload = { enabled: true, tasks };
        if (paraTwapScheduleStatus) {
          paraTwapScheduleStatus.textContent = '提交定时任务…';
        }
        const response = await fetch('/para/twap_scheduler/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        redirectIfUnauthorized(response);
        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || `HTTP ${response.status}`);
        }
        const data = await response.json();
        renderParaTwapScheduler({ enabled: data?.enabled, tasks: data?.tasks, status: data?.status });
        await refreshMetrics();
      }

      async function createParaTwapSchedulerTaskFromForm() {
        const draft = Array.isArray(paraTwapSchedulerTasksDraft) ? paraTwapSchedulerTasksDraft.slice() : [];
        const base = _buildTaskFromForm();
        if (!base) {
          return;
        }
        base.task_id = `task-${Date.now()}`;
        draft.push(base);
        await _submitParaTwapSchedulerTasks(draft);
        _setEditingTask(null);
      }

      async function saveEditedParaTwapSchedulerTask() {
        const editId = _getEditingTaskId();
        if (!editId) {
          if (paraTwapScheduleStatus) {
            paraTwapScheduleStatus.textContent = '请先在任务列表里点“编辑”';
          }
          return;
        }
        const formTask = _buildTaskFromForm();
        if (!formTask) {
          return;
        }
        const draft = Array.isArray(paraTwapSchedulerTasksDraft) ? paraTwapSchedulerTasksDraft.slice() : [];
        const idx = draft.findIndex((t) => t && String(t.task_id) === String(editId));
        if (idx < 0) {
          if (paraTwapScheduleStatus) {
            paraTwapScheduleStatus.textContent = '找不到要保存的任务';
          }
          _setEditingTask(null);
          return;
        }
        const existing = draft[idx] || {};
        draft[idx] = { ...existing, ...formTask, task_id: existing?.task_id || editId };
        await _submitParaTwapSchedulerTasks(draft);
      }

      async function fireParaTwapSchedulerTaskNow(taskId) {
        const draft = Array.isArray(paraTwapSchedulerTasksDraft) ? paraTwapSchedulerTasksDraft.slice() : [];
        const now = Date.now() / 1000;
        const updated = draft.map((t) => {
          if (!t || String(t.task_id) !== String(taskId)) {
            return t;
          }
          return { ...t, enabled: true, next_run_at: now };
        });
        await _submitParaTwapSchedulerTasks(updated);
      }

      async function toggleParaTwapSchedulerTask(taskId, enabled) {
        const draft = Array.isArray(paraTwapSchedulerTasksDraft) ? paraTwapSchedulerTasksDraft.slice() : [];
        const updated = draft.map((t) => {
          if (!t || String(t.task_id) !== String(taskId)) {
            return t;
          }
          const next = { ...t, enabled: Boolean(enabled) };
          // When turning on, fire immediately unless it already has a next_run.
          if (enabled && (next.next_run_at === null || next.next_run_at === undefined)) {
            next.next_run_at = Date.now() / 1000;
          }
          return next;
        });
        await _submitParaTwapSchedulerTasks(updated);
      }

      async function removeParaTwapSchedulerTask(taskId) {
        const draft = Array.isArray(paraTwapSchedulerTasksDraft) ? paraTwapSchedulerTasksDraft.slice() : [];
        const updated = draft.filter((t) => t && String(t.task_id) !== String(taskId));
        if (String(_getEditingTaskId() || '') === String(taskId)) {
          _setEditingTask(null);
        }
        if (!updated.length) {
          // Removing last task: submit empty list (clear).
          await _submitParaTwapSchedulerTasks([]);
          return;
        }
        await _submitParaTwapSchedulerTasks(updated);
      }

      function updateTwapVisibility() {
  const mode = (paraOrderModeSelect?.value || 'twap').toLowerCase();
        if (paraTwapDurationWrapper) {
          paraTwapDurationWrapper.style.display = mode === 'twap' ? 'block' : 'none';
        }
      }

      async function sendParaAdjustment(action) {
        if (!action || paraAdjustLocked) {
          return;
        }
        const rawMagnitude = parseFloat(paraAdjustSizeInput?.value ?? '1');
        const magnitude = Number.isFinite(rawMagnitude) && rawMagnitude > 0 ? rawMagnitude : 1;
        paraAdjustLocked = true;
        updateParaAdjustButtons();
        if (paraAdjustStatus) {
          paraAdjustStatus.textContent = `提交${describeAdjustmentAction(action)}请求…`;
        }

        const payload = { action, magnitude };
        const symbols = getSelectedParaSymbols();
        if (symbols) {
          payload.symbols = symbols;
        }

  const orderMode = (paraOrderModeSelect?.value || 'twap').toLowerCase();
        if (orderMode === 'twap') {
          const duration = clampTwapDurationSeconds(paraTwapDurationInput?.value ?? 0) || 900;
          payload.order_mode = 'twap';
          payload.twap_duration_seconds = duration;
        } else {
          payload.order_mode = 'market';
        }

        try {
          const response = await fetch('/para/adjust', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const responsePayload = await response.json();
          paraPendingRequestId = responsePayload?.request?.request_id ?? null;
          if (paraAdjustStatus) {
            paraAdjustStatus.textContent = '等待 VPS ACK…';
          }
          await refreshMetrics();
        } catch (error) {
          paraAdjustLocked = false;
          updateParaAdjustButtons();
          if (paraAdjustStatus) {
            paraAdjustStatus.textContent = `请求失败：${error}`;
          }
        }
      }

      function renderParaAdjustments(summary) {
        if (!paraAdjustPanel || !paraAdjustHistoryBody) {
          return;
        }
        renderParaTransferHistory(summary);
        const allRequests = Array.isArray(summary?.requests) ? summary.requests : [];
        const adjustmentRequests = allRequests.filter((request) => (request?.action || '').toLowerCase() !== 'transfer');
        const active = summary?.active_request;
        const activeIsAdjustment = (active?.action || '').toLowerCase() !== 'transfer';
        const effectiveActive = activeIsAdjustment ? active : null;
        let locked = false;

        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const scopeFor = (request) => describeSymbolScope(request?.target_symbols ?? request?.symbols);

        if (effectiveActive && ['pending', 'in_progress'].includes(normalizeStatus(effectiveActive.overall_status))) {
          locked = true;
          paraPendingRequestId = effectiveActive.request_id || null;
          const agents = Array.isArray(effectiveActive.agents) ? effectiveActive.agents : [];
          const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
          if (paraAdjustStatus) {
            const total = agents.length || 0;
            const pendingCount = pendingAgents.length;
            const scopeText = scopeFor(effectiveActive);
            paraAdjustStatus.textContent = `等待 ${pendingCount}/${total || '-'} 个 VPS ACK（${scopeText}）`;
          }
        } else if (adjustmentRequests.length) {
          const latest = adjustmentRequests[0];
          const statusText = normalizeStatus(latest.overall_status || 'pending');
          if (['pending', 'in_progress'].includes(statusText)) {
            locked = true;
            paraPendingRequestId = latest.request_id || null;
            const agents = Array.isArray(latest.agents) ? latest.agents : [];
            const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
            if (paraAdjustStatus) {
              const scopeText = scopeFor(latest);
              paraAdjustStatus.textContent = `等待 ${pendingAgents.length}/${agents.length || '-'} 个 VPS ACK（${scopeText}）`;
            }
          } else if (paraAdjustStatus) {
            const scopeText = scopeFor(latest);
            if (statusText === 'completed') {
              paraAdjustStatus.textContent = `最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）已完成`;
            } else if (statusText === 'failed') {
              paraAdjustStatus.textContent = `最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）部分失败`;
            } else {
              paraAdjustStatus.textContent = `最近状态：${statusText}（${scopeText}）`;
            }
          }
        } else if (paraAdjustStatus) {
          paraAdjustStatus.textContent = '等待指令…（默认全部币种）';
        }

        paraAdjustLocked = locked;
        if (!locked) {
          paraPendingRequestId = null;
        }
        updateParaAdjustButtons();

        if (!adjustmentRequests.length) {
          paraAdjustHistoryBody.innerHTML = '<tr><td colspan="9">暂无广播记录</td></tr>';
        } else {
          const historyRows = [];

          const safeText = (value) => {
            if (value === undefined || value === null) {
              return '--';
            }
            const text = String(value).trim();
            return text ? text : '--';
          };

          const pickExtraField = (extra, key) => {
            if (!extra || typeof extra !== 'object') {
              return '--';
            }
            return safeText(extra[key]);
          };

          const formatMaybeNumber = (value, decimals = 4) => {
            if (value === undefined || value === null) {
              return '--';
            }
            const raw = String(value).trim();
            if (!raw) {
              return '--';
            }
            const parsed = Number(raw);
            if (!Number.isFinite(parsed)) {
              return raw;
            }
            // Keep a reasonable precision for prices; trim trailing zeros.
            const fixed = parsed.toFixed(Math.min(6, Math.max(0, decimals)));
            return fixed.replace(/\.0+$/, '').replace(/(\.[0-9]*?)0+$/, '$1');
          };

          const buildAgentBadges = (agents) => agents
            .map((agent) => {
              const status = normalizeStatus(agent.status || 'pending');
              const label = escapeHtml(agent.agent_id || 'agent');
              const cls = status === 'completed'
                ? 'badge-success'
                : status === 'failed'
                  ? 'badge-danger'
                  : 'badge-muted';
              return `<span class="badge ${cls}" title="${escapeHtml(status)}">${label}</span>`;
            })
            .join(' ');

          const renderAgentDetailFields = (agent) => {
            if (!agent || typeof agent !== 'object') {
              return {
                agentId: '--',
                orderType: '--',
                avgPrice: '--',
                filledQty: '--'
              };
            }
            const extra = agent.extra;
            return {
              agentId: safeText(agent.agent_id),
              orderType: pickExtraField(extra, 'order_type'),
              avgPrice: formatMaybeNumber(extra?.avg_price, 5),
              filledQty: pickExtraField(extra, 'filled_qty')
            };
          };

          const normalizeEpochMs = (value) => {
            if (value === undefined || value === null) {
              return null;
            }
            const n = Number(value);
            if (!Number.isFinite(n) || n <= 0) {
              return null;
            }
            // Heuristic: seconds vs milliseconds.
            return n < 10_000_000_000 ? Math.round(n * 1000) : Math.round(n);
          };

          const formatDuration = (ms) => {
            if (!Number.isFinite(ms) || ms < 0) {
              return '--';
            }
            const totalSeconds = Math.round(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            if (minutes <= 0) {
              return `${seconds}s`;
            }
            return `${minutes}m${String(seconds).padStart(2, '0')}s`;
          };

          for (const request of adjustmentRequests.slice(0, 20)) {
            const statusText = request.overall_status || 'pending';
            const createdText = formatTimestamp(request.created_at) ?? '--';
            const agents = Array.isArray(request.agents) ? request.agents : [];
            const scopeText = scopeFor(request);
            const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
            const failedAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'failed');
            const statusMeta = [];
            if (pendingAgents.length) {
              statusMeta.push(`待ACK ${pendingAgents.length}`);
            }
            if (failedAgents.length) {
              statusMeta.push(`失败 ${failedAgents.length}`);
            }
            const statusCombined = statusMeta.length ? `${statusText}（${statusMeta.join(' / ')}）` : statusText;

            const badges = buildAgentBadges(agents);

            const sortedAgents = agents
              .filter((agent) => agent && typeof agent === 'object')
              .slice()
              .sort((a, b) => String(a.agent_id || '').localeCompare(String(b.agent_id || '')))
              .slice(0, 2);

            const leftAgent = sortedAgents[0] || null;
            const rightAgent = sortedAgents[1] || null;

            const left = renderAgentDetailFields(leftAgent);
            const right = renderAgentDetailFields(rightAgent);

            const nodeSummaryParts = [];
            if (leftAgent) {
              nodeSummaryParts.push(`${escapeHtml(left.agentId)} (${escapeHtml(safeText(leftAgent.status))})`);
            }
            if (rightAgent) {
              nodeSummaryParts.push(`${escapeHtml(right.agentId)} (${escapeHtml(safeText(rightAgent.status))})`);
            }
            const nodeSummary = nodeSummaryParts.length ? nodeSummaryParts.join(' · ') : (badges || '—');

            // Request-level order mode: if any agent reports TWAP then treat as TWAP.
            const orderModes = sortedAgents
              .map((agent) => pickExtraField(agent?.extra, 'order_type'))
              .filter((v) => v && v !== '--')
              .map((v) => String(v).toUpperCase());
            const orderModeText = orderModes.includes('TWAP')
              ? 'TWAP'
              : orderModes.length
                ? orderModes[0]
                : '市价';

            // Timing derived from TWAP history timestamps (if present in agent.extra)
            // 时间 = last_updated_at - created_at
            // 持续时间 = end_at - created_at
            const findFirstTimestamp = (keys) => {
              for (const agent of agents) {
                const extra = agent?.extra;
                if (!extra || typeof extra !== 'object') {
                  continue;
                }
                for (const key of keys) {
                  const v = normalizeEpochMs(extra[key]);
                  if (v) {
                    return v;
                  }
                }
              }
              return null;
            };

            const createdAtMs = findFirstTimestamp(['created_at']);
            const lastUpdatedAtMs = findFirstTimestamp(['last_updated_at', 'updated_at']);
            const endAtMs = findFirstTimestamp(['end_at']);

            const deltaUpdated = (createdAtMs && lastUpdatedAtMs) ? (lastUpdatedAtMs - createdAtMs) : null;
            const deltaEnd = (createdAtMs && endAtMs) ? (endAtMs - createdAtMs) : null;
            const timeText = deltaUpdated === null ? '--' : formatDuration(deltaUpdated);
            const durationText = deltaEnd === null ? '--' : formatDuration(deltaEnd);

            // Row 1: summary + merged node cell (colspan=4)
            historyRows.push(`
              <tr class="adjust-group-top">
                <td>${escapeHtml(createdText)}</td>
                <td>${escapeHtml(describeAdjustmentAction(request.action))}</td>
                <td>${escapeHtml(String(request.magnitude ?? '--'))}</td>
                <td>${escapeHtml(scopeText)}</td>
                <td>${escapeHtml(statusCombined)}</td>
                <td colspan="4" style="text-align:center;">
                  <span style="color:#8a94a6; margin-right:0.5rem;">${escapeHtml(orderModeText)}</span>
                  <span style="color:#8a94a6; margin-right:0.5rem;">时间</span>
                  <span style="margin-right:0.75rem; font-variant-numeric:tabular-nums;">${escapeHtml(timeText)}</span>
                  <span style="color:#8a94a6; margin-right:0.5rem;">持续时间</span>
                  <span style="margin-right:0.75rem; font-variant-numeric:tabular-nums;">${escapeHtml(durationText)}</span>
                </td>
              </tr>
            `);

            // Row 2: only per-VPS differing fields (both VPS rendered inside one row)

            const filledDisplay = (filled, total) => {
              const f = safeText(filled);
              const t = safeText(total);
              if (f === '--' && t === '--') {
                return '--';
              }
              return `${f}/${t}`;
            };

            const resolveReportedTotalQty = (agent) => {
              const extra = agent?.extra;
              if (!extra || typeof extra !== 'object') {
                return null;
              }
              // Prefer backend-reported total size for TWAP.
              const explicitSize = extra.algo_size ?? extra.algo_expected_size ?? extra.total_qty ?? extra.target_qty;
              if (explicitSize !== undefined && explicitSize !== null && String(explicitSize).trim() !== '') {
                return explicitSize;
              }
              // Derive total when remaining + filled are provided.
              const filledRaw = extra.filled_qty;
              const remainingRaw = extra.algo_remaining_size;
              const filledNum = Number(String(filledRaw ?? '').trim());
              const remainingNum = Number(String(remainingRaw ?? '').trim());
              if (Number.isFinite(filledNum) && Number.isFinite(remainingNum)) {
                const totalNum = filledNum + remainingNum;
                if (Number.isFinite(totalNum)) {
                  return formatMaybeNumber(totalNum, 6);
                }
              }
              return null;
            };

            const renderDetailCard = (agent) => `
              <div style="padding:0.1rem 0;">
                <div style="display:flex; justify-content:space-between; gap:0.5rem; align-items:baseline;">
                  <div><strong>${escapeHtml(agent.agentId)}</strong></div>
                </div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:0.35rem 0.75rem; margin-top:0.25rem; font-variant-numeric:tabular-nums;">
                  <div><span style="color:#8a94a6;">均价</span> ${escapeHtml(agent.avgPrice)}</div>
                  <div><span style="color:#8a94a6;">成交</span> ${escapeHtml(agent.filledText)}</div>
                </div>
              </div>
            `;

            const parseMaybeNumber = (value) => {
              if (value === undefined || value === null) {
                return null;
              }
              const n = Number(String(value).trim());
              return Number.isFinite(n) ? n : null;
            };

            // User-defined wear formula (frontend-only):
            // - 成交额 = 均价 * 已成交 * 2
            // - 磨损 = 均价差值(abs) * 成交
            // - 均价差值 = 两个 VPS 均价之差(abs)
            const computeFrontendWearSummary = (a, b) => {
              const aExtra = a?.extra;
              const bExtra = b?.extra;
              const aAvg = parseMaybeNumber(aExtra?.avg_price);
              const bAvg = parseMaybeNumber(bExtra?.avg_price);
              const aFilled = parseMaybeNumber(aExtra?.filled_qty);
              const bFilled = parseMaybeNumber(bExtra?.filled_qty);

              // Need both avg prices to compute price diff.
              if (!Number.isFinite(aAvg) || !Number.isFinite(bAvg)) {
                return null;
              }
              const priceDiff = Math.abs(aAvg - bAvg);

              // For totals, if one side missing filled_qty, treat it as 0.
              const filledA = Number.isFinite(aFilled) ? aFilled : 0;
              const filledB = Number.isFinite(bFilled) ? bFilled : 0;
              const filledTotal = filledA + filledB;
              if (!Number.isFinite(filledTotal) || filledTotal <= 0) {
                return null;
              }

              // 成交额用各自均价计算（合计）：sum(avg_i * filled_i * 2)
              const notional = (aAvg * filledA * 2) + (bAvg * filledB * 2);
              if (!Number.isFinite(notional) || notional <= 0) {
                return null;
              }

              // 磨损：均价差值 * 成交（这里用合计成交量）
              const wear = priceDiff * filledTotal;
              if (!Number.isFinite(wear)) {
                return null;
              }

              // 每万成交额磨损
              const per10k = (wear / notional) * 10000;

              return {
                priceDiff,
                filledTotal,
                notional,
                wear,
                per10k,
              };
            };

            const wearSummary = computeFrontendWearSummary(leftAgent, rightAgent);
            const wearText = wearSummary ? `${formatMaybeNumber(wearSummary.per10k, 4)}/万 (合计)` : '--';

            const leftCard = renderDetailCard({
              agentId: left.agentId,
              orderType: left.orderType,
              avgPrice: left.avgPrice,
              filledText: filledDisplay(left.filledQty, resolveReportedTotalQty(leftAgent))
            });
            const rightCard = renderDetailCard({
              agentId: right.agentId,
              orderType: right.orderType,
              avgPrice: right.avgPrice,
              filledText: filledDisplay(right.filledQty, resolveReportedTotalQty(rightAgent))
            });

            historyRows.push(`
              <tr class="adjust-group-bottom">
                <td>↳</td>
                <td colspan="4" style="color:#8a94a6;">
                  <span>VPS 详情</span>
                  <span style="margin-left:0.6rem; font-variant-numeric:tabular-nums;">
                    <span style="margin-right:0.25rem;">磨损</span>
                    <span style="color:#c9d1d9;">${escapeHtml(wearText)}</span>
                  </span>
                </td>
                <td colspan="4">
                  <div style="display:grid; grid-template-columns: 1fr 1fr; gap:0.75rem;">
                    <div style="border-right:1px solid rgba(255,255,255,0.05); padding-right:0.75rem;">${leftCard}</div>
                    <div style="padding-left:0.25rem;">${rightCard}</div>
                  </div>
                </td>
              </tr>
            `);
          }
          paraAdjustHistoryBody.innerHTML = historyRows.join('');
        }
      }

      function updateGrvtAdjustButtons() {
        const hasSymbols = !!getSelectedGrvtSymbols();
        const disabled = grvtAdjustLocked || !hasSymbols;
        [grvtAdjustAddButton, grvtAdjustReduceButton].forEach((button) => {
          if (button) {
            button.disabled = disabled;
          }
        });
        if (grvtAdjustStatus && !grvtAdjustLocked) {
          grvtAdjustStatus.textContent = hasSymbols ? '等待指令…' : '请选择币种后再提交';
        }
      }

      async function sendGrvtAdjustment(action) {
        if (!action || grvtAdjustLocked) {
          return;
        }
        const rawMagnitude = parseFloat(grvtAdjustSizeInput?.value ?? '1');
        const magnitude = Number.isFinite(rawMagnitude) && rawMagnitude > 0 ? rawMagnitude : 1;
        grvtAdjustLocked = true;
        updateGrvtAdjustButtons();
        if (grvtAdjustStatus) {
          grvtAdjustStatus.textContent = `提交${describeAdjustmentAction(action)}请求…`;
        }

        const selectedSymbols = getSelectedGrvtSymbols();
        if (!selectedSymbols || !selectedSymbols.length) {
          grvtAdjustLocked = false;
          updateGrvtAdjustButtons();
          if (grvtAdjustStatus) {
            grvtAdjustStatus.textContent = '请选择币种后再提交';
          }
          return;
        }
        const payload = { action, magnitude, symbols: selectedSymbols };

        try {
          const response = await fetch('/grvt/adjust', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            const text = await response.text();
            throw new Error(text || `HTTP ${response.status}`);
          }
          const responsePayload = await response.json();
          grvtPendingRequestId = responsePayload?.request?.request_id ?? null;
          if (grvtAdjustStatus) {
            grvtAdjustStatus.textContent = '等待 VPS ACK…';
          }
          await refreshMetrics();
        } catch (error) {
          grvtAdjustLocked = false;
          updateGrvtAdjustButtons();
          if (grvtAdjustStatus) {
            grvtAdjustStatus.textContent = `请求失败：${error}`;
          }
        }
      }

      function renderGrvtAdjustments(summary) {
        if (!grvtAdjustPanel || !grvtAdjustHistoryBody) {
          return;
        }
        const allRequests = Array.isArray(summary?.requests) ? summary.requests : [];
        const adjustmentRequests = allRequests.filter((request) => (request?.action || '').toLowerCase() !== 'transfer');
        const active = summary?.active_request;
        const activeIsAdjustment = (active?.action || '').toLowerCase() !== 'transfer';
        const effectiveActive = activeIsAdjustment ? active : null;
        let locked = false;

        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const scopeFor = (request) => describeSymbolScope(request?.target_symbols ?? request?.symbols);
        const resolveAgentsText = (request) => {
          const agents = Array.isArray(request?.agents) ? request.agents : [];
          const ids = agents
            .map((agent) => agent?.agent_id ?? agent?.agentId ?? agent?.id)
            .filter((value) => value && String(value).trim())
            .map((value) => String(value).trim());
          return ids.length ? ids.join(', ') : 'GRVT 监控';
        };

        if (effectiveActive && ['pending', 'in_progress'].includes(normalizeStatus(effectiveActive.overall_status))) {
            locked = true;
            grvtPendingRequestId = effectiveActive.request_id || null;
            const agents = Array.isArray(effectiveActive.agents) ? effectiveActive.agents : [];
            const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
            if (grvtAdjustStatus) {
              const total = agents.length || 0;
              const pendingCount = pendingAgents.length;
              const scopeText = scopeFor(effectiveActive);
              grvtAdjustStatus.textContent = `等待 ${pendingCount}/${total || '-'} 个 VPS ACK（${scopeText}）`;
            }
            if (grvtAdjustScope) {
              grvtAdjustScope.textContent = `当前广播：${resolveAgentsText(effectiveActive)}`;
            }
        } else if (adjustmentRequests.length) {
          const latest = adjustmentRequests[0];
          const statusText = normalizeStatus(latest.overall_status || 'pending');
          if (['pending', 'in_progress'].includes(statusText)) {
            locked = true;
            grvtPendingRequestId = latest.request_id || null;
            const agents = Array.isArray(latest.agents) ? latest.agents : [];
            const pendingAgents = agents.filter((agent) => normalizeStatus(agent.status) === 'pending');
            if (grvtAdjustStatus) {
              const scopeText = scopeFor(latest);
              grvtAdjustStatus.textContent = `等待 ${pendingAgents.length}/${agents.length || '-'} 个 VPS ACK（${scopeText}）`;
            }
            if (grvtAdjustScope) {
              grvtAdjustScope.textContent = `当前广播：${resolveAgentsText(latest)}`;
            }
          } else if (grvtAdjustStatus) {
            const scopeText = scopeFor(latest);
            if (statusText === 'completed') {
              grvtAdjustStatus.textContent = `最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）已完成`;
            } else if (statusText === 'failed') {
              grvtAdjustStatus.textContent = `最近一次 ${describeAdjustmentAction(latest.action)}（${scopeText}）部分失败`;
            } else {
              grvtAdjustStatus.textContent = `最近状态：${statusText}（${scopeText}）`;
            }
            if (grvtAdjustScope) {
              grvtAdjustScope.textContent = `当前广播：${resolveAgentsText(latest)}`;
            }
          }
        } else if (grvtAdjustStatus) {
          grvtAdjustStatus.textContent = '请选择币种后再提交';
          if (grvtAdjustScope) {
            grvtAdjustScope.textContent = '当前广播：GRVT 监控';
          }
        }

        grvtAdjustLocked = locked;
        if (!locked) {
          grvtPendingRequestId = null;
        }
        updateGrvtAdjustButtons();

        if (!adjustmentRequests.length) {
          grvtAdjustHistoryBody.innerHTML = '<tr><td colspan="6">暂无广播记录</td></tr>';
        } else {
          const historyRows = [];
          for (const request of adjustmentRequests.slice(0, 20)) {
            const statusText = request.overall_status || 'pending';
            const createdText = formatTimestamp(request.created_at) ?? '--';
            const agents = Array.isArray(request.agents) ? request.agents : [];
            const scopeText = scopeFor(request);
            const badges = agents
              .map((agent) => {
                const status = normalizeStatus(agent.status || 'pending');
                const label = escapeHtml(agent.agent_id || 'agent');
                let icon = '⏳';
                if (status === 'acknowledged') {
                  icon = '✅';
                } else if (status === 'failed') {
                  icon = '⚠️';
                } else if (status === 'expired') {
                  icon = '⌛';
                }
                const cls = `adjust-badge status-${status}`;
                return `<span class="${cls}">${icon} ${label}</span>`;
              })
              .join(' ');

            historyRows.push(`
            <tr>
              <td>${escapeHtml(createdText)}</td>
              <td>${escapeHtml(describeAdjustmentAction(request.action))}</td>
              <td>${escapeHtml(numberFormatter.format(toNumber(request.magnitude ?? 0)))}</td>
              <td>${escapeHtml(scopeText)}</td>
              <td>${escapeHtml(statusText)}</td>
              <td>${badges || '—'}</td>
            </tr>
          `);
          }

          grvtAdjustHistoryBody.innerHTML = historyRows.join('');
        }
        renderGrvtTransferHistory(summary);
      }

      // Backpack: match PARA-style adjustment history layout (grouped summary + VPS details).
      function renderBpAdjustmentsTableStyle(adjustmentRequests, { scopeFor }) {
        if (!bpAdjustHistoryBody) {
          return;
        }
        if (!adjustmentRequests.length) {
          bpAdjustHistoryBody.innerHTML = '<tr><td colspan="9">暂无广播记录</td></tr>';
          return;
        }

        const normalizeStatus = (value) => String(value || '').toLowerCase();
        const safeText = (value) => {
          if (value === undefined || value === null) {
            return '--';
          }
          const text = String(value).trim();
          return text ? text : '--';
        };
        const pickExtraField = (extra, key) => {
          if (!extra || typeof extra !== 'object') {
            return '--';
          }
          return safeText(extra[key]);
        };
        const formatMaybeNumber = (value, decimals = 4) => {
          if (value === undefined || value === null) {
            return '--';
          }
          const raw = String(value).trim();
          if (!raw) {
            return '--';
          }
          const parsed = Number(raw);
          if (!Number.isFinite(parsed)) {
            return raw;
          }
          const fixed = parsed.toFixed(Math.min(6, Math.max(0, decimals)));
          return fixed.replace(/\.0+$/, '').replace(/(\.[0-9]*?)0+$/, '$1');
        };

        const normalizeEpochMs = (value) => {
          if (value === undefined || value === null) {
            return null;
          }
          const n = Number(value);
          if (!Number.isFinite(n) || n <= 0) {
            return null;
          }
          return n < 10_000_000_000 ? Math.round(n * 1000) : Math.round(n);
        };
        const formatDuration = (ms) => {
          if (!Number.isFinite(ms) || ms < 0) {
            return '--';
          }
          const totalSeconds = Math.round(ms / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          if (minutes <= 0) {
            return `${seconds}s`;
          }
          return `${minutes}m${String(seconds).padStart(2, '0')}s`;
        };

        const parseMaybeNumber = (value) => {
          if (value === undefined || value === null) {
            return null;
          }
          const n = Number(String(value).trim());
          return Number.isFinite(n) ? n : null;
        };

        const computeFrontendWearSummary = (a, b) => {
          const aExtra = a?.extra;
          const bExtra = b?.extra;
          const aAvg = parseMaybeNumber(aExtra?.avg_price);
          const bAvg = parseMaybeNumber(bExtra?.avg_price);
          const aFilled = parseMaybeNumber(aExtra?.filled_qty);
          const bFilled = parseMaybeNumber(bExtra?.filled_qty);
          if (!Number.isFinite(aAvg) || !Number.isFinite(bAvg)) {
            return null;
          }
          const priceDiff = Math.abs(aAvg - bAvg);
          const filledA = Number.isFinite(aFilled) ? aFilled : 0;
          const filledB = Number.isFinite(bFilled) ? bFilled : 0;
          const filledTotal = filledA + filledB;
          if (!Number.isFinite(filledTotal) || filledTotal <= 0) {
            return null;
          }
          const notional = (aAvg * filledA * 2) + (bAvg * filledB * 2);
          if (!Number.isFinite(notional) || notional <= 0) {
            return null;
          }
          const wear = priceDiff * filledTotal;
          if (!Number.isFinite(wear)) {
            return null;
          }
          const per10k = (wear / notional) * 10000;
          return { priceDiff, filledTotal, notional, wear, per10k };
        };

        const resolveReportedTotalQty = (agent) => {
          const extra = agent?.extra;
          if (!extra || typeof extra !== 'object') {
            return null;
          }
          const explicitSize = extra.algo_size ?? extra.algo_expected_size ?? extra.total_qty ?? extra.target_qty;
          if (explicitSize !== undefined && explicitSize !== null && String(explicitSize).trim() !== '') {
            return explicitSize;
          }
          const filledRaw = extra.filled_qty;
          const remainingRaw = extra.algo_remaining_size;
          const filledNum = Number(String(filledRaw ?? '').trim());
          const remainingNum = Number(String(remainingRaw ?? '').trim());
          if (Number.isFinite(filledNum) && Number.isFinite(remainingNum)) {
            const totalNum = filledNum + remainingNum;
            if (Number.isFinite(totalNum)) {
              return formatMaybeNumber(totalNum, 6);
            }
          }
          return null;
        };

        const filledDisplay = (filled, total) => {
          const f = safeText(filled);
          const t = safeText(total);
          if (f === '--' && t === '--') {
            return '--';
          }
          return `${f}/${t}`;
        };

        const renderAgentDetailFields = (agent) => {
          const extra = agent?.extra;
          const progress = extra?.progress;
          // Backpack monitor uses extra.progress for TWAP progress; keep it compact.
          const executed = progress?.executedQuantity ?? progress?.executed_qty ?? extra?.executed_qty;
          const expected = progress?.expectedQuantity ?? progress?.expected_qty ?? extra?.algo_expected_size ?? extra?.algo_size ?? extra?.total_qty;
          const elapsed = progress?.elapsed_s ?? progress?.elapsedSec;

          let progressText = '--';
          if (executed !== undefined || expected !== undefined || elapsed !== undefined) {
            const execText = (executed === undefined || executed === null || String(executed).trim() === '') ? '--' : formatMaybeNumber(executed, 6);
            const expText = (expected === undefined || expected === null || String(expected).trim() === '') ? '--' : formatMaybeNumber(expected, 6);
            const pct = (() => {
              const eN = parseMaybeNumber(executed);
              const xN = parseMaybeNumber(expected);
              if (Number.isFinite(eN) && Number.isFinite(xN) && xN > 0) {
                return Math.max(0, Math.min(100, (eN / xN) * 100));
              }
              return null;
            })();
            const pctText = pct === null ? '' : ` · ${formatMaybeNumber(pct, 1)}%`;
            const elapsedText = elapsed === undefined || elapsed === null ? '' : ` · ${formatMaybeNumber(elapsed, 0)}s`;
            progressText = `${execText}/${expText}${pctText}${elapsedText}`;
          }

          return {
            agentId: safeText(agent?.agent_id),
            status: safeText(agent?.status),
            orderType: pickExtraField(extra, 'order_type'),
            avgPrice: formatMaybeNumber(extra?.avg_price, 5),
            filledQty: pickExtraField(extra, 'filled_qty'),
            progressText,
          };
        };

        const renderDetailCard = (agentDetail, agentRaw) => {
          const totalQty = resolveReportedTotalQty(agentRaw);
          return `
            <div style="padding:0.1rem 0;">
              <div style="display:flex; justify-content:space-between; gap:0.5rem; align-items:baseline;">
                <div><strong>${escapeHtml(agentDetail.agentId)}</strong></div>
                <div style="color:#8a94a6; font-size:0.72rem;">${escapeHtml(agentDetail.status)}</div>
              </div>
              <div style="display:grid; grid-template-columns: 1fr 1fr; gap:0.35rem 0.75rem; margin-top:0.25rem; font-variant-numeric:tabular-nums;">
                <div><span style="color:#8a94a6;">均价</span> ${escapeHtml(agentDetail.avgPrice)}</div>
                <div><span style="color:#8a94a6;">成交</span> ${escapeHtml(filledDisplay(agentDetail.filledQty, totalQty))}</div>
              </div>
              <div style="margin-top:0.2rem; font-variant-numeric:tabular-nums;">
                <span style="color:#8a94a6;">进度</span> <span style="color:#c9d1d9;">${escapeHtml(agentDetail.progressText)}</span>
              </div>
            </div>
          `;
        };

        const historyRows = [];
        for (const request of adjustmentRequests.slice(0, 20)) {
          const createdText = formatTimestamp(request.created_at) ?? '--';
          const agents = Array.isArray(request.agents) ? request.agents : [];
          const scopeText = scopeFor(request);
          const statusText = normalizeStatus(request.overall_status || request.status || 'pending');

          const pendingAgents = agents.filter((agent) => ['pending', 'in_progress', 'running'].includes(normalizeStatus(agent?.status)));
          const failedAgents = agents.filter((agent) => normalizeStatus(agent?.status) === 'failed');
          const statusMeta = [];
          if (pendingAgents.length) statusMeta.push(`未完成 ${pendingAgents.length}`);
          if (failedAgents.length) statusMeta.push(`失败 ${failedAgents.length}`);
          const statusCombined = statusMeta.length ? `${statusText}（${statusMeta.join(' / ')}）` : statusText;

          const sortedAgents = agents
            .filter((agent) => agent && typeof agent === 'object')
            .slice()
            .sort((a, b) => String(a.agent_id || '').localeCompare(String(b.agent_id || '')));

          const leftAgent = sortedAgents[0] || null;
          const rightAgent = sortedAgents[1] || null;
          const left = leftAgent ? renderAgentDetailFields(leftAgent) : null;
          const right = rightAgent ? renderAgentDetailFields(rightAgent) : null;

          const orderModes = sortedAgents
            .map((agent) => pickExtraField(agent?.extra, 'order_type'))
            .filter((v) => v && v !== '--')
            .map((v) => String(v).toUpperCase());
          const orderModeText = orderModes.includes('TWAP')
            ? 'TWAP'
            : orderModes.length
              ? orderModes[0]
              : '市价';

          const findFirstTimestamp = (keys) => {
            for (const agent of agents) {
              const extra = agent?.extra;
              if (!extra || typeof extra !== 'object') {
                continue;
              }
              for (const key of keys) {
                const v = normalizeEpochMs(extra[key]);
                if (v) {
                  return v;
                }
              }
            }
            return null;
          };
          const createdAtMs = findFirstTimestamp(['created_at']);
          const lastUpdatedAtMs = findFirstTimestamp(['last_updated_at', 'updated_at']);
          const endAtMs = findFirstTimestamp(['end_at']);
          const deltaUpdated = (createdAtMs && lastUpdatedAtMs) ? (lastUpdatedAtMs - createdAtMs) : null;
          const deltaEnd = (createdAtMs && endAtMs) ? (endAtMs - createdAtMs) : null;
          const timeText = deltaUpdated === null ? '--' : formatDuration(deltaUpdated);
          const durationText = deltaEnd === null ? '--' : formatDuration(deltaEnd);

          historyRows.push(`
            <tr class="adjust-group-top">
              <td>${escapeHtml(createdText)}</td>
              <td>${escapeHtml(describeAdjustmentAction(request.action))}</td>
              <td>${escapeHtml(String(request.magnitude ?? '--'))}</td>
              <td>${escapeHtml(scopeText)}</td>
              <td>${escapeHtml(statusCombined)}</td>
              <td colspan="4" style="text-align:center;">
                <span style="color:#8a94a6; margin-right:0.5rem;">${escapeHtml(orderModeText)}</span>
                <span style="color:#8a94a6; margin-right:0.5rem;">时间</span>
                <span style="margin-right:0.75rem; font-variant-numeric:tabular-nums;">${escapeHtml(timeText)}</span>
                <span style="color:#8a94a6; margin-right:0.5rem;">持续时间</span>
                <span style="margin-right:0.75rem; font-variant-numeric:tabular-nums;">${escapeHtml(durationText)}</span>
              </td>
            </tr>
          `);

          const wearSummary = computeFrontendWearSummary(leftAgent, rightAgent);
          const wearText = wearSummary ? `${formatMaybeNumber(wearSummary.per10k, 4)}/万 (合计)` : '--';

          const leftCard = left ? renderDetailCard(left, leftAgent) : '<div style="color:#8a94a6;">--</div>';
          const rightCard = right ? renderDetailCard(right, rightAgent) : '<div style="color:#8a94a6;">--</div>';

          historyRows.push(`
            <tr class="adjust-group-bottom">
              <td>↳</td>
              <td colspan="4" style="color:#8a94a6;">
                <span>VPS 详情</span>
                <span style="margin-left:0.6rem; font-variant-numeric:tabular-nums;">
                  <span style="margin-right:0.25rem;">磨损</span>
                  <span style="color:#c9d1d9;">${escapeHtml(wearText)}</span>
                </span>
              </td>
              <td colspan="4">
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:0.75rem;">
                  <div style="border-right:1px solid rgba(255,255,255,0.05); padding-right:0.75rem;">${leftCard}</div>
                  <div style="padding-left:0.25rem;">${rightCard}</div>
                </div>
              </td>
            </tr>
          `);
        }

        bpAdjustHistoryBody.innerHTML = historyRows.join('');
      }

      function normalizeRiskCapacitySeries(history, limit = 720) {
        if (!Array.isArray(history)) {
          return [];
        }
        const points = history
          .map((entry) => ({
            ts: Number(entry?.ts ?? entry?.timestamp),
            value: parseDecimal(entry?.total ?? entry?.value),
          }))
          .filter((point) => Number.isFinite(point.ts) && Number.isFinite(point.value));
        if (points.length > limit) {
          return points.slice(points.length - limit);
        }
        return points;
      }

      function normalizePriceSeriesEntry(entry, limit = 720) {
        if (!entry || !Array.isArray(entry.series)) {
          return [];
        }
        const series = entry.series.length > limit
          ? entry.series.slice(entry.series.length - limit)
          : entry.series;
        return series
          .map((point) => ({
            ts: Number(point?.ts ?? point?.time ?? point?.close_time),
            value: parseDecimal(point?.price ?? point?.close ?? point?.value),
          }))
          .filter((point) => Number.isFinite(point.ts) && Number.isFinite(point.value));
      }

      function normalizePercentChangeSeries(points) {
        if (!Array.isArray(points) || !points.length) {
          return [];
        }
        let baseline = null;
        for (const point of points) {
          const value = Number(point?.value);
          if (Number.isFinite(value) && value !== 0) {
            baseline = value;
            break;
          }
        }
        if (!Number.isFinite(baseline) || baseline === 0) {
          return [];
        }
        return points
          .map((point) => {
            const ts = Number(point?.ts);
            const value = Number(point?.value);
            if (!Number.isFinite(ts) || !Number.isFinite(value)) {
              return null;
            }
            const delta = ((value - baseline) / baseline) * 100;
            return { ts, value: delta };
          })
          .filter((point) => point && Number.isFinite(point.value));
      }

      function collectPercentPriceSeries(data) {
        const priceSeriesBlock = data?.volatility?.price_series;
        // BTC/ETH volatility feed removed; without it, the price chart simply has no series.
        if (!priceSeriesBlock) {
          return { percentSeries: [], diffSeries: null };
        }
        const priceEntries = priceSeriesBlock && typeof priceSeriesBlock === 'object'
          ? Object.values(priceSeriesBlock)
          : [];
        const rawSeries = [];
        const btcEntry = pickPriceEntry(priceEntries, 'BTC');
        const btcPoints = btcEntry ? normalizePriceSeriesEntry(btcEntry) : [];
        if (btcEntry && btcPoints.length) {
          rawSeries.push({
            label: btcEntry.label || btcEntry.symbol || 'BTC',
            symbol: btcEntry.symbol,
            color: BTC_LINE_COLOR,
            data: btcPoints,
          });
        }
        const ethEntry = pickPriceEntry(priceEntries, 'ETH', btcEntry?.symbol);
        const ethPoints = ethEntry ? normalizePriceSeriesEntry(ethEntry) : [];
        if (ethEntry && ethPoints.length) {
          rawSeries.push({
            label: ethEntry.label || ethEntry.symbol || 'ETH',
            symbol: ethEntry.symbol,
            color: ETH_LINE_COLOR,
            data: ethPoints,
          });
        }
        if (!rawSeries.length && priceEntries.length) {
          const fallback = priceEntries[0];
          const fallbackPoints = normalizePriceSeriesEntry(fallback);
          if (fallbackPoints.length) {
            rawSeries.push({
              label: fallback.label || fallback.symbol || 'Price',
              symbol: fallback.symbol,
              color: BTC_LINE_COLOR,
              data: fallbackPoints,
            });
          }
        }
        const percentSeries = rawSeries
          .map((series) => {
            const normalized = normalizePercentChangeSeries(series.data);
            if (!normalized.length) {
              return null;
            }
            return { ...series, data: normalized };
          })
          .filter(Boolean);
        const diffSeries = buildPriceDiffSeries(percentSeries);
        return { percentSeries, diffSeries };
      }

      function buildPriceDiffSeries(seriesList) {
        if (!Array.isArray(seriesList) || seriesList.length < 2) {
          return null;
        }
        const matchSeries = (keyword) => seriesList.find((series) => {
          const text = `${String(series.label || '')} ${String(series.symbol || '')}`.toUpperCase();
          return text.includes(keyword);
        });
        const btcSeries = matchSeries('BTC');
        const ethSeries = matchSeries('ETH');
        if (!btcSeries || !ethSeries) {
          return null;
        }
        const btcData = Array.isArray(btcSeries.data) ? btcSeries.data : [];
        const ethData = Array.isArray(ethSeries.data) ? ethSeries.data : [];
        if (!btcData.length || !ethData.length) {
          return null;
        }
        const diffPoints = [];
        let i = 0;
        let j = 0;
        while (i < btcData.length && j < ethData.length) {
          const btcPoint = btcData[i];
          const ethPoint = ethData[j];
          const btcTs = Number(btcPoint?.ts);
          const ethTs = Number(ethPoint?.ts);
          if (!Number.isFinite(btcTs)) {
            i += 1;
            continue;
          }
          if (!Number.isFinite(ethTs)) {
            j += 1;
            continue;
          }
          if (btcTs === ethTs) {
            const btcVal = Number(btcPoint?.value);
            const ethVal = Number(ethPoint?.value);
            if (Number.isFinite(btcVal) && Number.isFinite(ethVal)) {
              diffPoints.push({ ts: btcTs, value: btcVal - ethVal });
            }
            i += 1;
            j += 1;
          } else if (btcTs < ethTs) {
            i += 1;
          } else {
            j += 1;
          }
        }
        if (diffPoints.length < 2) {
          return null;
        }
        return {
          label: 'BTC-ETH Δ%',
          color: PRICE_DIFF_LINE_COLOR,
          data: diffPoints,
        };
      }

      function pickPriceEntry(entries, keyword, excludeSymbol = null) {
        if (!Array.isArray(entries)) {
          return null;
        }
        const upperKeyword = keyword ? keyword.toUpperCase() : null;
        for (const entry of entries) {
          const symbol = String(entry?.symbol || '').toUpperCase();
          if (excludeSymbol && symbol === String(excludeSymbol || '').toUpperCase()) {
            continue;
          }
          if (!upperKeyword) {
            return entry;
          }
          const label = `${symbol}${String(entry?.label || '').toUpperCase()}`;
          if (label.includes(upperKeyword)) {
            return entry;
          }
        }
        return null;
      }

      function computeNumericBounds(values) {
        let min = Infinity;
        let max = -Infinity;
        for (const value of values) {
          if (!Number.isFinite(value)) {
            continue;
          }
          if (value < min) {
            min = value;
          }
          if (value > max) {
            max = value;
          }
        }
        if (!Number.isFinite(min) || !Number.isFinite(max)) {
          return null;
        }
        if (min === max) {
          const epsilon = Math.abs(min) * 0.05 || 1;
          min -= epsilon;
          max += epsilon;
        }
        return { min, max };
      }

      function formatRangeLabel(minTs, maxTs) {
        if (!Number.isFinite(minTs) || !Number.isFinite(maxTs) || maxTs <= minTs) {
          return null;
        }
        const seconds = maxTs - minTs;
        if (seconds >= 3600) {
          return `覆盖约 ${(seconds / 3600).toFixed(1)} 小时`;
        }
        return `覆盖约 ${(seconds / 60).toFixed(0)} 分钟`;
      }

      function renderPriceChartFor(view, data) {
        const wrapper = view?.wrapper;
        const canvas = view?.canvas;
        const note = view?.note;
        const legend = view?.legend;
        if (!wrapper || !canvas) {
          return;
        }
        const { percentSeries } = collectPercentPriceSeries(data);
        if (!percentSeries.length) {
          wrapper.classList.add('hidden');
          if (note) {
            note.textContent = '等待数据…';
          }
          if (legend) {
            legend.innerHTML = '<span><span class="legend-dot legend-btc"></span>BTC</span><span><span class="legend-dot legend-eth"></span>ETH</span>';
          }
          return;
        }
        const chartResult = renderPriceCanvasFor(canvas, percentSeries);
        if (!chartResult) {
          wrapper.classList.add('hidden');
          if (note) {
            note.textContent = '等待数据…';
          }
          return;
        }
        wrapper.classList.remove('hidden');
        if (note) {
          const rangeText = formatRangeLabel(chartResult.minTs, chartResult.maxTs);
          note.textContent = rangeText || '最新数据';
        }
        if (legend) {
          legend.innerHTML = percentSeries
            .map((series) => (
              `<span><span class="legend-dot" style="background:${series.color}"></span>${escapeHtml(series.label)}</span>`
            ))
            .join('');
        }
      }

      function renderPriceChart(data) {
        renderPriceChartFor({
          wrapper: grvtPriceChartWrapper,
          canvas: grvtPriceChartCanvas,
          note: grvtPriceChartNote,
          legend: grvtPriceChartLegend,
        }, data);
      }

      // --- Exchange sidebar filtering ---
      function applyExchangeFilter(filter) {
        const normalized = String(filter || 'all').toLowerCase();
        const sections = Array.from(document.querySelectorAll('section[data-exchange]'));
        for (const section of sections) {
          const exchange = String(section.getAttribute('data-exchange') || '').toLowerCase();
          const visible = normalized === 'all' || (exchange && exchange === normalized);
          section.classList.toggle('hidden', !visible);
        }
        const buttons = Array.from(document.querySelectorAll('.sidebar-filter'));
        for (const btn of buttons) {
          btn.classList.toggle('active', String(btn.dataset.filter || 'all') === normalized);
        }
        try {
          window.localStorage.setItem('hedge-dashboard:exchange-filter', normalized);
        } catch (err) {
          // ignore
        }
      }

      function initExchangeFilterNav() {
        const buttons = Array.from(document.querySelectorAll('.sidebar-filter'));
        if (!buttons.length) {
          return;
        }
        for (const btn of buttons) {
          btn.addEventListener('click', () => applyExchangeFilter(btn.dataset.filter || 'all'));
        }
        let initial = 'all';
        try {
          initial = window.localStorage.getItem('hedge-dashboard:exchange-filter') || 'all';
        } catch (err) {
          initial = 'all';
        }
        applyExchangeFilter(initial);
      }

      document.addEventListener('DOMContentLoaded', initExchangeFilterNav);

      function renderParaPriceChart(data) {
        renderPriceChartFor({
          wrapper: paraPriceChartWrapper,
          canvas: paraPriceChartCanvas,
          note: paraPriceChartNote,
          legend: paraPriceChartLegend,
        }, data);
      }

      function renderPriceCanvasFor(canvas, seriesList) {
        if (!canvas) {
          return null;
        }
        const setup = prepareCanvas(canvas);
        if (!setup) {
          return null;
        }
        const { ctx, width, height } = setup;
        const layout = { top: 28, right: 48, bottom: 36, left: 68 };
        const innerWidth = Math.max(10, width - layout.left - layout.right);
        const innerHeight = Math.max(10, height - layout.top - layout.bottom);
        let minTs = Infinity;
        let maxTs = -Infinity;
        const values = [];
        for (const series of seriesList) {
          for (const point of series.data) {
            const ts = Number(point.ts);
            const value = Number(point.value);
            if (!Number.isFinite(ts) || !Number.isFinite(value)) {
              continue;
            }
            if (ts < minTs) {
              minTs = ts;
            }
            if (ts > maxTs) {
              maxTs = ts;
            }
            values.push(value);
          }
        }
        if (!Number.isFinite(minTs) || !Number.isFinite(maxTs)) {
          return null;
        }
        if (maxTs - minTs < 60) {
          maxTs = minTs + 60;
        }
        const bounds = computeNumericBounds(values);
        if (!bounds) {
          return null;
        }
        const rangeX = maxTs - minTs;
        const mapX = (ts) => layout.left + ((ts - minTs) / rangeX) * innerWidth;
        const mapY = (value) => {
          const ratio = (value - bounds.min) / (bounds.max - bounds.min);
          return layout.top + (1 - ratio) * innerHeight;
        };
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(layout.left, layout.top);
        ctx.lineTo(layout.left, layout.top + innerHeight);
        ctx.moveTo(width - layout.right, layout.top);
        ctx.lineTo(width - layout.right, layout.top + innerHeight);
        ctx.moveTo(layout.left, layout.top + innerHeight);
        ctx.lineTo(width - layout.right, layout.top + innerHeight);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        const gridLines = 4;
        for (let index = 1; index < gridLines; index += 1) {
          const y = layout.top + (innerHeight / gridLines) * index;
          ctx.beginPath();
          ctx.moveTo(layout.left, y);
          ctx.lineTo(width - layout.right, y);
          ctx.stroke();
        }
        const zeroY = mapY(0);
        if (zeroY >= layout.top && zeroY <= layout.top + innerHeight) {
          ctx.strokeStyle = 'rgba(255,255,255,0.18)';
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(layout.left, zeroY);
          ctx.lineTo(width - layout.right, zeroY);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        for (const series of seriesList) {
          drawTimedSeries(ctx, series.data, mapX, mapY, series.color, 2.5);
        }
        ctx.fillStyle = '#8a94a6';
        ctx.font = '12px "Segoe UI", system-ui, sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(formatSignedPercent(bounds.max, 2), layout.left - 8, layout.top + 12);
        ctx.fillText(formatSignedPercent(bounds.min, 2), layout.left - 8, layout.top + innerHeight + 2);
        return { minTs, maxTs };
      }

      function renderPriceCanvas(seriesList) {
        return renderPriceCanvasFor(grvtPriceChartCanvas, seriesList);
      }

      function renderTransferChart(data) {
        if (!grvtTransferChartWrapper || !grvtTransferChartCanvas) {
          return;
        }
        const { diffSeries } = collectPercentPriceSeries(data);
        const activeDiffSeries = diffSeries && Array.isArray(diffSeries.data) && diffSeries.data.length >= 2
          ? diffSeries
          : null;
        const updateLegend = () => {
          if (!grvtTransferChartLegend) {
            return;
          }
          const entries = [
            '<span><span class="legend-dot legend-transfer"></span>风险基数</span>',
          ];
          if (activeDiffSeries) {
            entries.push(
              `<span><span class="legend-dot legend-diff"></span>${escapeHtml(activeDiffSeries.label || 'BTC-ETH Δ%')}</span>`
            );
          }
          grvtTransferChartLegend.innerHTML = entries.join('');
        };
        const riskCapacityPoints = normalizeRiskCapacitySeries(data?.transferable_history);
        updateLegend();
        if (!riskCapacityPoints.length) {
          grvtTransferChartWrapper.classList.add('hidden');
          if (grvtTransferChartNote) {
            grvtTransferChartNote.textContent = '等待数据…';
          }
          return;
        }
        const chartResult = renderRiskCapacityCanvas(riskCapacityPoints, activeDiffSeries);
        if (!chartResult) {
          grvtTransferChartWrapper.classList.add('hidden');
          if (grvtTransferChartNote) {
            grvtTransferChartNote.textContent = '等待数据…';
          }
          return;
        }
        grvtTransferChartWrapper.classList.remove('hidden');
        if (grvtTransferChartNote) {
          const rangeText = formatRangeLabel(chartResult.minTs, chartResult.maxTs);
          grvtTransferChartNote.textContent = rangeText || '最新数据';
        }
      }

      function renderRiskCapacityCanvas(riskCapacityPoints, diffSeries = null) {
        if (!grvtTransferChartCanvas) {
          return null;
        }
        const setup = prepareCanvas(grvtTransferChartCanvas);
        if (!setup) {
          return null;
        }
        const { ctx, width, height } = setup;
        const layout = { top: 30, right: 56, bottom: 36, left: 72 };
        const innerWidth = Math.max(10, width - layout.left - layout.right);
        const innerHeight = Math.max(10, height - layout.top - layout.bottom);
        let minTs = Infinity;
        let maxTs = -Infinity;
  const values = [];
  const diffValues = [];
  let filteredDiffPoints = null;
        for (const point of riskCapacityPoints) {
          const ts = Number(point?.ts);
          const value = Number(point?.value);
          if (!Number.isFinite(ts) || !Number.isFinite(value)) {
            continue;
          }
          if (ts < minTs) {
            minTs = ts;
          }
          if (ts > maxTs) {
            maxTs = ts;
          }
          values.push(value);
        }
        if (!Number.isFinite(minTs) || !Number.isFinite(maxTs)) {
          return null;
        }
        if (maxTs - minTs < 60) {
          maxTs = minTs + 60;
        }
        const bounds = computeNumericBounds(values);
        if (!bounds) {
          return null;
        }
        if (diffSeries && Array.isArray(diffSeries.data)) {
          const withinRange = [];
          for (const point of diffSeries.data) {
            const ts = Number(point?.ts);
            const value = Number(point?.value);
            if (!Number.isFinite(ts) || !Number.isFinite(value)) {
              continue;
            }
            if (ts < minTs || ts > maxTs) {
              continue;
            }
            withinRange.push({ ts, value });
            diffValues.push(value);
          }
          if (withinRange.length >= 2) {
            filteredDiffPoints = withinRange;
          }
        }
        const diffBounds = diffValues.length ? computeNumericBounds(diffValues) : null;
        const rangeX = maxTs - minTs;
        const mapX = (ts) => layout.left + ((ts - minTs) / rangeX) * innerWidth;
        const mapY = (value) => {
          const ratio = (value - bounds.min) / (bounds.max - bounds.min);
          return layout.top + (1 - ratio) * innerHeight;
        };
        const mapDiffY = diffBounds
          ? (value) => {
              const ratio = (value - diffBounds.min) / (diffBounds.max - diffBounds.min);
              return layout.top + (1 - ratio) * innerHeight;
            }
          : null;
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(layout.left, layout.top);
        ctx.lineTo(layout.left, layout.top + innerHeight);
        ctx.moveTo(width - layout.right, layout.top);
        ctx.lineTo(width - layout.right, layout.top + innerHeight);
        ctx.moveTo(layout.left, layout.top + innerHeight);
        ctx.lineTo(width - layout.right, layout.top + innerHeight);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        const gridLines = 4;
        for (let index = 1; index < gridLines; index += 1) {
          const y = layout.top + (innerHeight / gridLines) * index;
          ctx.beginPath();
          ctx.moveTo(layout.left, y);
          ctx.lineTo(width - layout.right, y);
          ctx.stroke();
        }
  drawTimedSeries(ctx, riskCapacityPoints, mapX, mapY, RISK_CAPACITY_LINE_COLOR, 2.8);
        if (filteredDiffPoints && diffBounds && mapDiffY) {
          const zeroDiffY = mapDiffY(0);
          if (zeroDiffY >= layout.top && zeroDiffY <= layout.top + innerHeight) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(layout.left, zeroDiffY);
            ctx.lineTo(width - layout.right, zeroDiffY);
            ctx.stroke();
            ctx.setLineDash([]);
          }
          drawTimedSeries(
            ctx,
            filteredDiffPoints,
            mapX,
            mapDiffY,
            diffSeries.color || PRICE_DIFF_LINE_COLOR,
            2.2,
          );
        }
        ctx.fillStyle = '#8a94a6';
        ctx.font = '12px "Segoe UI", system-ui, sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(numberFormatter.format(bounds.max), layout.left - 8, layout.top + 12);
        ctx.fillText(numberFormatter.format(bounds.min), layout.left - 8, layout.top + innerHeight + 2);
        if (filteredDiffPoints && diffBounds && mapDiffY) {
          ctx.textAlign = 'left';
          const rightAxisX = width - layout.right + 8;
          ctx.fillText(formatSignedPercent(diffBounds.max, 2), rightAxisX, layout.top + 12);
          ctx.fillText(formatSignedPercent(diffBounds.min, 2), rightAxisX, layout.top + innerHeight + 2);
        }
        return { minTs, maxTs };
      }

      function computeRiskRatio(totalValue, balanceValue) {
        if (!Number.isFinite(totalValue) || totalValue >= 0) {
          return null;
        }
        if (!Number.isFinite(balanceValue) || balanceValue <= 0) {
          return null;
        }
        return Math.abs(totalValue) / balanceValue;
      }

      function resolveRiskBand(ratio, bands = RISK_GRADIENTS) {
        if (!Number.isFinite(ratio) || ratio < 0) {
          return null;
        }
        const targetBands = Array.isArray(bands) && bands.length ? bands : RISK_GRADIENTS;
        for (const band of targetBands) {
          if (ratio <= band.max) {
            return band;
          }
        }
        return targetBands[targetBands.length - 1];
      }

      function applyRiskTone(element, ratio, { variant = 'summary', bands = RISK_GRADIENTS } = {}) {
        if (!element) {
          return;
        }
        element.classList.add('risk-pill');
        element.classList.toggle('risk-pill-inline', variant === 'inline');
        element.classList.toggle('risk-pill-summary', variant === 'summary');
        if (!Number.isFinite(ratio) || ratio < 0) {
          element.style.removeProperty('background');
          element.style.removeProperty('color');
          element.style.removeProperty('box-shadow');
          element.dataset.riskLevel = 'unknown';
          return;
        }
  const activeBands = Array.isArray(bands) && bands.length ? bands : RISK_GRADIENTS;
  const band = resolveRiskBand(ratio, activeBands) ?? activeBands[activeBands.length - 1];
        element.style.background = band.gradient;
        element.style.color = band.color;
        element.style.boxShadow = band.shadow;
        element.dataset.riskLevel = band.label;
      }

      function buildAccountSortKey(agentId, account, summary) {
        const safeAgent = (agentId ?? '').toString().toLowerCase();
        const accountIdentifiers = [
          account?.account_id,
          account?.id,
          account?.address,
          account?.name,
          summary?.account_id,
          summary?.address,
        ];
        let identifier = accountIdentifiers.find((value) => {
          if (value === null || value === undefined) {
            return false;
          }
          const text = String(value).trim();
          return text.length > 0;
        });
        if (identifier === undefined) {
          identifier = account ? 'account' : 'summary';
        }
        return `${safeAgent}::${String(identifier).toLowerCase()}`;
      }

      function renderPara(data) {
        if (!paraAccountCount || !paraEmpty || !paraCard) {
          return;
        }

        try {

        // Prefer top-level paradex map, but fall back to agent payloads in case coordinator
        // snapshots omit the flattened map (backward compatibility with older snapshots).
        const mergedParaMap = {};
        const directMap = data?.paradex_accounts;
        if (directMap && typeof directMap === 'object') {
          for (const [agentId, snapshot] of Object.entries(directMap)) {
            if (snapshot) {
              mergedParaMap[agentId] = snapshot;
            }
          }
        }
        if (!Object.keys(mergedParaMap).length && data?.agents && typeof data.agents === 'object') {
          for (const [agentId, payload] of Object.entries(data.agents)) {
            const snapshot = payload?.paradex_accounts;
            if (snapshot) {
              mergedParaMap[agentId] = snapshot;
            }
          }
        }

  const entries = Object.entries(mergedParaMap);
  const nowSec = Date.now() / 1000;

        if (!entries.length) {
          paraLatestRiskRatio = null;
          recomputeGlobalRiskRatio();
          paraCard.classList.add('hidden');
          paraEmpty.classList.remove('hidden');
          paraAccountCount.textContent = '0 accounts';
          paraTotalPnl.textContent = '--';
          if (paraMaxImReq) {
            paraMaxImReq.textContent = '--';
          }
          paraTotalEquity.textContent = '--';
          paraWalletBalance.textContent = 'Wallet --';
          if (paraSourceUpdates) {
            paraSourceUpdates.textContent = '--';
            paraSourceUpdates.innerHTML = '';
          }
          if (paraAvgMaint) {
            paraAvgMaint.textContent = '--';
            paraAvgMaint.removeAttribute('title');
          }
          if (paraTransferableTotal) {
            paraTransferableTotal.textContent = '--';
          }
          if (paraTransferableNote) {
            paraTransferableNote.textContent = '等待风险裕量数据…';
          }
          if (paraRiskLevel) {
            paraRiskLevel.textContent = '--';
            applyRiskTone(paraRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
          }
          if (paraRiskDetail) {
            paraRiskDetail.textContent = 'Awaiting data…';
          }
          paraSummaryTime.textContent = '--';
          paraSummaryUpdated.textContent = 'Updated —';
          if (paraAccountGrid) {
            paraAccountGrid.innerHTML = '';
          }
          if (paraAccountsEmpty) {
            paraAccountsEmpty.classList.add('hidden');
          }
          updateParaSymbolOptions([]);
          updateParaTransferAgents([]);
          return;
        }

        paraEmpty.classList.add('hidden');
        paraCard.classList.remove('hidden');

        let aggregateAccountCount = 0;
    let aggregateTotalPnl = 0;
    let aggregateEquity = 0;
    let aggregateWallet = 0;
    let aggregateInitialMargin = 0;
  let aggregateMaintRequirement = 0;
  let aggregateMaintBase = 0;
  let hasTotal = false;
  let hasEquity = false;
  let hasWallet = false;
  let latestUpdate = 0;
  let maxAbsPnl = null;
  let maxInitialMargin = null;
  const flattenedAccounts = [];
  const symbolCandidates = new Set();
    const transferOptions = [];
        let worstLossAccount = null;

        for (const [agentId, snapshot] of entries) {
          try {
            if (!snapshot || typeof snapshot !== 'object') {
              continue; 
            }
            const summaryRaw = snapshot.summary;
            const summary = summaryRaw && typeof summaryRaw === 'object' ? summaryRaw : {};
            const transferDefaults = snapshot.transfer_defaults && typeof snapshot.transfer_defaults === 'object'
              ? snapshot.transfer_defaults
              : {};
            const agentLabel = summary?.label || summary?.account_label || summary?.name || agentId;
            transferOptions.push({ agentId, label: agentLabel, defaults: transferDefaults });
            const accountsRaw = snapshot.accounts;
            const accounts = Array.isArray(accountsRaw) ? accountsRaw : [];
            const snapshotTs = Number(summary.updated_at ?? snapshot.updated_at);
            if (Number.isFinite(snapshotTs) && snapshotTs > latestUpdate) {
              latestUpdate = snapshotTs;
            }

            if (accounts.length) {
              aggregateAccountCount += accounts.length;
              for (const account of accounts) {
                const accountObj = account && typeof account === 'object' ? account : {};
                const total = parseDecimal(accountObj.total_pnl);
                // ETH/BTC PnL removed from PARA cards.
                const equity = parseDecimal(accountObj.equity ?? accountObj.available_equity);
                const wallet = parseDecimal(accountObj.balance ?? accountObj.available_balance);
                const available = parseDecimal(accountObj.available_balance ?? accountObj.available_equity);
                const availableEquity = parseDecimal(accountObj.available_equity ?? accountObj.equity);
                const initialMarginFromApi = parseDecimal(accountObj.initial_margin_requirement);
                const initialMarginRequirement = parseDecimal(accountObj.initial_margin_requirement);
                let initialMarginTotal = Number.isFinite(initialMarginFromApi) ? initialMarginFromApi : 0;
                const positionsList = Array.isArray(accountObj.positions) ? accountObj.positions : [];
                if (!Number.isFinite(initialMarginTotal) || initialMarginTotal === 0) {
                  initialMarginTotal = 0;
                  if (positionsList.length) {
                    for (const position of positionsList) {
                      const leverage = parseDecimal(position.leverage);
                      const marginInfo = computePositionMargin(position);
                      const notionalValue = Number.isFinite(marginInfo?.notional)
                        ? marginInfo.notional
                        : (() => {
                            const notionalRaw = parseDecimal(position.notional_value ?? position.notional);
                            if (Number.isFinite(notionalRaw)) return notionalRaw;
                            const sizeVal = parseDecimal(position.net_size ?? position.size ?? position.quantity);
                            const priceVal = parseDecimal(position.mark_price ?? position.markPrice ?? position.entry_price ?? position.entryPrice);
                            return Number.isFinite(sizeVal) && Number.isFinite(priceVal) ? Math.abs(sizeVal * priceVal) : null;
                          })();
                      const initialMarginViaLeverage = Number.isFinite(notionalValue) && Number.isFinite(leverage) && leverage > 0
                        ? notionalValue / leverage
                        : null;
                      const initialMarginValue = Number.isFinite(initialMarginViaLeverage)
                        ? initialMarginViaLeverage
                        : (Number.isFinite(marginInfo?.initialMargin) ? marginInfo.initialMargin : null);
                      if (Number.isFinite(initialMarginValue)) {
                        initialMarginTotal += initialMarginValue;
                      }
                    }
                  }
                }
                if (Number.isFinite(total)) {
                  aggregateTotalPnl += total;
                  hasTotal = true;
                  const absPnl = Math.abs(total);
                  if (!Number.isFinite(maxAbsPnl) || absPnl > maxAbsPnl) {
                    maxAbsPnl = absPnl;
                  }
                  if (total < 0) {
                    const absLoss = absPnl;
                    if (!worstLossAccount || absLoss > worstLossAccount.lossValue) {
                      worstLossAccount = {
                        lossValue: absLoss,
                        accountName: accountObj.name ?? accountObj.account_id ?? accountObj.id ?? 'Account',
                        agentId,
                      };
                    }
                  }
                }
                // ETH/BTC PnL removed from Per Account Net PnL cards; keep parsing for backwards compatibility.
                if (Number.isFinite(equity)) {
                  aggregateEquity += equity;
                  hasEquity = true;
                }
                if (Number.isFinite(wallet)) {
                  aggregateWallet += wallet;
                  hasWallet = true;
                }
                if (Number.isFinite(initialMarginTotal)) {
                  aggregateInitialMargin += initialMarginTotal;
                  if (!Number.isFinite(maxInitialMargin) || initialMarginTotal > maxInitialMargin) {
                    maxInitialMargin = initialMarginTotal;
                  }
                }
                const transferableEstimate = estimateTransferableFunds({
                  walletValue: wallet,
                  equityValue: equity,
                  availableBalanceValue: available,
                  availableEquityValue: availableEquity,
                  totalInitialMargin: initialMarginTotal,
                  unrealizedPnl: total,
                });
                const transferableValue = transferableEstimate && Number.isFinite(transferableEstimate.value)
                  ? transferableEstimate.value
                  : null;

                flattenedAccounts.push({
                  agentId,
                  name: accountObj.name ?? accountObj.account_id ?? accountObj.id ?? 'Account',
                  total,
                  equity,
                  wallet,
                  available,
                  availableEquity,
                  transferableEstimate,
                  transferableValue,
                  positions: positionsList,
                  initialMarginTotal,
                  initialMarginRequirement,
                  updatedTs: snapshotTs,
                  sortKey: buildAccountSortKey(agentId, accountObj, summary),
                });
              }
            } else {
              const total = parseDecimal(summary.total_pnl);
              // ETH/BTC PnL removed from PARA cards.
              const equity = parseDecimal(summary.equity ?? summary.available_equity);
              const wallet = parseDecimal(summary.balance ?? summary.available_balance);
              const available = parseDecimal(summary.available_balance ?? summary.available_equity);
              const availableEquity = parseDecimal(summary.available_equity ?? summary.equity);
              const initialMarginTotal = parseDecimal(summary.initial_margin_requirement);
              const initialMarginRequirement = parseDecimal(summary.initial_margin_requirement);
              if (Number.isFinite(total)) {
                aggregateTotalPnl += total;
                hasTotal = true;
                const absPnl = Math.abs(total);
                if (!Number.isFinite(maxAbsPnl) || absPnl > maxAbsPnl) {
                  maxAbsPnl = absPnl;
                }
                if (total < 0) {
                  const absLoss = absPnl;
                  if (!worstLossAccount || absLoss > worstLossAccount.lossValue) {
                    worstLossAccount = {
                      lossValue: absLoss,
                      accountName: summary.name ?? summary.label ?? agentId,
                      agentId,
                    };
                  }
                }
              }
              // ETH/BTC PnL removed from Per Account Net PnL cards; keep parsing for backwards compatibility.
              if (Number.isFinite(equity)) {
                aggregateEquity += equity;
                hasEquity = true;
              }
              if (Number.isFinite(wallet)) {
                aggregateWallet += wallet;
                hasWallet = true;
              }
              if (Number.isFinite(initialMarginTotal)) {
                aggregateInitialMargin += initialMarginTotal;
                if (!Number.isFinite(maxInitialMargin) || initialMarginTotal > maxInitialMargin) {
                  maxInitialMargin = initialMarginTotal;
                }
              }
              // summary path lacks per-position IM, assume 0
              const accountCountFallback = Number(summary.account_count ?? 0);
              if (Number.isFinite(accountCountFallback) && accountCountFallback > 0) {
                aggregateAccountCount += accountCountFallback;
              }
              const transferableEstimate = estimateTransferableFunds({
                walletValue: wallet,
                equityValue: equity,
                availableBalanceValue: available,
                availableEquityValue: availableEquity,
                totalInitialMargin: Number.isFinite(initialMarginTotal) ? initialMarginTotal : 0,
                unrealizedPnl: total,
              });
              const transferableValue = transferableEstimate && Number.isFinite(transferableEstimate.value)
                ? transferableEstimate.value
                : null;

              flattenedAccounts.push({
                agentId,
                name: summary.name ?? summary.label ?? agentId,
                total,
                equity,
                wallet,
                available,
                availableEquity,
                transferableEstimate,
                transferableValue,
                positions: [],
                initialMarginTotal: Number.isFinite(initialMarginTotal) ? initialMarginTotal : 0,
                initialMarginRequirement,
                updatedTs: snapshotTs,
                sortKey: buildAccountSortKey(agentId, null, summary),
              });
            }
          } catch (err) {
            console.warn('PARA render error for agent', agentId, err);
          }
        }

        const sourcesLabel = entries.length === 1 ? 'source' : 'sources';
        const accountLabel = aggregateAccountCount === 1 ? 'account' : 'accounts';
        paraAccountCount.textContent = `${aggregateAccountCount} ${accountLabel} across ${entries.length} ${sourcesLabel}`;

        paraTotalPnl.textContent = hasTotal ? numberFormatter.format(aggregateTotalPnl) : '--';
        paraTotalEquity.textContent = hasEquity ? numberFormatter.format(aggregateEquity) : '--';
        paraWalletBalance.textContent = hasWallet
          ? `Wallet ${numberFormatter.format(aggregateWallet)}`
          : 'Wallet --';

        const maxAbsPnlValue = Number.isFinite(maxAbsPnl) ? maxAbsPnl : 0;
        const maxInitialMarginValue = Number.isFinite(maxInitialMargin) ? maxInitialMargin : 0;

        if (paraMaxImReq) {
          paraMaxImReq.textContent = maxInitialMarginValue > 0
            ? numberFormatter.format(maxInitialMarginValue)
            : '--';
        }
        const rawRiskAllowance = hasEquity
          ? aggregateEquity - 1.5 * maxInitialMarginValue
          : null;
        const hasRiskAllowanceValue = Number.isFinite(rawRiskAllowance) && rawRiskAllowance > 0;
        const riskAllowanceBaseNote = hasRiskAllowanceValue
          ? `覆盖 ${aggregateAccountCount} 个账户 · 风险裕量 = Equity - 1.5×max(IM ${numberFormatter.format(maxInitialMarginValue)})`
          : '缺少风险裕量数据';
        const bufferedRiskCapacity = evaluateRiskCapacityBuffer({
          hasValue: hasRiskAllowanceValue,
          value: hasRiskAllowanceValue ? rawRiskAllowance : null,
          timestamp: latestUpdate,
          baseNote: riskAllowanceBaseNote,
          state: paraRiskCapacityBufferState,
        });

        // “风险裕量”卡片与 RISK LEVEL 卡片使用同一份（buffer 后的）权威裕量值。
        // 告警历史会在后端侧做同口径写入。
        const effectiveRiskCapacity = Number.isFinite(bufferedRiskCapacity.displayValue)
          ? bufferedRiskCapacity.displayValue
          : null;

        if (paraTransferableTotal) {
          paraTransferableTotal.textContent = Number.isFinite(effectiveRiskCapacity)
            ? numberFormatter.format(effectiveRiskCapacity)
            : '--';
        }
        if (paraTransferableNote) {
          paraTransferableNote.textContent = bufferedRiskCapacity.note;
        }

        let paraRiskRatio = null;
        paraLatestRiskRatio = null;
        if (paraRiskLevel && paraRiskDetail) {
          const denominator = Number.isFinite(effectiveRiskCapacity) && effectiveRiskCapacity > 0
            ? effectiveRiskCapacity
            : null;
          const numerator = Number.isFinite(maxAbsPnlValue) ? maxAbsPnlValue : null;
          if (worstLossAccount && denominator && Number.isFinite(numerator)) {
            paraRiskRatio = numerator / denominator;
            paraRiskLevel.textContent = formatPercent(paraRiskRatio * 100, 2);
            applyRiskTone(paraRiskLevel, paraRiskRatio, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            const accountLabelText = worstLossAccount.accountName
              ? `${worstLossAccount.accountName} (${worstLossAccount.agentId})`
              : worstLossAccount.agentId;
            const lossText = numberFormatter.format(numerator ?? 0);
            const riskCapacityText = numberFormatter.format(denominator);
            paraRiskDetail.textContent = `${accountLabelText}亏损 ${lossText} / 裕量 ${riskCapacityText} · ${getRiskThresholdSummary()}`;
            paraLatestRiskRatio = paraRiskRatio;
          } else if (worstLossAccount && !denominator) {
            paraRiskLevel.textContent = '—';
            applyRiskTone(paraRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            paraRiskDetail.textContent = '缺少风险裕量数据，无法计算 RISK';
          } else {
            paraRiskLevel.textContent = '—';
            applyRiskTone(paraRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            paraRiskDetail.textContent = '无亏损或缺少盈亏数据';
          }
        }

        recomputeGlobalRiskRatio();

        const updatedText = formatTimestamp(latestUpdate);
        paraSummaryTime.textContent = updatedText ?? '--';
        paraSummaryUpdated.textContent = updatedText ? `Updated ${updatedText}` : 'Updated —';

        // ---- PARA reduce suggestion (BTC/ETH) ----
        if (paraReduceSuggestionMain && paraReduceSuggestionDetail) {
          const meaningfulAccounts = flattenedAccounts.filter((acc) => Array.isArray(acc.positions) && acc.positions.length);
          const suggestion = computeParaReduceSuggestion(meaningfulAccounts.length ? meaningfulAccounts : flattenedAccounts);
          if (suggestion?.ok) {
            paraReduceSuggestionMain.textContent = suggestion.message || '--';
            // 减仓建议只保留一行，不展示详情。
            paraReduceSuggestionDetail.textContent = '';
            paraReduceSuggestionDetail.style.display = 'none';
          } else {
            paraReduceSuggestionMain.textContent = '—';
            // 失败/不可用时也不展示第二行详情，避免噪音。
            paraReduceSuggestionDetail.textContent = '';
            paraReduceSuggestionDetail.style.display = 'none';
          }
        }

        if (paraSourceUpdates) {
          paraSourceUpdates.innerHTML = '';
          for (const [agentId, snapshot] of entries) {
            const summary = snapshot?.summary && typeof snapshot.summary === 'object' ? snapshot.summary : {};
            const agentLabel = summary.label || summary.account_label || summary.name || agentId;
            const ts = Number(summary.updated_at ?? summary.last_update_ts ?? snapshot?.updated_at ?? snapshot?.last_update_ts);
            const span = document.createElement('span');
            span.classList.add('badge');
            if (Number.isFinite(ts)) {
              const ageSec = Math.max(0, nowSec - ts);
              const freshnessText = `${formatDuration(ageSec)} ago`;
              if (ageSec >= PARA_STALE_CRIT_SEC) {
                span.classList.add('badge-danger');
                span.textContent = `${agentLabel}: stale · ${freshnessText}`;
              } else if (ageSec >= PARA_STALE_WARN_SEC) {
                span.classList.add('badge-warn');
                span.textContent = `${agentLabel}: delayed · ${freshnessText}`;
              } else {
                span.classList.add('badge-info');
                span.textContent = `${agentLabel}: fresh · ${freshnessText}`;
              }
            } else {
              span.classList.add('badge-muted');
              span.textContent = `${agentLabel}: time N/A`;
            }
            paraSourceUpdates.appendChild(span);
          }
          if (!paraSourceUpdates.childElementCount) {
            paraSourceUpdates.textContent = '--';
          }
        }

        updateRiskMeta();

        recomputeGlobalRiskRatio();
        if (!paraAccountGrid) {
          return;
        }

        if (!flattenedAccounts.length) {
          if (paraAvgMaint) {
            paraAvgMaint.textContent = '--';
            paraAvgMaint.removeAttribute('title');
          }
          if (paraSourceUpdates) {
            paraSourceUpdates.textContent = '--';
            paraSourceUpdates.innerHTML = '';
          }
          if (paraAccountsEmpty) {
            paraAccountsEmpty.classList.remove('hidden');
            const sourcesLabel = entries.length === 1 ? 'source' : 'sources';
            paraAccountsEmpty.textContent = entries.length
              ? `Received ${entries.length} ${sourcesLabel} but no account rows; check monitor payload shape.`
              : 'Waiting for account data…';
          }
          return;
        }

        if (paraAccountsEmpty) {
          paraAccountsEmpty.classList.add('hidden');
        }

        flattenedAccounts.sort((a, b) => {
          const aKey = a.sortKey ?? '';
          const bKey = b.sortKey ?? '';
          if (aKey !== bKey) {
            return aKey.localeCompare(bKey);
          }
          return (Number(b.updatedTs ?? 0) || 0) - (Number(a.updatedTs ?? 0) || 0);
        });

        const accountRenderKey = flattenedAccounts
          .map((entry) => {
            const count = Array.isArray(entry.positions) ? entry.positions.length : 0;
            const ts = Number(entry.updatedTs) || 0;
            return `${entry.agentId ?? 'source'}:${ts}:${count}`;
          })
          .join('|');
        const shouldRebuildGrid = !paraAccountGridKey || paraAccountGridKey !== accountRenderKey;
        paraAccountGridKey = accountRenderKey;
        if (shouldRebuildGrid) {
          paraAccountGrid.innerHTML = '';
        }

        for (const entry of flattenedAccounts) {
          const positions = Array.isArray(entry.positions)
            ? entry.positions.slice().sort((a, b) => {
                const aPnl = parseDecimal(a?.pnl);
                const bPnl = parseDecimal(b?.pnl);
                const aAbs = Number.isFinite(aPnl) ? Math.abs(aPnl) : -1;
                const bAbs = Number.isFinite(bPnl) ? Math.abs(bPnl) : -1;
                if (aAbs !== bAbs) {
                  return bAbs - aAbs;
                }
                const aSymbol = (a?.symbol ?? '').toString();
                const bSymbol = (b?.symbol ?? '').toString();
                return aSymbol.localeCompare(bSymbol, undefined, { sensitivity: 'base' });
              })
            : [];

          const maintenanceRequirementTotal = Number.isFinite(entry.initialMarginTotal)
            ? 0.5 * entry.initialMarginTotal
            : 0;
          const ratioBaseValue = Number.isFinite(entry.equity) && entry.equity > 0
            ? entry.equity
            : null;

          if (ratioBaseValue && Number.isFinite(maintenanceRequirementTotal) && maintenanceRequirementTotal >= 0) {
            const ratio = maintenanceRequirementTotal / ratioBaseValue;
            if (Number.isFinite(ratio)) {
              aggregateMaintRequirement += maintenanceRequirementTotal;
              aggregateMaintBase += ratioBaseValue;
            }
          }

          if (!shouldRebuildGrid) {
            continue;
          }

          const card = document.createElement('article');
          card.className = 'grvt-account-card';

          const totalText = Number.isFinite(entry.total) ? numberFormatter.format(entry.total) : '--';
          const equityText = Number.isFinite(entry.equity) ? numberFormatter.format(entry.equity) : '--';
          const walletText = Number.isFinite(entry.wallet) ? numberFormatter.format(entry.wallet) : '--';
          const initialMarginText = Number.isFinite(entry.initialMarginTotal)
            ? numberFormatter.format(entry.initialMarginTotal)
            : '--';

          // Prefer API initial_margin_requirement; fall back to legacy initial_margin/initial_margin_total.
          // Note: treat 0 as a valid number (display "0"), only use "--" for missing/NaN.
          const imReqCandidate = Number.isFinite(entry.initialMarginRequirement)
            ? entry.initialMarginRequirement
            : (Number.isFinite(entry.initialMarginTotal) ? entry.initialMarginTotal : null);
          const initialMarginRequirementText = Number.isFinite(imReqCandidate)
            ? numberFormatter.format(imReqCandidate)
            : '--';
          const transferableCandidate = Number.isFinite(entry.transferableValue)
            ? entry.transferableValue
            : (entry.transferableEstimate && Number.isFinite(entry.transferableEstimate.value)
              ? entry.transferableEstimate.value
              : null);
          const transferableText = Number.isFinite(transferableCandidate)
            ? numberFormatter.format(Math.max(0, transferableCandidate))
            : '--';
          const updatedText = formatTimestamp(entry.updatedTs) ?? '—';
          const ageSec = Number.isFinite(entry.updatedTs) ? Math.max(0, nowSec - entry.updatedTs) : null;
          let freshnessBadge = '';
          if (Number.isFinite(ageSec)) {
            const freshnessText = `${formatDuration(ageSec)} ago`;
            if (ageSec >= PARA_STALE_CRIT_SEC) {
              freshnessBadge = `<span class="badge badge-danger">Stale · ${escapeHtml(freshnessText)}</span>`;
            } else if (ageSec >= PARA_STALE_WARN_SEC) {
              freshnessBadge = `<span class="badge badge-warn">Delayed · ${escapeHtml(freshnessText)}</span>`;
            } else {
              freshnessBadge = `<span class="badge badge-info">Fresh · ${escapeHtml(freshnessText)}</span>`;
            }
          } else {
            freshnessBadge = '<span class="badge badge-muted">Time N/A</span>';
          }

          const positionsCountText = `${positions.length} pos`;

          card.innerHTML = `
            <header>
              <div>
                <span class="grvt-account-name">${escapeHtml(entry.name ?? 'Account')}</span>
                <span class="badge badge-info grvt-source-badge">${escapeHtml(entry.agentId ?? 'source')}</span>
              </div>
              <div class="grvt-account-badges">${freshnessBadge}</div>
              <span class="grvt-account-updated">${escapeHtml(updatedText)}</span>
            </header>
            <dl class="grvt-account-metrics">
              <div><dt>Total</dt><dd>${escapeHtml(totalText)}</dd></div>
              <div><dt>Positions</dt><dd>${escapeHtml(positionsCountText)}</dd></div>
              <div><dt>Equity</dt><dd>${escapeHtml(equityText)}</dd></div>
              <div><dt>Balance</dt><dd>${escapeHtml(walletText)}</dd></div>
              <div><dt>IM Req</dt><dd>${escapeHtml(initialMarginRequirementText)}</dd></div>
              <div><dt>Transferable</dt><dd>${escapeHtml(transferableText)}</dd></div>
              <div data-metric="maintenance"><dt>Maint.</dt><dd><span class="maintenance-ratio">—</span></dd></div>
            </dl>
          `;

          if (positions.length) {
            const table = document.createElement('table');
            table.className = 'grvt-positions-table';
            table.innerHTML = `
              <thead>
                <tr>
                  <th>Symbol</th>
                  <th>Side</th>
                  <th>Size</th>
                  <th>Entry</th>
                  <th>Mark</th>
                  <th>PnL</th>
                  <th>Value</th>
                  <th>Leverage</th>
                  <th>Init Margin</th>
                </tr>
              </thead>
              <tbody></tbody>
            `;
            const body = table.querySelector('tbody');
            const limit = Number.isFinite(MAX_PARA_POSITIONS) ? MAX_PARA_POSITIONS : positions.length;
            const trimmed = positions.slice(0, limit);
            for (const pos of trimmed) {
              const symbol = pos.symbol ?? '--';
              if (symbol) {
                symbolCandidates.add(normalizeSymbolLabel(symbol));
              }
              const side = (pos.side ?? '').toString().toUpperCase();
              const sizeValue = parseDecimal(pos.net_size ?? pos.size ?? pos.quantity);
              const sizeText = Number.isFinite(sizeValue)
                ? numberFormatter.format(sizeValue)
                : (pos.net_size ?? pos.size ?? '--');
              const entryPriceText = formatDecimal(pos.entry_price, 4);
              const markPriceText = formatDecimal(pos.mark_price, 4);
              const pnlValue = parseDecimal(pos.pnl);
              const pnlText = Number.isFinite(pnlValue) ? formatSignedNumber(pnlValue, 6) : (pos.pnl ?? '--');
              const pnlClass = percentClass(pnlValue);
              const marginInfo = computePositionMargin(pos);
              const leverageValue = parseDecimal(pos.leverage);
              const notionalValue = Number.isFinite(marginInfo?.notional)
                ? marginInfo.notional
                : (() => {
                    const notionalRaw = parseDecimal(pos.notional_value ?? pos.notional);
                    if (Number.isFinite(notionalRaw)) return notionalRaw;
                    const sizeVal = parseDecimal(pos.net_size ?? pos.size ?? pos.quantity);
                    const priceVal = parseDecimal(pos.mark_price ?? pos.markPrice ?? pos.entry_price ?? pos.entryPrice);
                    return Number.isFinite(sizeVal) && Number.isFinite(priceVal) ? Math.abs(sizeVal * priceVal) : null;
                  })();
              const notionalText = Number.isFinite(notionalValue)
                ? numberFormatter.format(notionalValue)
                : '--';
              const leverageText = Number.isFinite(leverageValue)
                ? `${formatDecimal(leverageValue, 2)}x`
                : '--';
              const initialMarginValue = Number.isFinite(notionalValue) && Number.isFinite(leverageValue) && leverageValue > 0
                ? notionalValue / leverageValue
                : (Number.isFinite(marginInfo?.initialMargin) ? marginInfo.initialMargin : null);
              const initialMarginText = Number.isFinite(initialMarginValue)
                ? numberFormatter.format(initialMarginValue)
                : '--';
              const row = document.createElement('tr');
              row.innerHTML = `
                <td>${escapeHtml(symbol)}</td>
                <td>${escapeHtml(side || '--')}</td>
                <td>${escapeHtml(sizeText)}</td>
                <td>${escapeHtml(entryPriceText)}</td>
                <td>${escapeHtml(markPriceText)}</td>
                <td class="${pnlClass}">${escapeHtml(pnlText)}</td>
                <td>${escapeHtml(notionalText)}</td>
                <td>${escapeHtml(leverageText)}</td>
                <td>${escapeHtml(initialMarginText)}</td>
              `;
              body.appendChild(row);
            }
            card.appendChild(table);
          } else {
            const empty = document.createElement('p');
            empty.className = 'grvt-positions-empty';
            empty.textContent = 'No positions';
            card.appendChild(empty);
          }

          const maintenanceBadge = card.querySelector('[data-metric="maintenance"] .maintenance-ratio');
          if (maintenanceBadge) {
            if (ratioBaseValue && Number.isFinite(maintenanceRequirementTotal) && maintenanceRequirementTotal >= 0) {
              const ratio = maintenanceRequirementTotal / ratioBaseValue;
              maintenanceBadge.textContent = formatPercent(ratio * 100, 2);
            } else if (ratioBaseValue) {
              maintenanceBadge.textContent = formatPercent(0, 2);
            } else {
              maintenanceBadge.textContent = '—';
            }
          }

          paraAccountGrid.appendChild(card);
        }

        if (shouldRebuildGrid) {
          paraAccountGrid.dataset.renderKey = accountRenderKey;
        }

        if (paraAvgMaint) {
          const avgMaintPercent = computePercent(aggregateMaintRequirement, aggregateMaintBase);
          if (Number.isFinite(avgMaintPercent)) {
            paraAvgMaint.textContent = formatPercent(avgMaintPercent, 2);
            paraAvgMaint.title = `Maint req ${numberFormatter.format(aggregateMaintRequirement)} / Base ${numberFormatter.format(aggregateMaintBase)}`;
          } else {
            paraAvgMaint.textContent = '--';
            paraAvgMaint.removeAttribute('title');
          }
        }

        updateParaTransferAgents(transferOptions);
        const paraSymbols = Array.from(symbolCandidates);
        updateParaSymbolOptions(paraSymbols);
        updateParaTwapScheduleSymbolOptions(paraSymbols);
        recomputeGlobalRiskRatio();
        } catch (err) {
          console.warn('renderPara error', err);
          if (paraEmpty) {
            paraEmpty.classList.remove('hidden');
            paraEmpty.textContent = 'Per-account render failed; see console for details.';
          }
          if (paraCard) {
            paraCard.classList.add('hidden');
          }
          updateParaTransferAgents([]);
          updateParaTwapScheduleSymbolOptions([]);
        }
      }

      function renderGrvt(data) {
        if (!grvtAccountCount || !grvtEmpty || !grvtCard) {
          return;
        }

  const grvtMap = data?.grvt_accounts ?? {};
  const entries = Object.entries(grvtMap);
  const nowSec = Date.now() / 1000;
        const marginCache = new WeakMap();
        const getMarginInfo = (position) => {
          if (!position || typeof position !== 'object') return null;
          if (marginCache.has(position)) return marginCache.get(position);
          const info = computePositionMargin(position);
          marginCache.set(position, info);
          return info;
        };
        const symbolCandidates = new Set();
        const instrumentList = Array.isArray(data?.instruments) ? data.instruments : [];
        for (const instrument of instrumentList) {
          const symbolText = normalizeSymbolLabel(instrument);
          if (symbolText) {
            symbolCandidates.add(symbolText);
          }
        }

        if (!entries.length) {
          grvtLatestRiskRatio = null;
          recomputeGlobalRiskRatio();
          grvtCard.classList.add('hidden');
          grvtEmpty.classList.remove('hidden');
          grvtAccountCount.textContent = '0 accounts';
          if (grvtAvgMaint) {
            grvtAvgMaint.textContent = '--';
            grvtAvgMaint.removeAttribute('title');
          }
          if (grvtSourceUpdates) {
            grvtSourceUpdates.textContent = '--';
            grvtSourceUpdates.innerHTML = '';
          }
          if (grvtReduceSuggestionMain) {
            grvtReduceSuggestionMain.textContent = '--';
          }
          if (grvtReduceSuggestionDetail) {
            grvtReduceSuggestionDetail.textContent = '等待账户与持仓数据…';
            grvtReduceSuggestionDetail.style.display = '';
          }
          if (grvtTotalEquity) {
            grvtTotalEquity.textContent = '--';
          }
          if (grvtTotalPosition) {
            grvtTotalPosition.textContent = '--';
          }
          if (grvtTotalPositionNet) {
            grvtTotalPositionNet.textContent = '--';
          }
          if (grvtWalletBalance) {
            grvtWalletBalance.textContent = 'Wallet --';
          }
          if (grvtTransferableTotal) {
            grvtTransferableTotal.textContent = '--';
          }
          if (grvtTransferableNote) {
            grvtTransferableNote.textContent = '等待风险基数数据…';
          }
          if (grvtRiskLevel) {
            grvtRiskLevel.textContent = '--';
            applyRiskTone(grvtRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
          }
          if (grvtRiskDetail) {
            grvtRiskDetail.textContent = 'Awaiting data…';
          }
          if (grvtAccountGrid) {
            grvtAccountGrid.innerHTML = '';
          }
          if (grvtAccountsEmpty) {
            grvtAccountsEmpty.classList.add('hidden');
          }
          updateGrvtTransferAgents([]);
          updateGrvtSymbolOptions(Array.from(symbolCandidates));
          return;
        }

        grvtEmpty.classList.add('hidden');
        grvtCard.classList.remove('hidden');

  let aggregateAccountCount = 0;
  let aggregateTotalPnl = 0;
        let latestUpdate = 0;
        let hasTotal = false;
        const flattenedAccounts = [];
        const transferOptions = [];

        for (const [agentId, snapshot] of entries) {
          if (!snapshot) {
            continue;
          }

          const summary = snapshot.summary ?? {};
          const transferDefaults = snapshot.transfer_defaults && typeof snapshot.transfer_defaults === 'object'
            ? snapshot.transfer_defaults
            : {};
          const agentLabel = summary?.label || summary?.account_label || summary?.name || agentId;
          transferOptions.push({ agentId, label: agentLabel, defaults: transferDefaults });
          const accounts = Array.isArray(snapshot.accounts) ? snapshot.accounts : [];
          const snapshotTs = Number(
            summary.updated_at ??
            summary.last_update_ts ??
            summary.updated_ts ??
            snapshot.updated_at ??
            snapshot.last_update_ts,
          );
          if (Number.isFinite(snapshotTs) && snapshotTs > latestUpdate) {
            latestUpdate = snapshotTs;
          }

          const accountCountFallback = Number(summary.account_count ?? 0);
          if (accounts.length) {
            aggregateAccountCount += accounts.length;
          } else if (Number.isFinite(accountCountFallback) && accountCountFallback > 0) {
            aggregateAccountCount += accountCountFallback;
          }

          let sourceHasTotal = false;

          if (accounts.length) {
            for (const account of accounts) {
              const accountTotal = parseDecimal(account.total_pnl);
              if (Number.isFinite(accountTotal)) {
                aggregateTotalPnl += accountTotal;
                hasTotal = true;
                sourceHasTotal = true;
              }

              const walletValue = parseDecimal(
                account.balance ??
                account.available_balance ??
                account.wallet_balance ??
                account.walletBalance ??
                summary.balance ??
                summary.available_balance ??
                summary.wallet_balance ??
                summary.walletBalance ??
                snapshot.balance ??
                snapshot.available_balance ??
                snapshot.wallet_balance ??
                snapshot.walletBalance
              );
              const availableBalanceValue = parseDecimal(
                account.available_balance ??
                summary.available_balance ??
                snapshot.available_balance
              );
              const equityValue = parseDecimal(
                account.equity ??
                account.available_equity ??
                account.total_equity ??
                account.totalEquity ??
                summary.equity ??
                summary.available_equity ??
                summary.total_equity ??
                summary.totalEquity ??
                snapshot.equity ??
                snapshot.available_equity ??
                snapshot.total_equity ??
                snapshot.totalEquity
              );
              const availableEquityValue = parseDecimal(
                account.available_equity ??
                summary.available_equity ??
                snapshot.available_equity
              );
              const positionsList = Array.isArray(account.positions) ? account.positions : [];
              let initialMarginTotal = 0;
              if (positionsList.length) {
                for (const position of positionsList) {
                  const marginInfo = computePositionMargin(position);
                  if (marginInfo && Number.isFinite(marginInfo.initialMargin)) {
                    initialMarginTotal += marginInfo.initialMargin;
                  }
                }
              }
              const transferableEstimate = estimateTransferableFunds({
                walletValue,
                equityValue,
                availableBalanceValue,
                availableEquityValue,
                totalInitialMargin: initialMarginTotal,
                unrealizedPnl: accountTotal,
              });
              const riskBaseValue = Number.isFinite(equityValue) ? equityValue : walletValue;
              const accountTs = Number(account.updated_at ?? snapshotTs);
              flattenedAccounts.push({
                agentId,
                account,
                summary,
                updatedTs: accountTs,
                totalValue: accountTotal,
                equityValue,
                walletValue,
                availableBalanceValue,
                availableEquityValue,
                initialMarginTotal,
                transferableEstimate,
                riskBaseValue,
                riskRatio: computeRiskRatio(accountTotal, riskBaseValue),
                sortKey: buildAccountSortKey(agentId, account, summary),
              });
            }
          }

          if (!sourceHasTotal) {
            const totalValue = parseDecimal(summary.total_pnl);
            if (Number.isFinite(totalValue)) {
              aggregateTotalPnl += totalValue;
              hasTotal = true;
            }
          }

          if (!accounts.length) {
            const placeholderTotal = parseDecimal(summary.total_pnl);
            const fallbackWallet = parseDecimal(
              summary.balance ??
              summary.available_balance ??
              summary.wallet_balance ??
              summary.walletBalance ??
              snapshot.balance ??
              snapshot.available_balance ??
              snapshot.wallet_balance ??
              snapshot.walletBalance
            );
            const fallbackEquity = parseDecimal(
              summary.equity ??
              summary.available_equity ??
              summary.total_equity ??
              summary.totalEquity ??
              snapshot.equity ??
              snapshot.available_equity ??
              snapshot.total_equity ??
              snapshot.totalEquity
            );
            const fallbackAvailableBalance = parseDecimal(
              summary.available_balance ??
              snapshot.available_balance
            );
            const fallbackAvailableEquity = parseDecimal(
              summary.available_equity ??
              snapshot.available_equity
            );
            const placeholderInitialMargin = 0;
            const placeholderTransferable = estimateTransferableFunds({
              walletValue: fallbackWallet,
              equityValue: fallbackEquity,
              availableBalanceValue: fallbackAvailableBalance,
              availableEquityValue: fallbackAvailableEquity,
              totalInitialMargin: placeholderInitialMargin,
              unrealizedPnl: placeholderTotal,
            });
            const riskBaseValue = Number.isFinite(fallbackEquity) ? fallbackEquity : fallbackWallet;
            flattenedAccounts.push({
              agentId,
              account: null,
              summary,
              updatedTs: snapshotTs,
              totalValue: placeholderTotal,
              equityValue: fallbackEquity,
              walletValue: fallbackWallet,
              availableBalanceValue: fallbackAvailableBalance,
              availableEquityValue: fallbackAvailableEquity,
              initialMarginTotal: placeholderInitialMargin,
              transferableEstimate: placeholderTransferable,
              riskBaseValue,
              riskRatio: computeRiskRatio(placeholderTotal, riskBaseValue),
              sortKey: buildAccountSortKey(agentId, null, summary),
            });
          }
        }

  let aggregateEquity = 0;
  let aggregateWallet = 0;
  let aggregateInitialMargin = 0;
  let aggregatePositionNotional = 0;
  const positionNetByAccount = [];
  let hasEquity = false;
  let hasWallet = false;
        let worstLossAccount = null;

        for (const entry of flattenedAccounts) {
          let accountNetPosition = 0;
          if (Number.isFinite(entry.equityValue)) {
            aggregateEquity += entry.equityValue;
            hasEquity = true;
          }
          if (Number.isFinite(entry.walletValue)) {
            aggregateWallet += entry.walletValue;
            hasWallet = true;
          }
          if (Number.isFinite(entry.initialMarginTotal)) {
            aggregateInitialMargin += entry.initialMarginTotal;
          }
          const totalValue = Number(entry.totalValue);
          if (Number.isFinite(totalValue) && totalValue < 0) {
            const absLoss = Math.abs(totalValue);
            if (!worstLossAccount || absLoss > worstLossAccount.lossValue) {
              worstLossAccount = {
                lossValue: absLoss,
                accountName: entry.account?.name ? String(entry.account.name) : null,
                agentId: entry.agentId ?? 'Source',
              };
            }
          }
        }

        const sourcesLabel = entries.length === 1 ? 'source' : 'sources';
        const accountLabel = aggregateAccountCount === 1 ? 'account' : 'accounts';
        grvtAccountCount.textContent = `${aggregateAccountCount} ${accountLabel} across ${entries.length} ${sourcesLabel}`;

  grvtTotalPnl.textContent = hasTotal ? formatDecimal(aggregateTotalPnl, 2) : '--';
  // ETH/BTC PnL removed from Per Account Net PnL.
        if (grvtTotalEquity) {
          grvtTotalEquity.textContent = hasEquity ? formatDecimal(aggregateEquity, 2) : '--';
        }
        if (grvtWalletBalance) {
          grvtWalletBalance.textContent = hasWallet
            ? `Wallet ${formatDecimal(aggregateWallet, 2)}`
            : 'Wallet --';
        }
        const rawRiskCapacity = hasEquity ? aggregateEquity - aggregateInitialMargin : null;
        const hasRiskCapacityValue = Number.isFinite(rawRiskCapacity) && rawRiskCapacity > 0;
        const riskCapacityBaseNote = hasRiskCapacityValue
          ? `覆盖 ${aggregateAccountCount} 个账户 · Equity-IM`
          : '缺少风险基数数据';
        const bufferedRiskCapacity = evaluateRiskCapacityBuffer({
          hasValue: hasRiskCapacityValue,
          value: hasRiskCapacityValue ? rawRiskCapacity : null,
          timestamp: latestUpdate,
          baseNote: riskCapacityBaseNote,
        });
        const effectiveRiskCapacity = Number.isFinite(bufferedRiskCapacity.displayValue)
          ? bufferedRiskCapacity.displayValue
          : null;

        if (grvtTransferableTotal) {
          grvtTransferableTotal.textContent = Number.isFinite(effectiveRiskCapacity)
            ? formatDecimal(effectiveRiskCapacity, 2)
            : '--';
        }
        if (grvtTransferableNote) {
          grvtTransferableNote.textContent = bufferedRiskCapacity.note;
        }

        grvtLatestRiskRatio = null;
        if (grvtRiskLevel && grvtRiskDetail) {
          const denominator = Number.isFinite(effectiveRiskCapacity) && effectiveRiskCapacity > 0
            ? effectiveRiskCapacity
            : null;
          if (worstLossAccount && denominator) {
            const riskRatio = worstLossAccount.lossValue / denominator;
            grvtLatestRiskRatio = riskRatio;
            grvtRiskLevel.textContent = formatPercent(riskRatio * 100, 2);
            applyRiskTone(grvtRiskLevel, riskRatio, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            const accountLabelText = worstLossAccount.accountName
              ? `${worstLossAccount.accountName} (${worstLossAccount.agentId})`
              : worstLossAccount.agentId;
            const lossText = numberFormatter.format(worstLossAccount.lossValue ?? 0);
            const riskCapacityText = numberFormatter.format(denominator);
            grvtRiskDetail.textContent = `${accountLabelText}亏损 ${lossText} / 基数 ${riskCapacityText} · ${getRiskThresholdSummary()}`;
          } else if (worstLossAccount && !denominator) {
            grvtRiskLevel.textContent = '—';
            applyRiskTone(grvtRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            grvtRiskDetail.textContent = '缺少风险基数数据，无法计算 RISK';
          } else {
            grvtRiskLevel.textContent = '—';
            applyRiskTone(grvtRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            grvtRiskDetail.textContent = '无亏损或缺少盈亏数据';
          }
          recomputeGlobalRiskRatio();
          updateRiskMeta();
        }

        const updatedText = formatTimestamp(latestUpdate);
        if (grvtSummaryTime) {
          grvtSummaryTime.textContent = updatedText ?? '--';
          grvtSummaryTime.classList.remove('hidden');
        }
        if (grvtSummaryUpdated) {
          grvtSummaryUpdated.textContent = updatedText ? `Updated ${updatedText}` : 'Updated —';
          grvtSummaryUpdated.classList.remove('hidden');
        }

        // ---- GRVT reduce suggestion (BTC/ETH) ----
        if (grvtReduceSuggestionMain && grvtReduceSuggestionDetail) {
          const meaningfulAccounts = flattenedAccounts.filter(
            (acc) => Array.isArray(acc?.account?.positions) && acc.account.positions.length,
          );
          const sourceAccounts = (meaningfulAccounts.length ? meaningfulAccounts : flattenedAccounts).map((acc) => ({
            name: acc.account?.name ?? acc.summary?.label ?? acc.agentId,
            total: acc.totalValue,
            ff_pnl: acc.summary?.ff_pnl,
            positions: acc.account?.positions,
          }));
          const candidateAccounts = sourceAccounts.slice(0, 2);
          if (candidateAccounts.length < 2) {
            grvtReduceSuggestionMain.textContent = '—';
            grvtReduceSuggestionDetail.textContent = '至少需要 2 个账户才能计算减仓建议';
            grvtReduceSuggestionDetail.style.display = '';
          } else {
            const suggestion = computeGrvtReduceSuggestion(candidateAccounts);
            if (suggestion?.ok) {
              grvtReduceSuggestionMain.textContent = suggestion.message || '--';
              const topList = Array.isArray(suggestion.top) ? suggestion.top : [];
              if (topList.length > 1) {
                const lines = topList.map((row, idx) => `${idx + 1}. ${row.message}`);
                grvtReduceSuggestionDetail.textContent = `TOP${topList.length}：${lines.join('；')}`;
                grvtReduceSuggestionDetail.style.display = '';
              } else {
                grvtReduceSuggestionDetail.textContent = '';
                grvtReduceSuggestionDetail.style.display = 'none';
              }
            } else {
              grvtReduceSuggestionMain.textContent = '—';
              grvtReduceSuggestionDetail.textContent = suggestion?.message || '无法计算减仓建议';
              grvtReduceSuggestionDetail.style.display = '';
            }
          }
        }

        updateGrvtTransferAgents(transferOptions);

        if (!grvtAccountGrid) {
          return;
        }

        if (!flattenedAccounts.length) {
          if (grvtAccountsEmpty) {
            grvtAccountsEmpty.classList.remove('hidden');
            grvtAccountsEmpty.textContent = 'Waiting for account data…';
          }
          if (grvtAccountGrid) {
            grvtAccountGrid.innerHTML = '';
            grvtAccountGridKey = '';
            grvtAccountGrid.dataset.renderKey = '';
          }
          return;
        }

        if (grvtAccountsEmpty) {
          grvtAccountsEmpty.classList.add('hidden');
        }

        flattenedAccounts.sort((a, b) => {
          const aKey = a.sortKey ?? '';
          const bKey = b.sortKey ?? '';
          if (aKey !== bKey) {
            return aKey.localeCompare(bKey);
          }
          const aTs = Number(a.updatedTs) || 0;
          const bTs = Number(b.updatedTs) || 0;
          return bTs - aTs;
        });

        const accountRenderKey = flattenedAccounts
          .map((entry) => {
            const count = Array.isArray(entry.account?.positions) ? entry.account.positions.length : 0;
            const ts = Number(entry.updatedTs) || 0;
            return `${entry.agentId ?? 'Source'}:${ts}:${count}`;
          })
          .join('|');
        const shouldRebuildGrid = !grvtAccountGridKey || grvtAccountGridKey !== accountRenderKey;
        grvtAccountGridKey = accountRenderKey;

        let aggregateMaintRequirement = 0;
        let aggregateMaintBase = 0;
        const accountStats = [];
        for (const entry of flattenedAccounts) {
          const account = entry.account;
          const positionsRaw = Array.isArray(account?.positions) ? account.positions : [];
          let accountNetPosition = 0;
          let accountPositionNotional = 0;
          const positionInfo = positionsRaw.length
            ? positionsRaw.map((position) => {
                const marginInfo = getMarginInfo(position);
                let notional = (marginInfo && Number.isFinite(marginInfo.notional)) ? marginInfo.notional : null;
                if (!(Number.isFinite(notional))) {
                  const sizeVal = parseDecimal(position?.net_size ?? position?.size ?? position?.quantity);
                  const priceVal = parseDecimal(position?.mark_price ?? position?.markPrice ?? position?.entry_price ?? position?.entryPrice);
                  if (Number.isFinite(sizeVal) && Number.isFinite(priceVal)) {
                    notional = Math.abs(sizeVal * priceVal);
                  }
                }
                if (Number.isFinite(notional)) {
                  accountPositionNotional += Math.abs(notional);
                }
                const netSizeVal = parseDecimal(position?.net_size ?? position?.size ?? position?.quantity);
                const netPriceVal = parseDecimal(position?.mark_price ?? position?.markPrice ?? position?.entry_price ?? position?.entryPrice);
                if (Number.isFinite(netSizeVal) && Number.isFinite(netPriceVal)) {
                  accountNetPosition += netSizeVal * netPriceVal;
                }
                return { position, marginInfo, notional };
              })
            : [];
          aggregatePositionNotional += accountPositionNotional;
          positionNetByAccount.push({
            agentId: entry.agentId ?? 'Source',
            name: entry.account?.name ? String(entry.account.name) : null,
            netValue: accountNetPosition,
          });
          accountStats.push({
            entry,
            account,
            positionsRaw,
            positionInfo,
          });
        }

        if (shouldRebuildGrid) {
          grvtAccountGrid.innerHTML = '';
        }

        for (const stat of accountStats) {
          const entry = stat.entry;
          const account = stat.account;
          const agentId = entry.agentId ?? 'Source';
          const fallbackName = account && account.name ? String(account.name) : 'Account';
          const displayName = account && account.name ? String(account.name) : `${agentId} ${fallbackName}`;
          const accountUpdated = formatTimestamp(entry.updatedTs);
          const equityValue = entry.equityValue;
          const walletValue = entry.walletValue;
          const riskPercent = Number.isFinite(entry.riskRatio) ? entry.riskRatio * 100 : null;

          if (stat.positionsRaw.length) {
            for (const position of stat.positionsRaw) {
              const symbolText = normalizeSymbolLabel(position?.symbol);
              if (symbolText) {
                symbolCandidates.add(symbolText);
              }
            }
          }
          if (!shouldRebuildGrid) {
            continue;
          }

          const card = document.createElement('article');
          card.className = 'grvt-account-card';
          card.innerHTML = `
            <header>
              <div>
                <span class="grvt-account-name">${escapeHtml(displayName)}</span>
                <span class="badge badge-info grvt-source-badge">${escapeHtml(agentId)}</span>
              </div>
              <span class="grvt-account-updated">${escapeHtml(accountUpdated ?? '—')}</span>
            </header>
          `;

          const metrics = document.createElement('dl');
          metrics.className = 'grvt-account-metrics';
          metrics.innerHTML = `
            <div><dt>Equity</dt><dd>${escapeHtml(Number.isFinite(equityValue) ? numberFormatter.format(equityValue) : '--')}</dd></div>
            <div><dt>Wallet</dt><dd>${escapeHtml(Number.isFinite(walletValue) ? numberFormatter.format(walletValue) : '--')}</dd></div>
            <div><dt>Total</dt><dd>${escapeHtml(Number.isFinite(entry.totalValue) ? numberFormatter.format(entry.totalValue) : '--')}</dd></div>
            <div data-metric="transfer"><dt>可转</dt><dd><span class="transfer-amount">—</span></dd></div>
            <div data-metric="maintenance"><dt>Maint.</dt><dd><span class="maintenance-ratio">—</span></dd></div>
            <div data-metric="risk"><dt>Risk</dt><dd><span class="risk-pill risk-pill-inline">—</span></dd></div>
          `;
          card.appendChild(metrics);

          const riskBadge = metrics.querySelector('[data-metric="risk"] .risk-pill');
          if (riskBadge) {
            if (Number.isFinite(riskPercent)) {
              riskBadge.textContent = formatPercent(riskPercent, 2);
            } else {
              riskBadge.textContent = '—';
            }
            const entryRiskRatio = Number.isFinite(entry.riskRatio) ? entry.riskRatio : null;
            applyRiskTone(riskBadge, entryRiskRatio, { variant: 'inline' });
          }

          const maintenanceBadge = metrics.querySelector('[data-metric="maintenance"] .maintenance-ratio');
          let maintenanceRequirementTotal = 0;
          const initialMarginRequirementTotal = Number.isFinite(entry.initialMarginTotal)
            ? entry.initialMarginTotal
            : 0;

          const positions = stat.positionInfo.length
            ? stat.positionInfo
                .slice()
                .sort((a, b) => {
                  const aPnl = parseDecimal(a?.position?.pnl ?? a?.position?.unrealized_pnl ?? a?.position?.unrealizedPnl);
                  const bPnl = parseDecimal(b?.position?.pnl ?? b?.position?.unrealized_pnl ?? b?.position?.unrealizedPnl);
                  const aAbs = Number.isFinite(aPnl) ? Math.abs(aPnl) : -1;
                  const bAbs = Number.isFinite(bPnl) ? Math.abs(bPnl) : -1;
                  if (aAbs !== bAbs) {
                    return bAbs - aAbs;
                  }
                  const aSymbol = normalizeSymbolLabel(a?.position?.symbol);
                  const bSymbol = normalizeSymbolLabel(b?.position?.symbol);
                  return aSymbol.localeCompare(bSymbol, undefined, { sensitivity: 'base' });
                })
                .slice(0, MAX_GRVT_POSITIONS)
            : [];
          if (positions.length) {
            const table = document.createElement('table');
            table.className = 'grvt-positions-table';
            table.innerHTML = `
              <thead>
                <tr>
                  <th>Symbol</th>
                  <th>Side</th>
                  <th>Size</th>
                  <th>Entry</th>
                  <th>Mark</th>
                  <th>PnL</th>
                  <th>Value</th>
                  <th>Init Margin</th>
                </tr>
              </thead>
              <tbody></tbody>
            `;
            const body = table.querySelector('tbody');
            for (const row of positions) {
              const position = row.position;
              const side = position.side ? String(position.side).toUpperCase() : '—';
              const sizeText = formatDecimal(position.net_size, 4);
              const entryText = formatDecimal(position.entry_price, 4);
              const markText = formatDecimal(position.mark_price, 4);
              const pnlValue = parseDecimal(position.pnl ?? position.unrealized_pnl ?? position.unrealizedPnl);
              const pnlText = Number.isFinite(pnlValue) ? formatDecimal(pnlValue, 6) : '--';
              const pnlClass = percentClass(pnlValue);
              const marginInfo = row.marginInfo;
              if (marginInfo && Number.isFinite(marginInfo.maintenanceMargin)) {
                maintenanceRequirementTotal += marginInfo.maintenanceMargin;
              }
              const notionalText = Number.isFinite(row.notional)
                ? numberFormatter.format(row.notional)
                : '--';
              const initialMarginText = marginInfo && Number.isFinite(marginInfo.initialMargin)
                ? numberFormatter.format(marginInfo.initialMargin)
                : '--';
              const rowEl = document.createElement('tr');
              rowEl.innerHTML = `
                <td>${escapeHtml(position.symbol ?? '--')}</td>
                <td>${escapeHtml(side)}</td>
                <td>${escapeHtml(sizeText)}</td>
                <td>${escapeHtml(entryText)}</td>
                <td>${escapeHtml(markText)}</td>
                <td class="${pnlClass}">${escapeHtml(pnlText)}</td>
                <td>${escapeHtml(notionalText)}</td>
                <td>${escapeHtml(initialMarginText)}</td>
              `;
              body.appendChild(rowEl);
            }
            card.appendChild(table);
          } else {
            const empty = document.createElement('p');
            empty.className = 'grvt-positions-empty';
            empty.textContent = account ? 'No open positions' : 'Awaiting account snapshot';
            card.appendChild(empty);
          }

          const transferBadge = metrics.querySelector('[data-metric="transfer"] .transfer-amount');
          if (transferBadge) {
            const transferableEstimate = entry.transferableEstimate;
            if (transferableEstimate) {
              transferBadge.textContent = numberFormatter.format(transferableEstimate.value);
              transferBadge.title = `估算：权益 - 初始保证金 - 未实现盈利 ≈ ${numberFormatter.format(transferableEstimate.raw)}`;
              transferBadge.dataset.state = transferableEstimate.value <= 0 ? 'empty' : 'ok';
            } else {
              transferBadge.textContent = '—';
              transferBadge.title = '缺少必要的账户或仓位数据，无法估算';
              transferBadge.dataset.state = 'unknown';
            }
          }

          if (maintenanceBadge) {
            const ratioBaseValue = Number.isFinite(equityValue) && equityValue > 0
              ? equityValue
              : Number.isFinite(walletValue) && walletValue > 0
                ? walletValue
                : null;
            if (ratioBaseValue && Number.isFinite(maintenanceRequirementTotal) && maintenanceRequirementTotal >= 0) {
              const ratio = maintenanceRequirementTotal / ratioBaseValue;
              maintenanceBadge.textContent = formatPercent(ratio * 100, 2);
              aggregateMaintRequirement += maintenanceRequirementTotal;
              aggregateMaintBase += ratioBaseValue;
            } else if (ratioBaseValue) {
              maintenanceBadge.textContent = formatPercent(0, 2);
            } else {
              maintenanceBadge.textContent = '—';
            }
          }

          grvtAccountGrid.appendChild(card);
        }

        if (shouldRebuildGrid) {
          grvtAccountGrid.dataset.renderKey = accountRenderKey;
        }

        if (grvtTotalPosition) {
          grvtTotalPosition.textContent = aggregatePositionNotional > 0
            ? formatDecimal(aggregatePositionNotional, 2)
            : '--';
        }
        if (grvtTotalPositionNet) {
          const base = positionNetByAccount.filter(row => Number.isFinite(row.netValue));
          const first = base[0];
          const second = base[1];
          const firstText = first ? `账户1: ${formatDecimal(first.netValue, 2)}` : '账户1: --';
          const secondText = second ? `账户2: ${formatDecimal(second.netValue, 2)}` : '账户2: --';
          grvtTotalPositionNet.innerHTML = `${escapeHtml(firstText)}<br>${escapeHtml(secondText)}`;
        }

        if (grvtAvgMaint) {
          const avgMaintPercent = computePercent(aggregateMaintRequirement, aggregateMaintBase);
          if (Number.isFinite(avgMaintPercent)) {
            grvtAvgMaint.textContent = formatPercent(avgMaintPercent, 2);
            grvtAvgMaint.title = `Maint req ${numberFormatter.format(aggregateMaintRequirement)} / Base ${numberFormatter.format(aggregateMaintBase)}`;
          } else {
            grvtAvgMaint.textContent = '--';
            grvtAvgMaint.removeAttribute('title');
          }
        }

        if (grvtSourceUpdates) {
          grvtSourceUpdates.innerHTML = '';
          for (const [agentId, snapshot] of entries) {
            const summary = snapshot?.summary && typeof snapshot.summary === 'object' ? snapshot.summary : {};
            const agentLabel = summary.label || summary.account_label || summary.name || agentId;
            const ts = Number(summary.updated_at ?? snapshot?.updated_at);
            const span = document.createElement('span');
            span.classList.add('badge');
            if (Number.isFinite(ts)) {
              const ageSec = Math.max(0, nowSec - ts);
              const freshnessText = `${formatDuration(ageSec)} ago`;
              if (ageSec >= PARA_STALE_CRIT_SEC) {
                span.classList.add('badge-danger');
                span.textContent = `${agentLabel}: stale · ${freshnessText}`;
              } else if (ageSec >= PARA_STALE_WARN_SEC) {
                span.classList.add('badge-warn');
                span.textContent = `${agentLabel}: delayed · ${freshnessText}`;
              } else {
                span.classList.add('badge-info');
                span.textContent = `${agentLabel}: fresh · ${freshnessText}`;
              }
            } else {
              span.classList.add('badge-muted');
              span.textContent = `${agentLabel}: time N/A`;
            }
            grvtSourceUpdates.appendChild(span);
          }
          if (!grvtSourceUpdates.childElementCount) {
            grvtSourceUpdates.textContent = '--';
          }
        }

        updateGrvtSymbolOptions(Array.from(symbolCandidates));
      }

      function renderBackpack(data) {
        const bpAccountCount = document.getElementById('bp-account-count');
        const bpEmpty = document.getElementById('bp-empty');
        const bpCard = document.getElementById('bp-card');
        const bpTotalPnl = document.getElementById('bp-total-pnl');
        const bpMaxImReq = document.getElementById('bp-max-im-req');
        const bpTotalEquity = document.getElementById('bp-total-equity');
        const bpWalletBalance = document.getElementById('bp-wallet-balance');
        const bpTransferTotal = document.getElementById('bp-transfer-total');
        const bpTransferNote = document.getElementById('bp-transfer-note');
        const bpRiskLevel = document.getElementById('bp-risk-level');
        const bpRiskDetail = document.getElementById('bp-risk-detail');
        const bpAvgMaint = document.getElementById('bp-avg-maint');
        const bpReduceSuggestionMain = document.getElementById('bp-reduce-suggestion-main');
        const bpReduceSuggestionDetail = document.getElementById('bp-reduce-suggestion-detail');
        const bpSummaryTime = document.getElementById('bp-summary-time');
        const bpSummaryUpdated = document.getElementById('bp-summary-updated');
        const bpAccountGrid = document.getElementById('bp-account-grid');
        const bpAccountsEmpty = document.getElementById('bp-accounts-empty');

        if (!bpAccountCount || !bpEmpty || !bpCard) {
          return;
        }

        try {
          // Prefer top-level backpack map; fall back to per-agent payloads.
          const mergedBpMap = {};
          const directMap = data?.backpack_accounts;
          if (directMap && typeof directMap === 'object') {
            for (const [agentId, snapshot] of Object.entries(directMap)) {
              if (snapshot) {
                mergedBpMap[agentId] = snapshot;
              }
            }
          }
          if (!Object.keys(mergedBpMap).length && data?.agents && typeof data.agents === 'object') {
            for (const [agentId, payload] of Object.entries(data.agents)) {
              const snapshot = payload?.backpack_accounts;
              if (snapshot) {
                mergedBpMap[agentId] = snapshot;
              }
            }
          }

          const entries = Object.entries(mergedBpMap);
          const nowSec = Date.now() / 1000;

          if (!entries.length) {
            bpCard.classList.add('hidden');
            bpEmpty.classList.remove('hidden');
            bpAccountCount.textContent = '0 accounts';
            if (bpTotalPnl) bpTotalPnl.textContent = '--';
            if (bpMaxImReq) bpMaxImReq.textContent = '--';
            if (bpTotalEquity) bpTotalEquity.textContent = '--';
            if (bpWalletBalance) bpWalletBalance.textContent = 'Wallet --';
            if (bpTransferTotal) bpTransferTotal.textContent = '--';
            if (bpTransferNote) bpTransferNote.textContent = '等待风险基数数据…';
            if (bpAvgMaint) bpAvgMaint.textContent = '--';
            if (bpRiskLevel) {
              bpRiskLevel.textContent = '--';
              applyRiskTone(bpRiskLevel, null, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
            }
            if (bpRiskDetail) bpRiskDetail.textContent = 'Awaiting data…';
            if (bpSummaryTime) bpSummaryTime.textContent = '--';
            if (bpSummaryUpdated) bpSummaryUpdated.textContent = 'Updated —';
            if (bpAccountGrid) bpAccountGrid.innerHTML = '';
            if (bpAccountsEmpty) bpAccountsEmpty.classList.add('hidden');
            return;
          }

          bpEmpty.classList.add('hidden');
          bpCard.classList.remove('hidden');

          let aggregateAccountCount = 0;
          let aggregateTotalPnl = 0;
          let aggregateEquity = 0;
          let aggregateWallet = 0;
          let hasTotal = false;
          let hasEquity = false;
          let hasWallet = false;
          let latestUpdate = 0;
          const flattenedAccounts = [];
          let sawAnyPositions = false;
          const symbolCandidates = new Set();

          // Summary risk metrics
          let aggregateInitialMargin = 0;
          let maxInitialMargin = null;
          let aggregateMaintRequirement = 0;
          let aggregateMaintBase = 0;
          let worstLossAccount = null;

          for (const [agentId, snapshot] of entries) {
            if (!snapshot || typeof snapshot !== 'object') {
              continue;
            }
            const summaryRaw = snapshot.summary;
            const summary = summaryRaw && typeof summaryRaw === 'object' ? summaryRaw : {};
            const accountsRaw = snapshot.accounts;
            const accounts = Array.isArray(accountsRaw) ? accountsRaw : [];
            const snapshotPositions = Array.isArray(snapshot.positions) ? snapshot.positions : [];
            if (snapshotPositions.length) {
              sawAnyPositions = true;
            }
            const snapshotTs = Number(summary.updated_at ?? snapshot.updated_at);
            if (Number.isFinite(snapshotTs) && snapshotTs > latestUpdate) {
              latestUpdate = snapshotTs;
            }

            // Backpack monitor may choose either: per-account list, or summary-only.
            if (accounts.length) {
              aggregateAccountCount += accounts.length;
              for (const account of accounts) {
                const obj = account && typeof account === 'object' ? account : {};
                const equity = parseDecimal(obj.equity ?? obj.account_value ?? obj.total_account_value);
                const wallet = parseDecimal(obj.balance ?? obj.available_balance ?? obj.cash_balance);

                // Per requirement: Backpack account total should be computed as sum(PnL) across positions.
                // Align with position table UX: prefer computed PnL = size*(mark-entry), fall back to upstream pnl.
                const positionsForTotal = Array.isArray(obj.positions)
                  ? obj.positions
                  : snapshotPositions;
                let computedTotal = 0;
                let hasComputedTotal = false;
                for (const p of (Array.isArray(positionsForTotal) ? positionsForTotal : [])) {
                  const size = parseDecimal(p?.size ?? p?.positionSize ?? p?.qty ?? p?.quantity);
                  const entry = parseDecimal(p?.entryPrice ?? p?.avgEntryPrice ?? p?.avgEntry ?? p?.entry);
                  const mark = parseDecimal(p?.markPrice ?? p?.mark ?? p?.indexPrice ?? p?.lastPrice ?? p?.price);
                  const pnl = (Number.isFinite(size) && Number.isFinite(entry) && Number.isFinite(mark))
                    ? (size * (mark - entry))
                    : parseDecimal(
                      p?.pnl
                        ?? p?.pnlRealized
                        ?? p?.pnl_realized
                        ?? p?.realizedPnl
                        ?? p?.unrealizedPnl
                        ?? p?.pnlUnrealized
                        ?? p?.pnl_unrealized
                    );
                  if (Number.isFinite(pnl)) {
                    computedTotal += pnl;
                    hasComputedTotal = true;
                  }
                }
                const total = hasComputedTotal
                  ? computedTotal
                  : parseDecimal(obj.total_pnl ?? obj.pnl ?? obj.unrealized_pnl);

                if (Number.isFinite(total)) {
                  aggregateTotalPnl += total;
                  hasTotal = true;
                }
                if (Number.isFinite(equity)) {
                  aggregateEquity += equity;
                  hasEquity = true;
                }
                if (Number.isFinite(wallet)) {
                  aggregateWallet += wallet;
                  hasWallet = true;
                }
                flattenedAccounts.push({
                  agentId,
                  name: obj.name ?? obj.account_id ?? obj.id ?? summary.label ?? agentId,
                  total,
                  equity,
                  wallet,
                  // Backpack monitor currently reports positions at snapshot-level.
                  // If per-account positions are not provided, fall back to snapshot.positions.
                  positions: Array.isArray(obj.positions) ? obj.positions : snapshotPositions,
                  // Keep a raw computed total for exact reconciliation in the UI.
                  computedTotal: hasComputedTotal ? computedTotal : null,
                  updatedTs: snapshotTs,
                  sortKey: buildAccountSortKey(agentId, obj, summary),
                });
              }
            } else {
              // Summary-only path: also compute total from snapshot.positions when possible.
              let computedTotal = 0;
              let hasComputedTotal = false;
              for (const p of snapshotPositions) {
                const size = parseDecimal(p?.size ?? p?.positionSize ?? p?.qty ?? p?.quantity);
                const entry = parseDecimal(p?.entryPrice ?? p?.avgEntryPrice ?? p?.avgEntry ?? p?.entry);
                const mark = parseDecimal(p?.markPrice ?? p?.mark ?? p?.indexPrice ?? p?.lastPrice ?? p?.price);
                const pnl = (Number.isFinite(size) && Number.isFinite(entry) && Number.isFinite(mark))
                  ? (size * (mark - entry))
                  : parseDecimal(
                    p?.pnl
                      ?? p?.pnlRealized
                      ?? p?.pnl_realized
                      ?? p?.realizedPnl
                      ?? p?.unrealizedPnl
                      ?? p?.pnlUnrealized
                      ?? p?.pnl_unrealized
                  );
                if (Number.isFinite(pnl)) {
                  computedTotal += pnl;
                  hasComputedTotal = true;
                }
              }
              const total = hasComputedTotal
                ? computedTotal
                : parseDecimal(summary.total_pnl ?? summary.pnl ?? summary.unrealized_pnl);
              const equity = parseDecimal(summary.equity ?? summary.account_value ?? summary.total_account_value);
              const wallet = parseDecimal(summary.balance ?? summary.available_balance ?? summary.cash_balance);
              if (Number.isFinite(total)) {
                aggregateTotalPnl += total;
                hasTotal = true;
              }
              if (Number.isFinite(equity)) {
                aggregateEquity += equity;
                hasEquity = true;
              }
              if (Number.isFinite(wallet)) {
                aggregateWallet += wallet;
                hasWallet = true;
              }
              const accountCountFallback = Number(summary.account_count ?? 0);
              if (Number.isFinite(accountCountFallback) && accountCountFallback > 0) {
                aggregateAccountCount += accountCountFallback;
              } else {
                aggregateAccountCount += 1;
              }
              flattenedAccounts.push({
                agentId,
                name: summary.name ?? summary.label ?? agentId,
                total,
                equity,
                wallet,
                positions: snapshotPositions,
                computedTotal: hasComputedTotal ? computedTotal : null,
                updatedTs: snapshotTs,
                sortKey: buildAccountSortKey(agentId, null, summary),
              });
            }
          }

          // Compute summary metrics based on flattened accounts and their positions.
          // IMPORTANT: compute per-account total from positions first, so Risk Level numerator
          // does not depend on later DOM rendering order.
          for (const entry of flattenedAccounts) {
            const positionsForTotal = Array.isArray(entry.positions) ? entry.positions : [];
            let pnlTotal = 0;
            let hasAnyPnl = false;
            for (const p of positionsForTotal) {
              const netQty = parseDecimal(p?.net_size ?? p?.netQuantity ?? p?.q ?? p?.size ?? p?.positionSize ?? p?.qty ?? p?.quantity);
              const entryPx = parseDecimal(p?.entry_price ?? p?.entryPrice ?? p?.avgEntryPrice ?? p?.avgEntry ?? p?.entry ?? p?.B);
              const markPx = parseDecimal(p?.mark_price ?? p?.markPrice ?? p?.mark ?? p?.indexPrice ?? p?.lastPrice ?? p?.price ?? p?.M);
              const computedPnl = (Number.isFinite(netQty) && Number.isFinite(entryPx) && Number.isFinite(markPx))
                ? (netQty * (markPx - entryPx))
                : null;
              const rawPnl = parseDecimal(
                p?.pnl
                ?? p?.pnlRealized
                ?? p?.unrealizedPnl
                ?? p?.pnlUnrealized
                ?? p?.pnl_unrealized
                ?? p?.unrealized_pnl
                ?? p?.P
              );
              const pnl = Number.isFinite(computedPnl) ? computedPnl : rawPnl;
              if (!Number.isFinite(pnl)) {
                continue;
              }
              pnlTotal += pnl;
              hasAnyPnl = true;
            }
            if (hasAnyPnl) {
              entry.total = pnlTotal;
            }
          }

          for (const entry of flattenedAccounts) {
            const equityValue = Number(entry.equity);
            const walletValue = Number(entry.wallet);

            // Aggregate base values
            if (Number.isFinite(equityValue)) {
              // already aggregated below for display, but keep local for ratios
            }

            // Worst loss numerator for Backpack Risk Level:
            // use the worst per-account TOTAL (only if total < 0), i.e. max(abs(total)).
            const totalValue = Number(entry.total);
            if (Number.isFinite(totalValue) && totalValue < 0) {
              const absLoss = Math.abs(totalValue);
              if (!worstLossAccount || absLoss > worstLossAccount.lossValue) {
                worstLossAccount = {
                  lossValue: absLoss,
                  accountName: entry.name ? String(entry.name) : null,
                  agentId: entry.agentId ?? 'Source',
                };
              }
            }

            // Per-account: sum IM/MM requirement from positions.
            const positions = Array.isArray(entry.positions) ? entry.positions : [];
            let initialMarginTotal = 0;
            let maintenanceRequirementTotal = 0;
            for (const position of positions) {
              const notional = parseDecimal(position?.netExposureNotional ?? position?.notional ?? position?.net_exposure_notional ?? position?.n);
              const imf = parseDecimal(position?.imf ?? position?.initialMarginFraction ?? position?.f);
              const mmf = parseDecimal(position?.mmf ?? position?.maintenanceMarginFraction ?? position?.m);
              if (Number.isFinite(notional) && Number.isFinite(imf)) {
                initialMarginTotal += Math.abs(notional * imf);
              }
              if (Number.isFinite(notional) && Number.isFinite(mmf)) {
                maintenanceRequirementTotal += Math.abs(notional * mmf);
              }
            }

            if (Number.isFinite(initialMarginTotal)) {
              aggregateInitialMargin += initialMarginTotal;
              if (maxInitialMargin === null || initialMarginTotal > maxInitialMargin) {
                maxInitialMargin = initialMarginTotal;
              }
            }

            const ratioBaseValue = Number.isFinite(equityValue) && equityValue > 0
              ? equityValue
              : Number.isFinite(walletValue) && walletValue > 0
                ? walletValue
                : null;
            if (ratioBaseValue && Number.isFinite(maintenanceRequirementTotal) && maintenanceRequirementTotal >= 0) {
              aggregateMaintRequirement += maintenanceRequirementTotal;
              aggregateMaintBase += ratioBaseValue;
            }
          }

          // Symbols for broadcast-adjust dropdown (best-effort based on current positions).
          for (const entry of flattenedAccounts) {
            const positions = Array.isArray(entry?.positions) ? entry.positions : [];
            for (const position of positions) {
              const raw = position?.symbol ?? position?.s;
              if (raw) {
                symbolCandidates.add(String(raw));
              }
            }
          }

          updateBpSymbolOptions(Array.from(symbolCandidates));

          // Populate internal transfer directory (agent_id -> internal address).
          try {
            renderBpInternalTransferDirectory({ backpack_accounts: mergedBpMap });
          } catch (_) {
            // ignore
          }

          const sourcesLabel = entries.length === 1 ? 'source' : 'sources';
          const accountLabel = aggregateAccountCount === 1 ? 'account' : 'accounts';
          bpAccountCount.textContent = `${aggregateAccountCount} ${accountLabel} across ${entries.length} ${sourcesLabel}`;

          if (bpTotalPnl) bpTotalPnl.textContent = hasTotal ? numberFormatter.format(aggregateTotalPnl) : '--';
          if (bpMaxImReq) bpMaxImReq.textContent = Number.isFinite(maxInitialMargin) ? numberFormatter.format(maxInitialMargin) : '--';
          if (bpTotalEquity) bpTotalEquity.textContent = hasEquity ? numberFormatter.format(aggregateEquity) : '--';
          if (bpWalletBalance) bpWalletBalance.textContent = hasWallet ? `Wallet ${numberFormatter.format(aggregateWallet)}` : 'Wallet --';

          // Risk capacity & risk level (PARA-like): capacity = equity - 1.5×max(IM)
          // (see PARA implementation around para-transfer-note).
          if (bpTransferTotal || bpTransferNote || bpRiskLevel || bpRiskDetail) {
            const maxInitialMarginValue = Number.isFinite(maxInitialMargin) ? maxInitialMargin : 0;
            const rawCapacity = hasEquity && maxInitialMarginValue > 0
              ? (aggregateEquity - 1.5 * maxInitialMarginValue)
              : null;
            const hasCapacity = Number.isFinite(rawCapacity) && rawCapacity > 0;
            if (bpTransferTotal) {
              bpTransferTotal.textContent = hasCapacity ? numberFormatter.format(rawCapacity) : '--';
            }
            if (bpTransferNote) {
              bpTransferNote.textContent = hasCapacity
                ? `覆盖 ${aggregateAccountCount} 个账户 · 风险裕量 = Equity - 1.5×max(IM ${numberFormatter.format(maxInitialMarginValue)})`
                : '缺少风险裕量数据';
            }

            if (bpAvgMaint) {
              const avgMaintPercent = computePercent(aggregateMaintRequirement, aggregateMaintBase);
              if (Number.isFinite(avgMaintPercent)) {
                bpAvgMaint.textContent = formatPercent(avgMaintPercent, 2);
                bpAvgMaint.title = `Maint req ${numberFormatter.format(aggregateMaintRequirement)} / Base ${numberFormatter.format(aggregateMaintBase)}`;
              } else {
                bpAvgMaint.textContent = '--';
                bpAvgMaint.removeAttribute('title');
              }
            }

            if (bpRiskLevel) {
              let riskRatio = null;
              if (worstLossAccount && hasCapacity) {
                riskRatio = worstLossAccount.lossValue / rawCapacity;
                bpRiskLevel.textContent = formatPercent(riskRatio * 100, 2);
              } else {
                bpRiskLevel.textContent = '—';
              }
              bpLatestRiskRatio = Number.isFinite(riskRatio) ? riskRatio : null;
              applyRiskTone(bpRiskLevel, riskRatio, { variant: 'summary', bands: GLOBAL_RISK_GRADIENTS });
              if (bpRiskDetail) {
                if (worstLossAccount && hasCapacity) {
                  const who = worstLossAccount.accountName
                    ? `${worstLossAccount.accountName} (${worstLossAccount.agentId})`
                    : worstLossAccount.agentId;
                  bpRiskDetail.textContent = `${who}亏损 ${numberFormatter.format(worstLossAccount.lossValue)} / 基数 ${numberFormatter.format(rawCapacity)} · ${getRiskThresholdSummary()}`;
                } else if (worstLossAccount && !hasCapacity) {
                  bpRiskDetail.textContent = '缺少风险基数数据，无法计算 RISK';
                } else {
                  bpRiskDetail.textContent = '无亏损或缺少盈亏数据';
                }
              }
            }
          }

          const updatedText = formatTimestamp(latestUpdate);
          if (bpSummaryTime) bpSummaryTime.textContent = updatedText ?? '--';
          if (bpSummaryUpdated) {
            const baseText = updatedText ? `Updated ${updatedText}` : 'Updated —';
            bpSummaryUpdated.textContent = (!sawAnyPositions && flattenedAccounts.length)
              ? `${baseText} · 未收到 positions（请确认已运行 backpack_account_monitor 并上报持仓）`
              : baseText;
          }

          // ---- Backpack reduce suggestion (BTC/ETH) ----
          if (bpReduceSuggestionMain && bpReduceSuggestionDetail) {
            const meaningfulAccounts = flattenedAccounts.filter((acc) => Array.isArray(acc.positions) && acc.positions.length);
            const suggestion = computeBpReduceSuggestion(meaningfulAccounts.length ? meaningfulAccounts : flattenedAccounts);
            if (suggestion?.ok) {
              bpReduceSuggestionMain.textContent = suggestion.message || '--';
              // Keep it minimal (single line), same as PARA.
              bpReduceSuggestionDetail.textContent = '';
              bpReduceSuggestionDetail.style.display = 'none';
            } else {
              bpReduceSuggestionMain.textContent = '—';
              bpReduceSuggestionDetail.textContent = '';
              bpReduceSuggestionDetail.style.display = 'none';
            }
          }

          if (!bpAccountGrid) {
            return;
          }

          if (!flattenedAccounts.length) {
            if (bpAccountsEmpty) {
              bpAccountsEmpty.classList.remove('hidden');
              bpAccountsEmpty.textContent = 'No account rows; check monitor payload shape.';
            }
            return;
          }
          if (bpAccountsEmpty) {
            bpAccountsEmpty.classList.add('hidden');
          }

          flattenedAccounts.sort((a, b) => {
            const aKey = a.sortKey ?? '';
            const bKey = b.sortKey ?? '';
            if (aKey !== bKey) {
              return aKey.localeCompare(bKey);
            }
            return (Number(b.updatedTs ?? 0) || 0) - (Number(a.updatedTs ?? 0) || 0);
          });

          const accountRenderKey = flattenedAccounts
            .map((entry) => {
              const count = Array.isArray(entry.positions) ? entry.positions.length : 0;
              const ts = Number(entry.updatedTs) || 0;
              return `${entry.agentId ?? 'source'}:${ts}:${count}`;
            })
            .join('|');
          const shouldRebuildGrid = !bpAccountGridKey || bpAccountGridKey !== accountRenderKey;
          bpAccountGridKey = accountRenderKey;
          if (!shouldRebuildGrid) {
            return;
          }

          bpAccountGrid.innerHTML = '';

          for (const entry of flattenedAccounts) {
            const card = document.createElement('article');
            card.className = 'grvt-account-card';

            // NOTE: Backpack card TOTAL should match the sum of PnL shown in the positions table.
            // We'll compute a table-total below and then patch the displayed TOTAL.
            const totalText = Number.isFinite(entry.total) ? numberFormatter.format(entry.total) : '--';
            const equityText = Number.isFinite(entry.equity) ? numberFormatter.format(entry.equity) : '--';
            const walletText = Number.isFinite(entry.wallet) ? numberFormatter.format(entry.wallet) : '--';
            const updatedText = formatTimestamp(entry.updatedTs) ?? '—';
            const ageSec = Number.isFinite(entry.updatedTs) ? Math.max(0, nowSec - entry.updatedTs) : null;
            let freshnessBadge = '';
            if (Number.isFinite(ageSec)) {
              const freshnessText = `${formatDuration(ageSec)} ago`;
              if (ageSec >= PARA_STALE_CRIT_SEC) {
                freshnessBadge = `<span class="badge badge-danger">Stale · ${escapeHtml(freshnessText)}</span>`;
              } else if (ageSec >= PARA_STALE_WARN_SEC) {
                freshnessBadge = `<span class="badge badge-warn">Delayed · ${escapeHtml(freshnessText)}</span>`;
              } else {
                freshnessBadge = `<span class="badge badge-info">Fresh · ${escapeHtml(freshnessText)}</span>`;
              }
            } else {
              freshnessBadge = '<span class="badge badge-muted">Time N/A</span>';
            }

            card.innerHTML = `
              <header>
                <div>
                  <span class="grvt-account-name">${escapeHtml(entry.name ?? 'Account')}</span>
                  <span class="badge badge-info grvt-source-badge">${escapeHtml(entry.agentId ?? 'source')}</span>
                </div>
                <div class="grvt-account-badges">${freshnessBadge}</div>
                <span class="grvt-account-updated">${escapeHtml(updatedText)}</span>
              </header>
            `;

            // Backpack cards previously only showed 3 metrics. Add the shared metric strip so
            // we can surface Maint. (maintenance margin ratio) consistently.
            const metrics = document.createElement('dl');
            metrics.className = 'grvt-account-metrics';
            metrics.innerHTML = `
              <div><dt>Total</dt><dd>${escapeHtml(totalText)}</dd></div>
              <div><dt>Equity</dt><dd>${escapeHtml(equityText)}</dd></div>
              <div><dt>Balance</dt><dd>${escapeHtml(walletText)}</dd></div>
              <div data-metric="maintenance"><dt>Maint.</dt><dd><span class="maintenance-ratio">—</span></dd></div>
            `;
            card.appendChild(metrics);

            // Positions table (best-effort). Expect monitor-side normalized keys, but
            // also tolerate raw Backpack keys.
            const positionsList = Array.isArray(entry.positions) ? entry.positions : [];
            if (positionsList.length) {
              const table = document.createElement('table');
              table.className = 'grvt-positions-table';
              table.innerHTML = `
                <thead>
                  <tr>
                    <th>Symbol</th>
                    <th>Side</th>
                    <th>Size</th>
                    <th>Value</th>
                    <th>Entry</th>
                    <th>Mark</th>
                    <th>PnL</th>
                    <th>Init Margin</th>
                  </tr>
                </thead>
                <tbody></tbody>
              `;
              const body = table.querySelector('tbody');
              // Maintain per-account totals for a maintenance ratio badge.
              // Per openapi_bp.json: positions can include imf/mmf and netExposureNotional.
              let bpMaintenanceRequirementTotal = 0;
              let bpTablePnlTotal = 0;
              let bpTablePnlHasAny = false;
              for (const position of positionsList) {
                const symbol = position?.symbol ?? position?.s ?? '--';
                const netQty = parseDecimal(position?.net_size ?? position?.netQuantity ?? position?.q);
                const entryPx = parseDecimal(position?.entry_price ?? position?.entryPrice ?? position?.B);
                const markPx = parseDecimal(position?.mark_price ?? position?.markPrice ?? position?.M);
                // Backpack: prefer computed PnL = size * (mark - entry).
                // - LONG (size>0): profit when mark > entry
                // - SHORT (size<0): profit when mark < entry
                // Fallback to upstream PnL fields only when inputs are missing.
                const computedPnl = (Number.isFinite(netQty) && Number.isFinite(entryPx) && Number.isFinite(markPx))
                  ? (netQty * (markPx - entryPx))
                  : null;
                const rawPnl = parseDecimal(
                  position?.pnl
                  ?? position?.pnlRealized
                  ?? position?.unrealizedPnl
                  ?? position?.P
                );
                const pnl = Number.isFinite(computedPnl) ? computedPnl : rawPnl;
                if (Number.isFinite(pnl)) {
                  bpTablePnlTotal += pnl;
                  bpTablePnlHasAny = true;
                }
                const positionValue = (Number.isFinite(netQty) && Number.isFinite(markPx))
                  ? Math.abs(netQty) * markPx
                  : null;
                const pnlClass = percentClass(pnl);
                const side = Number.isFinite(netQty)
                  ? (netQty >= 0 ? 'LONG' : 'SHORT')
                  : (position?.side ? String(position.side).toUpperCase() : '—');

                // Initial margin (absolute) = notional * imf (openapi: FuturePositionWithMargin.imf)
                const bpNotional = parseDecimal(position?.netExposureNotional ?? position?.notional ?? position?.net_exposure_notional ?? position?.n);
                const bpImf = parseDecimal(position?.imf ?? position?.initialMarginFraction ?? position?.f);
                const bpMmf = parseDecimal(position?.mmf ?? position?.maintenanceMarginFraction ?? position?.m);
                const bpInitialMargin = (Number.isFinite(bpNotional) && Number.isFinite(bpImf)) ? Math.abs(bpNotional * bpImf) : null;
                if (Number.isFinite(bpNotional) && Number.isFinite(bpMmf)) {
                  bpMaintenanceRequirementTotal += Math.abs(bpNotional * bpMmf);
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                  <td>${escapeHtml(String(symbol))}</td>
                  <td>${escapeHtml(String(side))}</td>
                  <td>${escapeHtml(Number.isFinite(netQty) ? formatDecimal(Math.abs(netQty), 4) : '--')}</td>
                  <td>${escapeHtml(Number.isFinite(positionValue) ? numberFormatter.format(positionValue) : '--')}</td>
                  <td>${escapeHtml(Number.isFinite(entryPx) ? formatDecimal(entryPx, 4) : '--')}</td>
                  <td>${escapeHtml(Number.isFinite(markPx) ? formatDecimal(markPx, 4) : '--')}</td>
                  <td class="${pnlClass}">${escapeHtml(Number.isFinite(pnl) ? formatDecimal(pnl, 6) : '--')}</td>
                  <td>${escapeHtml(Number.isFinite(bpInitialMargin) ? numberFormatter.format(bpInitialMargin) : '--')}</td>
                `;
                body.appendChild(row);
              }
              card.appendChild(table);

              // Keep data-layer total and displayed TOTAL consistent with the table PnL sum.
              // This ensures Risk Level numerator (worst account total) matches what the user sees.
              try {
                if (bpTablePnlHasAny) {
                  entry.total = bpTablePnlTotal;
                  const totalDd = card.querySelector('.grvt-account-metrics > div:first-child dd');
                  if (totalDd) {
                    totalDd.textContent = numberFormatter.format(bpTablePnlTotal);
                    totalDd.title = 'sum(PnL rows)';
                  }
                }
              } catch (_) {
                // ignore
              }

              // Update maintenance ratio badge for Backpack cards.
              try {
                const maintenanceBadge = card.querySelector('[data-metric="maintenance"] .maintenance-ratio');
                if (maintenanceBadge) {
                  const ratioBaseValue = Number.isFinite(entry.equity) && entry.equity > 0
                    ? entry.equity
                    : Number.isFinite(entry.wallet) && entry.wallet > 0
                      ? entry.wallet
                      : null;
                  if (ratioBaseValue && Number.isFinite(bpMaintenanceRequirementTotal) && bpMaintenanceRequirementTotal >= 0) {
                    const ratio = bpMaintenanceRequirementTotal / ratioBaseValue;
                    maintenanceBadge.textContent = formatPercent(ratio * 100, 2);
                    maintenanceBadge.title = `Σ(Maint req) ${numberFormatter.format(bpMaintenanceRequirementTotal)} / Base ${numberFormatter.format(ratioBaseValue)}`;
                  } else {
                    maintenanceBadge.textContent = '—';
                    maintenanceBadge.removeAttribute('title');
                  }
                }
              } catch (_) {
                // ignore
              }
            }

            bpAccountGrid.appendChild(card);
          }
        } catch (err) {
          console.warn('renderBackpack error', err);
          if (bpEmpty) {
            bpEmpty.classList.remove('hidden');
            bpEmpty.textContent = 'Backpack render failed; see console for details.';
          }
          if (bpCard) {
            bpCard.classList.add('hidden');
          }
        }
      }

      function renderAggregate(data) {
        // Aggregated KPI cards (position/cycles/pnl/volume/balances/runtime) were removed from the UI.

        if (data.last_update_ts) {
          const updatedDate = new Date(Number(data.last_update_ts) * 1000);
          const latestAgent = data.last_agent_id ? ` (agent: ${data.last_agent_id})` : '';
          updatedElement.textContent = `Last update: ${updatedDate.toLocaleString()}${latestAgent}`;
        } else {
          updatedElement.textContent = 'Awaiting data…';
        }
      }

      function updateBatchButtons() {
        if (!pauseAllButton || !resumeAllButton) {
          return;
        }

        if (batchBusy) {
          pauseAllButton.disabled = true;
          resumeAllButton.disabled = true;
        } else {
          pauseAllButton.disabled = lastDefaultPaused;
          resumeAllButton.disabled = !lastDefaultPaused;
        }

        pauseAllButton.classList.toggle('button-ghost', lastDefaultPaused);
        resumeAllButton.classList.toggle('button-ghost', !lastDefaultPaused);
      }

      function redirectIfUnauthorized(response) {
        if (response && response.status === 401) {
          window.location.href = '/login';
        }
      }

      async function sendControl(agentId, action, button) {
        if (!agentId || !action) {
          return;
        }

        const previousText = button?.textContent ?? '';
        if (button) {
          button.disabled = true;
          button.textContent = action === 'pause' ? 'Pausing…' : 'Resuming…';
        }

        try {
          const response = await fetch('/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ agent_id: agentId, action })
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          await refreshMetrics();
        } catch (error) {
          updatedElement.textContent = `Control update failed: ${error}`;
        } finally {
          if (button) {
            button.disabled = false;
            button.textContent = previousText || (action === 'pause' ? 'Pause' : 'Resume');
          }
        }
      }

      async function sendBatchControl(action, button) {
        if (!action) {
          return;
        }

        const buttons = [pauseAllButton, resumeAllButton].filter(Boolean);
        const previousTexts = new Map();

        batchBusy = true;
        updateBatchButtons();

        if (button) {
          previousTexts.set(button, button.textContent);
          button.textContent = action === 'pause' ? 'Pausing…' : 'Resuming…';
        }

        try {
          const response = await fetch('/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ scope: 'all', action })
          });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          await refreshMetrics();
        } catch (error) {
          updatedElement.textContent = `Control update failed: ${error}`;
        } finally {
          batchBusy = false;
          buttons.forEach((btn) => {
            if (btn && previousTexts.has(btn)) {
              btn.textContent = previousTexts.get(btn);
            }
          });
          updateBatchButtons();
        }
      }

      function renderAgents(data) {
        try {
          let agentMap = data?.agents;
          if (!agentMap || typeof agentMap !== 'object') {
            agentMap = {};
          }

        // Fallback: if no agents payload, synthesize from other sections (PARA/GRVT) so Per-VPS pane
        // still shows the sources we have data for.
        if (Object.keys(agentMap).length === 0) {
          const synthetic = {};
          const paradexMap = data?.paradex_accounts;
          if (paradexMap && typeof paradexMap === 'object') {
            for (const [agentId, snapshot] of Object.entries(paradexMap)) {
              if (!synthetic[agentId]) {
                const summaryTs = Number(snapshot?.summary?.updated_at ?? snapshot?.updated_at ?? 0);
                synthetic[agentId] = {
                  position: 0,
                  total_cycles: 0,
                  cumulative_pnl: 0,
                  cumulative_volume: 0,
                  available_balance: snapshot?.summary?.balance,
                  total_account_value: snapshot?.summary?.equity ?? snapshot?.summary?.available_equity,
                  instrument: snapshot?.summary?.instrument ?? 'PARADEX',
                  last_update_ts: Number.isFinite(summaryTs) ? summaryTs : undefined,
                };
              }
            }
          }
          const grvtMap = data?.grvt_accounts;
          if (grvtMap && typeof grvtMap === 'object') {
            for (const [agentId, snapshot] of Object.entries(grvtMap)) {
              if (!synthetic[agentId]) {
                const summaryTs = Number(snapshot?.summary?.updated_at ?? snapshot?.updated_at ?? 0);
                synthetic[agentId] = {
                  position: 0,
                  total_cycles: 0,
                  cumulative_pnl: 0,
                  cumulative_volume: 0,
                  available_balance: snapshot?.summary?.total_equity ?? snapshot?.summary?.wallet_balance,
                  total_account_value: snapshot?.summary?.total_equity,
                  instrument: snapshot?.summary?.instrument ?? 'GRVT',
                  last_update_ts: Number.isFinite(summaryTs) ? summaryTs : undefined,
                };
              }
            }
          }
          const syntheticKeys = Object.keys(synthetic);
          if (syntheticKeys.length) {
            agentMap = synthetic;
          }
        }

          const entries = Object.entries(agentMap ?? {});
          const staleSet = new Set(data?.stale_agents ?? []);
          const lastAgentId = data?.last_agent_id ?? null;
          const controls = data?.controls ?? {};

          agentGrid.innerHTML = '';

          if (!entries.length) {
            agentGrid.classList.add('hidden');
            agentEmpty.classList.remove('hidden');
            const agentCountValue = toNumber(data?.agent_count);
            if (agentCountValue > 0) {
              agentEmpty.textContent = `有 ${agentCountValue} 台 VPS 在统计，但未收到明细；检查 /metrics 是否返回 agents 字段`;
            } else {
              agentEmpty.textContent = 'Waiting for VPS metrics…';
            }
            agentCount.textContent = `${agentCountValue || 0} active`;
            return;
          }

        agentGrid.classList.remove('hidden');
        agentEmpty.classList.add('hidden');

        entries.sort((a, b) => a[0].localeCompare(b[0], undefined, { sensitivity: 'base' }));

        let activeCount = 0;
        let pausedCount = 0;

  for (const [agentId, metrics] of entries) {
          const safeId = escapeHtml(agentId);
          const position = numberFormatter.format(toNumber(metrics.position));
          const pnl = numberFormatter.format(toNumber(metrics.cumulative_pnl));
          const volume = numberFormatter.format(toNumber(metrics.cumulative_volume));
          const available = numberFormatter.format(
            toNumber(
              metrics.available_balance ??
              metrics.available ??
              metrics.total_available_balance
            )
          );
          const accountValue = numberFormatter.format(
            toNumber(
              metrics.total_account_value ??
              metrics.account_value ??
              metrics.total_asset_value
            )
          );
          const instrumentText = metrics.instrument ? escapeHtml(metrics.instrument) : '—';
          const runtimeSeconds = toNumber(metrics.runtime_seconds);
          const runtimeDisplay = escapeHtml(formatDuration(runtimeSeconds));
          let depthDisplay = '—';
          if (metrics.depths && typeof metrics.depths === 'object') {
            const depthEntries = Object.entries(metrics.depths)
              .map(([key, value]) => {
                const depthValue = Number(value);
                if (!Number.isFinite(depthValue)) {
                  return null;
                }
                return `${escapeHtml(String(key))} ${depthValue}`;
              })
              .filter(Boolean);
            if (depthEntries.length) {
              depthDisplay = depthEntries.join(' · ');
            }
          }
          const cyclesRaw = Number(metrics.total_cycles ?? 0);
          const cycles = Number.isFinite(cyclesRaw) ? cyclesRaw : '--';

          const updatedTs = Number(metrics.last_update_ts ?? 0) * 1000;
          const updatedText = Number.isFinite(updatedTs) && updatedTs > 0
            ? new Date(updatedTs).toLocaleString()
            : 'Awaiting data…';

          const control = controls[agentId] ?? {};
          const isPaused = Boolean(control.paused);
          const controlTs = Number(control.updated_at ?? 0) * 1000;
          const pausedSinceText = isPaused && Number.isFinite(controlTs) && controlTs > 0
            ? new Date(controlTs).toLocaleString()
            : null;

          const card = document.createElement('article');
          card.className = 'agent-card card';

          const isStale = staleSet.has(agentId);
          if (isStale) {
            card.classList.add('stale');
          }
          if (isPaused) {
            card.classList.add('paused');
            pausedCount += 1;
          }
          if (!isStale && !isPaused) {
            activeCount += 1;
          }
          if (lastAgentId && agentId === lastAgentId) {
            card.classList.add('recent');
          }

          const statusParts = [];
          statusParts.push(isPaused ? 'Paused' : 'Active');
          if (isStale) {
            statusParts.push('Stale');
          }
          if (pausedSinceText) {
            statusParts.push(`since ${pausedSinceText}`);
          }
          const statusText = statusParts.join(' · ');

          card.innerHTML = `
            <header>
              <span class="agent-name">${safeId}</span>
              <span class="badge-group">
                ${lastAgentId && agentId === lastAgentId ? '<span class="badge badge-info">Latest</span>' : ''}
                ${isPaused ? '<span class="badge badge-muted">Paused</span>' : ''}
                ${isStale ? '<span class="badge badge-warn">Stale</span>' : ''}
              </span>
            </header>
            <dl class="agent-metrics">
              <div><dt>Position</dt><dd>${position}</dd></div>
              <div><dt>Total Cycles</dt><dd>${cycles}</dd></div>
              <div><dt>Runtime</dt><dd>${runtimeDisplay}</dd></div>
              <div><dt>Cumulative PnL</dt><dd>${pnl}</dd></div>
              <div><dt>Total Volume</dt><dd>${volume}</dd></div>
              <div><dt>Available</dt><dd>${available}</dd></div>
              <div><dt>Account Value</dt><dd>${accountValue}</dd></div>
              <div><dt>Instrument</dt><dd>${instrumentText}</dd></div>
              <div><dt>Depth</dt><dd>${escapeHtml(depthDisplay)}</dd></div>
            </dl>
            <p class="timestamp">${escapeHtml(statusText || 'Status unknown')}</p>
            <div class="control-actions">
              <button type="button" data-agent="${safeId}">${isPaused ? 'Resume' : 'Pause'}</button>
              <span class="updated-note">Updated ${escapeHtml(updatedText)}</span>
            </div>
          `;

          const controlButton = card.querySelector('button');
          if (controlButton) {
            controlButton.addEventListener('click', () => {
              const action = isPaused ? 'resume' : 'pause';
              sendControl(agentId, action, controlButton);
            });
          }

          agentGrid.appendChild(card);
        }

        const summaryParts = [];
        summaryParts.push(`${activeCount} active`);
        summaryParts.push(`${pausedCount} paused`);
        summaryParts.push(`${entries.length} total`);
        agentCount.textContent = summaryParts.join(' · ');

        const defaultPaused = Boolean(data?.default_paused);
        if (defaultPauseIndicator) {
          defaultPauseIndicator.classList.toggle('hidden', !defaultPaused);
        }

        lastDefaultPaused = defaultPaused;
        updateBatchButtons();
        } catch (err) {
          console.warn('renderAgents error', err);
          if (agentEmpty) {
            agentEmpty.classList.remove('hidden');
            agentEmpty.textContent = 'Per-VPS section failed to render; check console for details.';
          }
          if (agentGrid) {
            agentGrid.classList.add('hidden');
          }
        }
      }

      function describeStrategyAction(action) {
        if (!action) {
          return '—';
        }
        let text = String(action).trim();
        if (text.includes('.')) {
          text = text.split('.').pop() || text;
        }
        text = text.replace(/_/g, ' ');
        return text.charAt(0).toUpperCase() + text.slice(1);
      }

      function describeStrategyDirection(direction) {
        if (!direction) {
          return '—';
        }
        let text = String(direction).trim();
        if (text.includes('.')) {
          text = text.split('.').pop() || text;
        }
        return text.replace(/_/g, ' ').toUpperCase();
      }

      // Strategy + spread monitors removed.

      // renderVolatility + simulation helpers removed.

      async function refreshMetrics() {
        try {
          const response = await fetch('/metrics', { cache: 'no-store' });
          redirectIfUnauthorized(response);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();
          lastMetricsSnapshot = data;
          renderAggregate(data);
          // BTC/ETH Volatility panel removed.
          renderPriceChart(data);
          renderParaPriceChart(data);
          renderAgents(data);
          renderPara(data);
          renderGrvt(data);
          renderBackpack(data);
          renderParaAdjustments(data?.para_adjustments);
          renderParaTwapScheduler(data?.para_twap_scheduler);
          renderGrvtAdjustments(data?.grvt_adjustments);
          const bpAdjPayload = await fetchBackpackAdjustments();
          renderBackpackAdjustments(bpAdjPayload);

          const bpTransferPayload = await fetchBackpackTransferHistory();
          if (bpTransferPayload && typeof renderBpTransferAdjustments === 'function') {
            const adj = Array.isArray(bpTransferPayload?.adjustments) ? bpTransferPayload.adjustments : [];
            renderBpTransferAdjustments(adj);
          }
          renderAutoBalance(data?.auto_balance, data?.agents);
          renderParaAutoBalance(data?.para_auto_balance, data?.paradex_accounts || data?.agents);
          renderBpAutoBalance(data?.bp_auto_balance, data?.backpack_accounts || data?.agents);
          maybeRefreshRiskHistory();
        } catch (error) {
          updatedElement.textContent = `Dashboard error: ${error}`;
          agentCount.textContent = '—';
          agentGrid.innerHTML = '';
          agentGrid.classList.add('hidden');
          agentEmpty.classList.remove('hidden');
          agentEmpty.textContent = 'Unable to load metrics at the moment.';
          // BTC/ETH Volatility panel removed.
        }
      }

      // Wire PARA scheduled TWAP buttons
      if (paraTwapScheduleStartButton) {
        paraTwapScheduleStartButton.addEventListener('click', () => createParaTwapSchedulerTaskFromForm());
      }
      if (paraTwapScheduleSaveEditButton) {
        paraTwapScheduleSaveEditButton.addEventListener('click', () => saveEditedParaTwapSchedulerTask());
      }
      if (paraTwapScheduleStopButton) {
        paraTwapScheduleStopButton.addEventListener('click', () => disableParaTwapScheduler());
      }
      if (paraTwapScheduleRefreshButton) {
        paraTwapScheduleRefreshButton.addEventListener('click', () => refreshParaTwapScheduler());
      }

      // Task list actions (event delegation).
      const paraTwapTaskRoot = document.getElementById('paraTwapScheduleTasks');
      if (paraTwapTaskRoot) {
        paraTwapTaskRoot.addEventListener('click', async (evt) => {
          const el = evt?.target;
          if (!el) return;
          const editId = el.getAttribute && el.getAttribute('data-ptwap-task-edit');
          const fireId = el.getAttribute && el.getAttribute('data-ptwap-task-fire');
          const removeId = el.getAttribute && el.getAttribute('data-ptwap-task-remove');
          if (editId) {
            evt.preventDefault();
            const draft = Array.isArray(paraTwapSchedulerTasksDraft) ? paraTwapSchedulerTasksDraft : [];
            const target = draft.find((t) => t && String(t.task_id) === String(editId));
            if (target) {
              _applyTaskToForm(target);
              _setEditingTask(target);
            }
            return;
          }
          if (fireId) {
            evt.preventDefault();
            try {
              await fireParaTwapSchedulerTaskNow(fireId);
            } catch (err) {
              if (paraTwapScheduleStatus) {
                paraTwapScheduleStatus.textContent = `立即触发失败：${err}`;
              }
            }
          }
          if (removeId) {
            evt.preventDefault();
            try {
              await removeParaTwapSchedulerTask(removeId);
            } catch (err) {
              if (paraTwapScheduleStatus) {
                paraTwapScheduleStatus.textContent = `删除任务失败：${err}`;
              }
            }
          }
        });

        paraTwapTaskRoot.addEventListener('change', async (evt) => {
          const el = evt?.target;
          if (!el) return;
          const toggleId = el.getAttribute && el.getAttribute('data-ptwap-task-toggle');
          if (!toggleId) return;
          try {
            await toggleParaTwapSchedulerTask(toggleId, Boolean(el.checked));
          } catch (err) {
            if (paraTwapScheduleStatus) {
              paraTwapScheduleStatus.textContent = `切换任务失败：${err}`;
            }
          }
        });
      }

      if (paraTwapScheduleResetSymbolButton) {
        paraTwapScheduleResetSymbolButton.addEventListener('click', () => {
          try {
            if (paraTwapScheduleSymbolsSelect) {
              paraTwapScheduleSymbolsSelect.selectedIndex = -1;
            }
          } catch (_) {
            // ignore
          }
        });
      }

      // Simulation inputs removed.
      if (pauseAllButton) {
        pauseAllButton.addEventListener('click', () => sendBatchControl('pause', pauseAllButton));
      }
      if (resumeAllButton) {
        resumeAllButton.addEventListener('click', () => sendBatchControl('resume', resumeAllButton));
      }
      // Spread/Strategy selector events removed.
      if (grvtAdjustAddButton) {
        grvtAdjustAddButton.addEventListener('click', () => sendGrvtAdjustment('add'));
      }
      if (grvtAdjustReduceButton) {
        grvtAdjustReduceButton.addEventListener('click', () => sendGrvtAdjustment('reduce'));
      }
      if (paraOrderModeSelect) {
        paraOrderModeSelect.addEventListener('change', updateTwapVisibility);
        updateTwapVisibility();
      }
      if (paraAdjustAddButton) {
        paraAdjustAddButton.addEventListener('click', () => sendParaAdjustment('add'));
      }
      if (paraAdjustReduceButton) {
        paraAdjustReduceButton.addEventListener('click', () => sendParaAdjustment('reduce'));
      }
      if (bpOrderModeSelect) {
        bpOrderModeSelect.addEventListener('change', updateBpTwapVisibility);
        updateBpTwapVisibility();
      }
      if (bpAdjustAddButton) {
        bpAdjustAddButton.addEventListener('click', () => sendBpAdjustment('add'));
      }
      if (bpAdjustReduceButton) {
        bpAdjustReduceButton.addEventListener('click', () => sendBpAdjustment('reduce'));
      }
      if (grvtResetSymbolButton) {
        grvtResetSymbolButton.addEventListener('click', () => {
          clearGrvtSymbolSelection();
        });
      }
      if (paraResetSymbolButton) {
        paraResetSymbolButton.addEventListener('click', () => {
          clearParaSymbolSelection();
        });
      }
      if (bpResetSymbolButton) {
        bpResetSymbolButton.addEventListener('click', () => {
          clearBpSymbolSelection();
        });
      }

      // Backpack adjust UI sanity check (ensures clicks are observable).
      validateBpAdjustDom();
      const selectAlternativeTarget = () => {
        if (!grvtTransferTargetSelect || !grvtTransferSourceSelect) {
          return;
        }
        if ((grvtTransferTargetSelect.options.length || 0) <= 1) {
          return;
        }
        if (grvtTransferTargetSelect.value !== grvtTransferSourceSelect.value) {
          return;
        }
        const options = Array.from(grvtTransferTargetSelect.options || []);
        const candidate = options.find((option) => option.value && option.value !== grvtTransferSourceSelect.value);
        if (candidate) {
          grvtTransferTargetSelect.value = candidate.value;
          applyGrvtTransferDefaults('target', { forceAll: true });
        }
      };
      const selectAlternativeParaTarget = () => {
        if (!paraTransferTargetSelect || !paraTransferSourceSelect) {
          return;
        }
        if ((paraTransferTargetSelect.options.length || 0) <= 1) {
          return;
        }
        if (paraTransferTargetSelect.value !== paraTransferSourceSelect.value) {
          return;
        }
        const options = Array.from(paraTransferTargetSelect.options || []);
        const candidate = options.find((option) => option.value && option.value !== paraTransferSourceSelect.value);
        if (candidate) {
          paraTransferTargetSelect.value = candidate.value;
          applyParaTransferDefaults('target', { forceAll: true });
        }
      };
      if (grvtTransferSourceSelect) {
        grvtTransferSourceSelect.addEventListener('change', () => {
          applyGrvtTransferDefaults('source', { forceAll: true });
          selectAlternativeTarget();
          updateGrvtTransferButtons();
          // loadSimulationData / updateSimulationFromInputs / handleSimOptimizeRequest removed.
        });
      }
      if (grvtTransferTargetSelect) {
        grvtTransferTargetSelect.addEventListener('change', () => {
          applyGrvtTransferDefaults('target', { forceAll: true });
          syncGrvtTransferSelectionStatus();
          updateGrvtTransferButtons();
        });
      }
      if (grvtTransferSubmitButton) {
        grvtTransferSubmitButton.addEventListener('click', () => {
          sendGrvtTransfer();
        });
      }
      if (riskHistoryRefreshButton) {
        riskHistoryRefreshButton.addEventListener('click', () => {
          loadRiskHistory({ silent: false });
        });
      }

      if (paraRiskHistoryRefreshButton) {
        paraRiskHistoryRefreshButton.addEventListener('click', () => {
          loadRiskHistory({ silent: false });
        });
      }

      if (bpRiskHistoryRefreshButton) {
        bpRiskHistoryRefreshButton.addEventListener('click', () => {
          loadRiskHistory({ silent: false });
        });
      }
      if (riskAlertEnabledInput) {
        riskAlertEnabledInput.addEventListener('change', () => {
          updateRiskInputsState();
          markRiskSettingsDirty();
        });
      }
      if (riskStaleEnabledInput) {
        riskStaleEnabledInput.addEventListener('change', () => {
          updateRiskInputsState();
          markRiskSettingsDirty();
        });
      }
      if (paraRiskAlertEnabledInput) {
        paraRiskAlertEnabledInput.addEventListener('change', () => {
          updateRiskInputsState();
          markParaRiskSettingsDirty();
        });
      }

      if (bpRiskAlertEnabledInput) {
        bpRiskAlertEnabledInput.addEventListener('change', () => {
          updateRiskInputsState();
          markBpRiskSettingsDirty();
        });
      }
      if (riskThresholdSlider) {
        riskThresholdSlider.addEventListener('input', (event) => {
          const value = clamp(Number(event.target.value), 5, 90);
          if (riskThresholdInput) {
            riskThresholdInput.value = value.toFixed(1);
          }
          updateRiskThresholdLabel(value);
          markRiskSettingsDirty();
        });
      }
      if (paraRiskThresholdSlider) {
        paraRiskThresholdSlider.addEventListener('input', (event) => {
          const value = clamp(Number(event.target.value), 5, 90);
          if (paraRiskThresholdInput) {
            paraRiskThresholdInput.value = value.toFixed(1);
          }
          updateRiskThresholdLabel(value);
          markParaRiskSettingsDirty();
        });
      }

      if (bpRiskThresholdSlider) {
        bpRiskThresholdSlider.addEventListener('input', (event) => {
          const value = clamp(Number(event.target.value), 5, 90);
          if (bpRiskThresholdInput) {
            bpRiskThresholdInput.value = value.toFixed(1);
          }
          updateRiskThresholdLabel(value);
          markBpRiskSettingsDirty();
        });
      }
      if (riskThresholdInput) {
        riskThresholdInput.addEventListener('input', () => {
          const value = clamp(Number(riskThresholdInput.value), 1, 90);
          if (Number.isFinite(value) && riskThresholdSlider) {
            riskThresholdSlider.value = value;
          }
          updateRiskThresholdLabel(value);
          markRiskSettingsDirty();
        });
      }
      if (riskStaleCriticalInput) {
        riskStaleCriticalInput.addEventListener('input', () => {
          markRiskSettingsDirty();
        });
      }
      if (paraRiskThresholdInput) {
        paraRiskThresholdInput.addEventListener('input', () => {
          const value = clamp(Number(paraRiskThresholdInput.value), 1, 90);
          if (Number.isFinite(value) && paraRiskThresholdSlider) {
            paraRiskThresholdSlider.value = value;
          }
          updateRiskThresholdLabel(value);
          markParaRiskSettingsDirty();
        });
      }

      if (bpRiskThresholdInput) {
        bpRiskThresholdInput.addEventListener('input', () => {
          const value = clamp(Number(bpRiskThresholdInput.value), 1, 90);
          if (Number.isFinite(value) && bpRiskThresholdSlider) {
            bpRiskThresholdSlider.value = value;
          }
          updateRiskThresholdLabel(value);
          markBpRiskSettingsDirty();
        });
      }
      [
        riskResetInput,
        riskCooldownInput,
        riskBarkUrlInput,
        riskBarkTimeoutInput,
        riskTitleTemplateInput,
        riskBodyTemplateInput,
      ].forEach((input) => {
        if (!input) {
          return;
        }
        input.addEventListener('input', markRiskSettingsDirty);
      });
      if (riskBarkAppendInput) {
        riskBarkAppendInput.addEventListener('change', markRiskSettingsDirty);
      }
      [
        paraRiskResetInput,
        paraRiskCooldownInput,
        paraRiskBarkUrlInput,
        paraRiskBarkTimeoutInput,
        paraRiskTitleTemplateInput,
        paraRiskBodyTemplateInput,
      ].forEach((input) => {
        if (!input) {
          return;
        }
        input.addEventListener('input', markParaRiskSettingsDirty);
      });

      [
        bpRiskResetInput,
        bpRiskCooldownInput,
        bpRiskBarkUrlInput,
        bpRiskBarkTimeoutInput,
        bpRiskTitleTemplateInput,
        bpRiskBodyTemplateInput,
      ].forEach((input) => {
        if (!input) {
          return;
        }
        input.addEventListener('input', markBpRiskSettingsDirty);
      });

      if (bpRiskSaveButton) {
        bpRiskSaveButton.addEventListener('click', () => {
          saveBpRiskSettings();
        });
      }
      if (riskSaveButton) {
        riskSaveButton.addEventListener('click', () => {
          saveRiskSettings();
        });
      }
      if (riskTestButton) {
        riskTestButton.addEventListener('click', () => {
          triggerRiskTest();
        });
      }
      if (riskRefreshButton) {
        riskRefreshButton.addEventListener('click', () => {
          loadRiskSettings({ silent: false });
        });
      }
      if (riskDisableButton) {
        riskDisableButton.addEventListener('click', () => {
          disableRiskAlerts();
        });
      }
      if (paraRiskSaveButton) {
        paraRiskSaveButton.addEventListener('click', () => {
          saveParaRiskSettings();
        });
      }
      if (paraRiskTestButton) {
        paraRiskTestButton.addEventListener('click', () => {
          triggerParaRiskTest();
        });
      }
      if (paraRiskRefreshButton) {
        paraRiskRefreshButton.addEventListener('click', () => {
          loadParaRiskSettings({ silent: false });
        });
      }
      if (paraRiskDisableButton) {
        paraRiskDisableButton.addEventListener('click', () => {
          disableParaRiskAlerts();
        });
      }
      if (bpRiskTestButton) {
        bpRiskTestButton.addEventListener('click', () => {
          triggerBpRiskTest();
        });
      }
      if (bpRiskRefreshButton) {
        bpRiskRefreshButton.addEventListener('click', () => {
          loadBpRiskSettings({ silent: false });
        });
      }
      if (bpRiskDisableButton) {
        bpRiskDisableButton.addEventListener('click', () => {
          disableBpRiskAlerts();
        });
      }
    updateGrvtSymbolOptions([]);
    updateParaSymbolOptions([]);
    updateGrvtTransferButtons();
    updateParaTransferButtons();
    updateAutoBalanceButtons();
    updateParaAutoBalanceButtons();
    updateBpAutoBalanceButtons();
    updateRiskButtons();
    loadRiskHistory({ silent: true });
    loadAutoBalanceConfig({ silent: true });
    loadParaAutoBalanceConfig({ silent: true });
    loadBpAutoBalanceConfig({ silent: true });
    loadRiskSettings({ silent: true });
  loadParaRiskSettings({ silent: true });
    loadBpRiskSettings({ silent: true });
    refreshMetrics();
    setInterval(refreshMetrics, 2000);

    </script>
  </body>
</html>
